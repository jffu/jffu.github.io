<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>jffu&#39;s blog</title>
<meta name="keywords" content="jffu&#39;s blog, jffu&#39;s blog">
<meta name="description" content="最近跟外面的一些公司聊了下AI相关的岗位，发现一个很有意思的现象：Agent 的巨大潜力，大家都看到了，然后都想搞一些事情，再然后想招一些搞过 Agent 的人，设了一些高高低低的要求。但深入点看的话，Agent 本质上非常简单，其实并没有">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="jffu&#39;s blog">
<meta property="og:description" content="最近跟外面的一些公司聊了下AI相关的岗位，发现一个很有意思的现象：Agent 的巨大潜力，大家都看到了，然后都想搞一些事情，再然后想招一些搞过 Agent 的人，设了一些高高低低的要求。但深入点看的话，Agent 本质上非常简单，其实并没有">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title"></h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2025-04-27</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>最近跟外面的一些公司聊了下AI相关的岗位，发现一个很有意思的现象：Agent 的巨大潜力，大家都看到了，然后都想搞一些事情，再然后想招一些搞过 Agent 的人，设了一些高高低低的要求。但深入点看的话，Agent 本质上非常简单，其实并没有什么技术门槛，只要理解大模型的能力以及 Agent 在此之上能做的事情，开发一个 Agent 就跟开发普通接口没有任何区别。</p>
<h1 id="从-Prompt-Engineering-到-Function-Call"><a href="#从-Prompt-Engineering-到-Function-Call" class="headerlink" title="从 Prompt Engineering 到 Function Call"></a>从 Prompt Engineering 到 Function Call</h1><p>现在是2025年，Prompt Engineering（提示词工程）大家都很熟悉了。假设你有这样一个需求：</p>
<blockquote>
<p>我要到某地去旅游，需要提前规划行程，比如订火车票，看看当地天气，有哪些美食推荐，等等</p>
</blockquote>
<p>在传统搜索引擎时代，你可能就是在百度或谷歌里，按照自己的要求，一个个需求查询，比如：</p>
<blockquote>
<ol>
<li>黄山适合哪个季节去？</li>
<li>黄山在5月份的天气怎么样？</li>
<li>黄山有什么推荐的美食和酒店，价格是多少？</li>
<li>12306订票网站</li>
</ol>
</blockquote>
<p>确实比较繁琐和割裂吧？而通过大模型，你可能会这么问：</p>
<blockquote>
<p>你是一个专业的行程规划导游，现在需要给人推荐黄山的二日游行程，请按照如下要求给出行程建议：</p>
<p>….省略一堆</p>
</blockquote>
<p>大模型会洋洋洒洒输出一堆，但新问题来了：我们都知道大模型的知识只停留在训练时的数据，它是无法感知实时的天气的，酒店的价格也不能指望它知道，更别提上12306给你查票了。</p>
<p>从这个简单的例子可以看出，我们不再满足于让大模型做简单的生成工作，而是想让其成为一个智能体 Agent，完成需要复杂编排和决策的任务，这时候可以调用外部工具的 Function Call 就出场了。</p>
<p>Function Call 简单来说，就是在常规的用户 prompt 基础上，把可用的工具列表也加到 prompt 中，让大模型来选择合适的工具和调用参数。</p>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/p1-2025-04-28-1437.svg"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/p1-2025-04-28-1437.svg"  alt="p1-2025-04-28-1437" lazyload></a></p>
<p>加入工具列表后，现在提示词可能长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">你是一个旅游行程规划助手，以下是你可用的工具列表：</span><br><span class="line">1. **天气查询** - 获取指定城市的天气信息</span><br><span class="line">   - 参数：&#123; &quot;city&quot;: &quot;城市名称&quot;, &quot;unit&quot;: &quot;温度单位，如&#x27;metric&#x27;或&#x27;imperial&#x27;&quot; &#125;</span><br><span class="line">2. **酒店查询** - 获取指定城市排名靠前的酒店信息</span><br><span class="line">    - 参数：&#123; &quot;city&quot;: &quot;城市名称&quot;, &quot;check_in&quot;: &quot;入住日期&quot;, &quot;check_out&quot;: &quot;退房日期&quot;, &quot;num_guests&quot;: &quot;客人数量&quot; &#125;</span><br><span class="line">3. **火车票预订** - 查询指定城市的火车票信息，并进行预订</span><br><span class="line">   - 参数：&#123; &quot;from_city&quot;: &quot;出发城市&quot;, &quot;to_city&quot;: &quot;目的城市&quot;, &quot;date&quot;: &quot;出发日期&quot; &#125;</span><br><span class="line">请对用户的请求进行决策，如果不需要借助工具则直接回答。若决策需要用工具，则选择合适的工具，并解析出需要的参数，按照以下 JSON 格式返回结果。输出应直接为 JSON 格式，不要输出其他内容。</span><br><span class="line">### 示例</span><br><span class="line">1. 用户请求: &quot;黄山的天气&quot;</span><br><span class="line">   输出:</span><br><span class="line">   ```json</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;tool&quot;: &quot;天气查询&quot;,</span><br><span class="line">     &quot;parameters&quot;: &#123;</span><br><span class="line">       &quot;city&quot;: &quot;黄山&quot;,</span><br><span class="line">       &quot;unit&quot;: &quot;metric&quot;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">2. 用户请求: &quot;黄山的推荐酒店&quot;</span><br><span class="line">   输出:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tool&quot;: &quot;酒店查询&quot;,</span><br><span class="line">  &quot;parameters&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &quot;黄山&quot;,</span><br><span class="line">    &quot;check_in&quot;: &quot;2023-10-01&quot;,</span><br><span class="line">    &quot;check_out&quot;: &quot;2023-10-02&quot;,</span><br><span class="line">    &quot;num_guests&quot;: 2</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">3. 用户请求: &quot;查询明天从上海到黄山北的火车票&quot;</span><br><span class="line">   输出:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tool&quot;: &quot;火车票查询&quot;,</span><br><span class="line">  &quot;parameters&quot;: &#123;</span><br><span class="line">    &quot;from_city&quot;: &quot;上海&quot;,</span><br><span class="line">    &quot;to_city&quot;: &quot;黄山北&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2023-10-01&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，根据以下用户请求生成响应：</span><br><span class="line">用户请求: &quot;帮我规划一个从上海到黄山的旅行，包含天气、酒店和火车票信息...&quot;</span><br></pre></td></tr></table></figure>

<p>当然大模型输出了工具和参数后，还需要一个调用执行的过程，整体流程大体长这样：</p>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/agent_flow.svg"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/agent_flow.svg"  alt="agent_flow" lazyload></a></p>
<p>这是代码的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 获取用户输入</span></span><br><span class="line">    user_question = <span class="built_in">input</span>(<span class="string">&quot;$ &quot;</span>)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_question&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用模型，生成函数调用请求</span></span><br><span class="line">    completion = client.chat.completions.create(</span><br><span class="line">        model=MODEL_NAME, messages=messages, tools=tools</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 将模型生成的消息加入对话历史</span></span><br><span class="line">        messages.append(completion.choices[<span class="number">0</span>].message)</span><br><span class="line">        <span class="keyword">if</span> completion.choices[<span class="number">0</span>].message.content:</span><br><span class="line">            <span class="built_in">print</span>(completion.choices[<span class="number">0</span>].message.content)</span><br><span class="line">        <span class="keyword">if</span> completion.choices[<span class="number">0</span>].finish_reason == <span class="string">&quot;stop&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果模型请求调用工具</span></span><br><span class="line">        <span class="keyword">for</span> tool_call <span class="keyword">in</span> completion.choices[<span class="number">0</span>].message.tool_calls:</span><br><span class="line">            name = tool_call.function.name</span><br><span class="line">            args = json.loads(tool_call.function.arguments)</span><br><span class="line">            <span class="comment"># 根据工具名称匹配到具体的工具，使用大模型生成的参数进行调用</span></span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;天气查询&quot;</span>:</span><br><span class="line">                result = get_weather(args[<span class="string">&quot;code&quot;</span>])</span><br><span class="line">            messages.append(&#123;</span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">                <span class="string">&quot;tool_call_id&quot;</span>: tool_call.<span class="built_in">id</span>,</span><br><span class="line">                <span class="string">&quot;content&quot;</span>: <span class="built_in">str</span>(result)</span><br><span class="line">            &#125;)</span><br><span class="line">          <span class="keyword">elif</span> name == <span class="string">&quot;酒店查询&quot;</span>:</span><br><span class="line">              <span class="comment">## TODO</span></span><br><span class="line">              <span class="keyword">pass</span></span><br><span class="line">          <span class="keyword">elif</span> name == <span class="string">&quot;火车票查询&quot;</span>:</span><br><span class="line">              <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 再次调用模型，让它基于工具返回结果生成最终回答</span></span><br><span class="line">        completion = client.chat.completions.create(</span><br><span class="line">            model=MODEL_NAME, messages=messages, tools=tools</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>



<h1 id="从-Function-Call-到-MCP"><a href="#从-Function-Call-到-MCP" class="headerlink" title="从 Function Call 到 MCP"></a>从 Function Call 到 MCP</h1><p>从上面的流程中可以看出，大模型需要能够做出正确的决策非常关键，包括选择合适的工具，确定正确的参数。因此实际应用中，往往还要对预训练的模型再进一步加上工具调用的样本去微调，微调后的后训练模型从中学会在合适的时机，决策需要调用合适的工具，最终成为一个适合作为 Agent 底座的模型。</p>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/2025-04-28-1437.svg"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/2025-04-28-1437.svg"  alt="2025-04-28-1437" lazyload></a></p>
<p>Function Call 本质上就是通过一个对话模板，拼接出一个包含了工具列表上下文的 prompt 给到大模型。以上面的天气查询为例，Qwen QwQ 32B模型拼出来的 prompt 长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;|im_start|&gt;system</span><br><span class="line"></span><br><span class="line">You may call one or more functions to assist with the user query.</span><br><span class="line"></span><br><span class="line">You are provided with function signatures within &lt;tools&gt;&lt;/tools&gt; XML tags:</span><br><span class="line">&lt;tools&gt;</span><br><span class="line">&#123;&quot;name&quot;: &quot;getWeather&quot;, &quot;description&quot;: &quot;获取指定城市的天气&quot;, &quot;parameters&quot;: &#123;&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123;&quot;city&quot;: &#123;&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;城市名称&quot;&#125;, &quot;date&quot;: &#123;&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;请求天气的日期&quot;&#125;&#125;, &quot;required&quot;: [&quot;city&quot;]&#125;&#125;</span><br><span class="line">&lt;/tools&gt;</span><br><span class="line"></span><br><span class="line">For each function call, return a json object with function name and arguments within &lt;tool_call&gt;&lt;/tool_call&gt; XML tags:</span><br><span class="line">&lt;tool_call&gt;</span><br><span class="line">&#123;&quot;name&quot;: &quot;&lt;function-name&gt;&quot;, &quot;arguments&quot;: &lt;args-json-object&gt;&#125;</span><br><span class="line">&lt;/tool_call&gt;&lt;|im_end|&gt;</span><br><span class="line"></span><br><span class="line">&lt;|im_start|&gt;user</span><br><span class="line">请查询杭州的天气&lt;|im_end|&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到有一些例如<code>&lt;tools&gt;</code>的 xml 标签，还有称为 special token 的<code>&lt;|im_start|&gt;</code>和<code>&lt;|im_end|&gt;</code>。虽然 OpenAI 第一个提出了 Function Call 的概念，但每个大模型厂家对这块的工具定义格式都不一样。比如 OpenAI 命名叫 <code>tool-calls</code>，LLaMa 则叫<code>function_call</code>，Gemini就叫<code>functionCall</code>。</p>
<p>Function Call 的问题简而言之，就是其<strong>每家都有自己的标准，API 实现对平台高度依赖</strong>。作为工具或服务提供方而言，适配一个模型就意味着写一套专门的适配代码。</p>
<p>由此就可以引出 <a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/introduction"><strong>MCP（Model Context Protocol）</strong></a>了。从名字上就可以看出，MCP 其实就是个协议，它是由 Claude 大模型厂商 Anthropic 提出的一个通用开放的协议，约定了LLM与工具交互的格式。套用一张官网将 MCP 与 USB-Type C 类比的图：</p>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/078dd739-b178-40fb-8249-935974d0e606.png"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/078dd739-b178-40fb-8249-935974d0e606.png"  alt="078dd739-b178-40fb-8249-935974d0e606" lazyload></a></p>
<p>MCP 遵循C&#x2F;S架构，定义了 <code>Host</code>、<code>Client</code>和<code>Server</code>三个角色：</p>
<ul>
<li><strong>Host</strong>：一个 AI 应用，为执行基于 AI 的任务提供环境，同时运行 MCP 客户端。 常用的就比如 Claude Desktop、Cursor、Cline等。</li>
<li><strong>Client</strong>： 与<code>Server</code>通信，运行在<code>Host</code>应用中。</li>
<li><strong>Server</strong>：服务提供方，遵循 MCP 协议暴露工具服务，包括3类能力：<ul>
<li><strong>Resources</strong>: 客户端可以读取的数据（如 API 响应或文件内容）</li>
<li><strong>Tools</strong>: LLM 在用户批准后可以调用的功能</li>
<li><strong>Prompts</strong>: 帮助用户完成特定任务的预先编写好的提示词模板</li>
</ul>
</li>
</ul>
<p>是不是非常简单？</p>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/ae2caa2f-88ff-4a3d-a223-fbea4f90ad19.gif"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/ae2caa2f-88ff-4a3d-a223-fbea4f90ad19.gif"  alt="ae2caa2f-88ff-4a3d-a223-fbea4f90ad19" lazyload></a></p>
<p>我在看 MCP 的介绍的时候，就一直在想，原来 MCP 就这么简单？但不可否认的是，凭借这套简单的约定，MCP 在极短的时间内就得到了诸多大模型厂商的支持（像 OpenAI 也已经支持 MCP），可以说 MCP 已经是事实上的标准。国内像阿里这类大模型领头羊的跟进速度也非常快，截止到今天 <a target="_blank" rel="noopener" href="https://www.modelscope.cn/mcp">ModelScope</a> 上已经有2432个 MCP 服务了。</p>
<h1 id="MCP-原理"><a href="#MCP-原理" class="headerlink" title="MCP 原理"></a>MCP 原理</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><blockquote>
<p>一个遵循 MCP 协议的 Agent 交互流程：</p>
<ol>
<li><p>客户端（Claude Desktop &#x2F; Cursor）将问题发送给 LLM。</p>
</li>
<li><p>LLM 分析可用的工具，并决定使用哪一个（或多个）。</p>
</li>
<li><p>客户端通过 MCP Server 执行所选的工具。</p>
</li>
<li><p>工具的执行结果被送回给 LLM。</p>
</li>
<li><p>LLM 结合执行结果，归纳总结后生成自然语言展示给用户。</p>
</li>
</ol>
</blockquote>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/c8fb95de-2cc3-4ee7-b0f5-b7160cbcf37d.png"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/c8fb95de-2cc3-4ee7-b0f5-b7160cbcf37d.png"  alt="c8fb95de-2cc3-4ee7-b0f5-b7160cbcf37d" lazyload></a></p>
<h2 id="Client-实现"><a href="#Client-实现" class="headerlink" title="Client 实现"></a>Client 实现</h2><p>MCP 的 <code>Client</code>维护与<code>Server</code>间的连接，直接看<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/python-sdk/blob/main/examples/clients/simple-chatbot/mcp_simple_chatbot/main.py">示例源码</a>，我删除了部分不重要的代码，加了中文注释。整体流程：</p>
<ol>
<li>获取得到 server 提供的 tool 工具列表，将每个 tool 的功能描述格式化成字符串，放到 LLM 的 system prompt 中（并指定 LLM 要返回的 JSON 格式）</li>
<li>同时将用户的输入作为 user prompt 传给 LLM</li>
<li>解析 LLM 返回的 JSON，根据 tool 名称和参数调用对应 server 的工具</li>
</ol>
<p><a class="simple-lightbox" href="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/e176a18f-0c9f-4c60-ae61-b4aa009c1db0.png"><img   src="/images/loading.svg" data-src="/Users/jffu/Documents/%E6%96%87%E7%AB%A0/%E9%85%8D%E5%9B%BE/agent_simple/e176a18f-0c9f-4c60-ae61-b4aa009c1db0.png"  alt="e176a18f-0c9f-4c60-ae61-b4aa009c1db0" lazyload></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 初始化所有的server</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">            <span class="keyword">await</span> server.initialize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将每个server提供的tools添加到all_tools中</span></span><br><span class="line">    all_tools = []</span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">        tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">        all_tools.extend(tools)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将每个tool的功能描述格式化成字符串，后面会用来提供给LLM，这样LLM可以根据用途选择合适的tool</span></span><br><span class="line">    tools_description = <span class="string">&quot;\n&quot;</span>.join([tool.format_for_llm() <span class="keyword">for</span> tool <span class="keyword">in</span> all_tools])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建system prompt，将上一步格式化的所有tool的功能描述放到LLM的上下文中</span></span><br><span class="line">    system_message = (</span><br><span class="line">        <span class="string">&quot;You are a helpful assistant with access to these tools:\n\n&quot;</span></span><br><span class="line">        <span class="string">f&quot;<span class="subst">&#123;tools_description&#125;</span>\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Choose the appropriate tool based on the user&#x27;s question. &quot;</span></span><br><span class="line">        <span class="string">&quot;If no tool is needed, reply directly.\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;IMPORTANT: When you need to use a tool, you must ONLY respond with &quot;</span></span><br><span class="line">        <span class="string">&quot;the exact JSON object format below, nothing else:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">        <span class="string">&#x27;    &quot;tool&quot;: &quot;tool-name&quot;,\n&#x27;</span></span><br><span class="line">        <span class="string">&#x27;    &quot;arguments&quot;: &#123;\n&#x27;</span></span><br><span class="line">        <span class="string">&#x27;        &quot;argument-name&quot;: &quot;value&quot;\n&#x27;</span></span><br><span class="line">        <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;&#125;\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;After receiving a tool&#x27;s response:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;1. Transform the raw data into a natural, conversational response\n&quot;</span></span><br><span class="line">        <span class="string">&quot;2. Keep responses concise but informative\n&quot;</span></span><br><span class="line">        <span class="string">&quot;3. Focus on the most relevant information\n&quot;</span></span><br><span class="line">        <span class="string">&quot;4. Use appropriate context from the user&#x27;s question\n&quot;</span></span><br><span class="line">        <span class="string">&quot;5. Avoid simply repeating the raw data\n\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Please use only the tools that are explicitly defined above.&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: system_message&#125;]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 省略部分代码，这里将用户的输入作为 user prompt 传给LLM</span></span><br><span class="line">            messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_input&#125;)</span><br><span class="line">            <span class="comment"># 现在有了 system prompt 和 user prompt，就可以调用 LLM 了</span></span><br><span class="line">            llm_response = self.llm_client.get_response(messages)</span><br><span class="line">            <span class="comment"># LLM 会返回一个 JSON 字符串，即我们在 system prompt 中定义的格式</span></span><br><span class="line">            result = <span class="keyword">await</span> self.process_llm_response(llm_response)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 LLM 响应的代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">process_llm_response</span>(<span class="params">self, llm_response: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># 解析json字符串，得到要调用的tool的名称和参数</span></span><br><span class="line">    tool_call = json.loads(llm_response)</span><br><span class="line">    <span class="comment"># 遍历所有的server和server提供的tool列表，根据名称匹配到对应的tool</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;tool&quot;</span> <span class="keyword">in</span> tool_call <span class="keyword">and</span> <span class="string">&quot;arguments&quot;</span> <span class="keyword">in</span> tool_call:</span><br><span class="line">        <span class="keyword">for</span> server <span class="keyword">in</span> self.servers:</span><br><span class="line">            tools = <span class="keyword">await</span> server.list_tools()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(tool.name == tool_call[<span class="string">&quot;tool&quot;</span>] <span class="keyword">for</span> tool <span class="keyword">in</span> tools):</span><br><span class="line">                result = <span class="keyword">await</span> server.execute_tool(</span><br><span class="line">                    tool_call[<span class="string">&quot;tool&quot;</span>], tool_call[<span class="string">&quot;arguments&quot;</span>]</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">return</span> <span class="string">f&quot;Tool execution result: <span class="subst">&#123;result&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;No server found with tool: <span class="subst">&#123;tool_call[<span class="string">&#x27;tool&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> llm_response</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 LLM 选择使用哪个工具，完全是基于工具的功能描述来的，所以对于工具开发者来说，文档描述非常重要！</p>
<h2 id="Server-实现"><a href="#Server-实现" class="headerlink" title="Server 实现"></a>Server 实现</h2><p>MCP 官方提供了一个天气查询的 <a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/quickstart/server">Server 样例</a>。直接照着写一遍就能得到一个可用的 MCP server 了。主要代码贴在下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化server,FastMCP是官方提供的便捷工具类，封装了一些常用的方法</span></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;weather&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键：使用@mcp.tool()装饰的方法会被识别为tool</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_alerts</span>(<span class="params">state: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get weather alerts for a US state.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        state: Two-letter US state code (e.g. CA, NY)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  	<span class="comment"># 省略具体实现，就是向指定api地址发起一个http请求，获取天气数据</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与上面的方法一样，是server提供的另一个tool</span></span><br><span class="line"><span class="meta">@mcp.tool()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_forecast</span>(<span class="params">latitude: <span class="built_in">float</span>, longitude: <span class="built_in">float</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get weather forecast for a location.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        latitude: Latitude of the location</span></span><br><span class="line"><span class="string">        longitude: Longitude of the location</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Initialize and run the server</span></span><br><span class="line">    mcp.run(transport=<span class="string">&#x27;stdio&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>还记得上面 client 实现部分中，提到的每个 server 要提供 tool 的功能描述吗？这里的关键在于<code> @mcp.tool()</code>这个装饰器，它会做两件事情：</p>
<ul>
<li>提取 python 函数的函数名以及 docstring 等（这就是功能描述字符串的来源），从函数构建出一个 tool</li>
<li>将构建的 tool 加到 server 的 tool 列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @mcp.tool()装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tool</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, name: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>, description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Callable</span>[[AnyFunction], AnyFunction]:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">fn: AnyFunction</span>) -&gt; AnyFunction:</span><br><span class="line">        self.add_tool(fn, name=name, description=description)</span><br><span class="line">        <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tool.from_function：获取函数名和docstring等作为tool的功能描述，从函数构建出一个tool</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">from_function</span>(<span class="params"></span></span><br><span class="line"><span class="params">     cls,</span></span><br><span class="line"><span class="params">     fn: <span class="type">Callable</span>,</span></span><br><span class="line"><span class="params">     name: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">     description: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">     context_kwarg: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"> </span>) -&gt; <span class="string">&quot;Tool&quot;</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Create a Tool from a function.&quot;&quot;&quot;</span></span><br><span class="line">     func_name = name <span class="keyword">or</span> fn.__name__ <span class="comment"># 获取函数名</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> func_name == <span class="string">&quot;&lt;lambda&gt;&quot;</span>:</span><br><span class="line">         <span class="keyword">raise</span> ValueError(<span class="string">&quot;You must provide a name for lambda functions&quot;</span>)</span><br><span class="line"> </span><br><span class="line">     func_doc = description <span class="keyword">or</span> fn.__doc__ <span class="keyword">or</span> <span class="string">&quot;&quot;</span> <span class="comment"># 获取函数 docstring</span></span><br><span class="line">     is_async = inspect.iscoroutinefunction(fn)</span><br><span class="line">     </span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>

<p>所以如果你要实现一个自己的 MCP server，要做的就是：写一个功能函数，写好函数名和注释，然后加上<code>@mcp.tool()</code>注解，done！当然最后还需要注册 server，不同的客户端（Claude Desktop、Cursor、Cline等）各不相同，这里就不赘述了。</p>
<h1 id="Agent-的本质和挑战"><a href="#Agent-的本质和挑战" class="headerlink" title="Agent 的本质和挑战"></a>Agent 的本质和挑战</h1><p>总结一下：</p>
<ul>
<li>Agent 本质上还是 Prompt Engineering，让大模型帮忙从一堆工具接口中选择合适的那一组</li>
<li>MCP 本质上也只是一个协议，它解决的是找接口和解析接口的问题（让大模型快速知道有哪些工具可以用）</li>
</ul>
<p>目前 Agent 和 MCP 还存在不少挑战，简单列了些我看到的问题和解法，欢迎补充。</p>
<ul>
<li>如何保证prompt的安全性？OpenAI提出了<a target="_blank" rel="noopener" href="https://openai.github.io/openai-agents-python/guardrails/">Guardrails</a>。</li>
<li>如何动态注册和下线 MCP server 或 tool？目前看到的是 Nacos 一类的注册中心有在尝试。</li>
<li>如果有很多 Agent，或者说 MCP server可以用，如果一股脑所有的信息放到 LLM 上下文，就会导致 Token 爆炸。如果能根据用户的问题或需求，先预筛选出可用的 Agent，那样会好很多。</li>
<li>对于复杂的流程，LLM 的上下文窗口是否放得下所有对话的信息？这必然涉及到信息的压缩。</li>
<li>快速爆发但良莠不齐的 Agent 生态，会否出现一个统一的 MCP 市场？如果没有管控，那就是下一个 npm？</li>
<li>身份认证、权限校验、安全防护要怎么做？还没有一个最佳实践。</li>
<li>MCP 的 SDK 语言还比较有限，目前只支持Python、Java、TS、Kotlin、C#（当然我相信很快就能解决）。</li>
<li>传统的工具服务如何快速改造甚至0代码就能转换成一个Agent或者 MCP server？是否可以通过一套协议转换机制就能实现？</li>
</ul>
<p>预测一下，未来企业架构中会出现一个跟 API 网关类似的 <strong>MCP 网关</strong>的角色，上面说的安全防护、动态注册、协议转换等等，都将是这个 MCP 网关的关键能力。</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%BB%8E-Prompt-Engineering-%E5%88%B0-Function-Call"><span class="top-box-text">从 Prompt Engineering 到 Function Call</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%BB%8E-Function-Call-%E5%88%B0-MCP"><span class="top-box-text">从 Function Call 到 MCP</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#MCP-%E5%8E%9F%E7%90%86"><span class="top-box-text">MCP 原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="top-box-text">工作流程</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Client-%E5%AE%9E%E7%8E%B0"><span class="top-box-text">Client 实现</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Server-%E5%AE%9E%E7%8E%B0"><span class="top-box-text">Server 实现</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Agent-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%8C%91%E6%88%98"><span class="top-box-text">Agent 的本质和挑战</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/01/09/guan-yu-han-shu-shi-bian-cheng-he-duo-xing-chu-shi-hua-de-yan-shen-si-kao/">
          <h3 class="post-title">
            下一篇：关于函数式编程和惰性初始化的延伸思考
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Go VS Java VS Kotlin：协程示例PK和思考</title>
<meta name="keywords" content="Go VS Java VS Kotlin：协程示例PK和思考, jffu&#39;s blog">
<meta name="description" content="Go、Java、Kotlin，各自协程的比较和思考。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Go VS Java VS Kotlin：协程示例PK和思考">
<meta property="og:description" content="Go、Java、Kotlin，各自协程的比较和思考。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Go VS Java VS Kotlin：协程示例PK和思考</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2022-11-14</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
                  ，
                
              </a>
            
              <a href="/tags/Go/">
              Go
                
                  ，
                
              </a>
            
              <a href="/tags/Kotlin/">
              Kotlin
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>这篇文章是对之前这篇<a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/249741">《虚拟线程：Java的新利器？》</a>的补充。为了让自己对不同语言的协程机制有更深入的理解，并且有一个更直观的对比，就上手写一些示例，写着写着发现过程中的思考值得记录下来，于是就有了这篇文章。这里不谈各个语言的协程底层原理，因为我认为本质上没什么差别，最大的不同无非是用的有栈&#x2F;无栈协程，调度器的设计等等，只从语法和API层面做个比较。</p>
<blockquote>
<p>以下示例参考自<a target="_blank" rel="noopener" href="https://mccue.dev/pages/5-2-22-go-concurrency-in-java">Go’s Concurrency Examples in Java 19</a>，删掉了其中我认为复杂或意义不大的示例，部分示例做了修改。</p>
</blockquote>
<h1 id="Example-1-Hello-World"><a href="#Example-1-Hello-World" class="headerlink" title="Example 1. Hello World"></a>Example 1. Hello World</h1><p>先来看下最简单示例：启动协程，然后say Hello World。</p>
<p><strong>Go:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="built_in">println</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的示例代码很简单，一个简单的<code>go</code>关键词就完成了协程的创建和启动。</p>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.jffu.examples.vt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">VirtualThreads</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">                 Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">            executor.submit(() -&gt; say(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">            say(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java代码使用了Java 19中新引入的虚拟线程API，<code>Executors.newVirtualThreadPerTaskExecutor()</code>会创建一个基于虚拟线程的<code>ExecutorService</code>，即开即用，非常简单。</p>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.runBlocking</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">5</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runBlocking &#123;</span><br><span class="line">       launch &#123;</span><br><span class="line">           say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin版本使用了<code>launch</code>库函数来创建一个协程，用<code>suspend</code>关键字来标识可以被协程执行的函数。</p>
<p>对比一下，第一感觉就是Java版的代码显得更”臃肿”，原因在于<code>Thread.sleep()</code>会抛出<code>InterruptedException</code>，这是一个受检异常，意味着你必须在某一层处理它。<code>InterruptedException</code>是一个很好的例子，大多数时候我们也不知道该怎么处理这类异常，所以最终选择就是：捕获，并忽略…</p>
<p>作为对比，Kotlin没有受检异常。<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/exceptions.html#checked-exceptions">Kotlin官方文档</a>里举了另一个典型的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Appendable <span class="title function_">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>每次追加一个字符串到<code>Appendable</code>（可以是一个 <code>StringBuilder</code>、某种日志、控制台等）上时，就必须捕获 <code>IOException</code>。 为什么？因为相应实现可能正在执行 IO 操作（<code>Writer</code> 也实现了 <code>Appendable</code>）。 其结果是这种代码随处可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    log.append(message)</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// Must be safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/effectivejava-136174.html">《Effective Java》第三版</a> 第 77 条说道：<em>不要忽略异常</em> 。</p>
<blockquote>
<p>Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result – decreased productivity and little or no increase in code quality.</p>
<p>通过一些小程序测试得出的结论是，异常规范会同时提高开发者的生产力与代码质量，然而，大型软件项目的经验得出了不同的结论—— 生产力降低了、代码质量几乎没有提高。</p>
</blockquote>
<p>关于受检异常的进一步思考可以参考下面的两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">Java’s checked exceptions were a mistake</a> (Rod Waldhoff)</li>
<li><a target="_blank" rel="noopener" href="https://www.artima.com/intv/handcuffs.html">The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</li>
</ul>
<p>为什么Java的受检异常是一个错误的设计？从我个人的经验看，受检异常带来的弊大于利。受检异常的初始意图是迫使API的调用方关注API调用过程中可能出现的特殊情况，这在自包含的程序内可能是有效的，但站在更上一层的调用方角度上，这会使得代码复杂化。很多时候上层的调用方并不想关心底层的各类异常，它做的最多的是在最外层使用一个<code>try-catch</code>捕获所有异常，然后统一进行处理。可以简单地列举出众多受检异常的”七宗罪”：</p>
<ul>
<li>底层的异常在上层看来并不太好理解</li>
<li>如果某一级的调用方不知道如何处理，它只有两个选择 <ul>
<li>将异常再往上抛，这只是把麻烦丢出去而已，所有的方法签名都要显式声明这一异常，而这一异常可能被定义在另一个库中</li>
<li>吃掉这个异常，转换成另一个在这一级定义的受检异常（把麻烦抛给再上一层），或者转换成<code>RuntimeException</code>（好像处理了异常，又好像什么都没做？）</li>
</ul>
</li>
<li>API的改动会导致调用方也被迫进行修改，一个例子：<code>foo</code>方法在版本1抛出了A、B、C三种异常，在版本2中又增加了新的异常D。对于<code>foo</code>的调用方而言，更新版本意味着要修改代码。</li>
</ul>
<blockquote>
<p>正如<strong>Anders Hejlsberg</strong>说，他对检查异常的担忧是这一设计给程序员戴上了手铐，程序员被迫在API设计者的”教育下”学习如何处理异常。</p>
</blockquote>
<p>从这个角度上讲，Go似乎也好不到哪去，想想满地的<code>err != nil</code>。</p>
<h1 id="Example-2-Channel"><a href="#Example-2-Channel" class="headerlink" title="Example 2. Channel"></a>Example 2. Channel</h1><p>很多时候协程并不是孤立的存在，彼此之间需要进行通信，而_channel_就是协程和协程间，协程和主线程间通信的桥梁。这个示例启动了两个协程对一个数组做分块求和。</p>
<p><strong>Go:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr []<span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	ch &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], ch)</span><br><span class="line">	<span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], ch)</span><br><span class="line">	x, y := &lt;-ch, &lt;-ch</span><br><span class="line">	<span class="built_in">println</span>(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go中goroutine通过<code>chan</code>给另一个goroutine发送值信息。每个_channel_都有一个特殊的类型，也就是_channel_可发送数据的类型。这里使用内置的<code>make</code>函数，创建了一个传输int类型的_channel_。创建后，就可以使用<code>&lt;-</code>运算符将数据发给_channel_和从_channel_中获取数据。</p>
<p><strong>Java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.jffu.examples.vt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Queues</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> start, <span class="type">int</span> end, BlockingQueue&lt;Integer&gt; queue)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            sum += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span>[] s = &#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                sum(s, <span class="number">0</span>, s.length / <span class="number">2</span>, queue);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                sum(s, s.length / <span class="number">2</span>, s.length, queue);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> queue.take();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;%d %d %d\n&quot;</span>, x, y, x + y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的标准库里没有_channel_的概念，所以这里用<code>BlockingQueue</code>来代替。</p>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.channels.Channel</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.launch</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.runBlocking</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(arr: <span class="type">List</span>&lt;<span class="type">Int</span>&gt;, channel: <span class="type">Channel</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    channel.send(arr.sum())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> s = listOf(<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(<span class="number">2</span>)</span><br><span class="line">        s.chunked(s.size / <span class="number">2</span>).forEach &#123;</span><br><span class="line">            launch &#123; sum(it, channel) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> x = channel.receive()</span><br><span class="line">        <span class="keyword">val</span> y = channel.receive()</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$x</span> <span class="variable">$y</span> <span class="subst">$&#123;x + y&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin的协程库里自带了原生的<code>Channel</code>，使用起来也很简单，用<code>send()</code>发，用<code>receive()</code>收。如果只需要发或者收，可以使用<code>Channel</code>的父类<code>SendChannel</code>和<code>ReceiveChannel</code>。</p>
<p>_Channel_是协程间通信的标准机制，就像Linux进程间通信使用的管道一样。Go和Kotlin对_channel_都有原生的支持，这一点上Java是欠缺的，只能用_BlockingQueue_来模拟。这两个概念虽然很像，但_BlockingQueue_无法完全替代_channel_，原因在于：</p>
<ul>
<li>_BlockingQueue_无法清晰地表达”数据传输完成”和”数据传输失败”这两者的区别； </li>
<li>无法关闭一个<code>BlockingQueue</code>，而_channel_是可以被关闭的，关闭后如果再使用_channel_收发数据，使用者应该能够收到一个错误 </li>
<li>_channel_往往会配套有多路复用的_select_操作，而_BlockingQueue_不支持</li>
</ul>
<p>在Java 19前，_BlockingQueue_提供的<code>put</code>和<code>take</code>是阻塞的，而_channel_的<code>send</code>和<code>receive</code>是挂起的，本质上是因为_BlockingQueue_不是为协程设计的。在<a target="_blank" rel="noopener" href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part2.html#channels">Project Loom的提案</a>里可以看到，Java的设计者们已经在考虑在Java中增加_channel_，但目前最新的Java 19中还未包含。未来可能会引入一个<code>Carrier</code>类型来支持_channel_功能，文档中给了一个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Carrier&lt;String&gt; carrier = <span class="keyword">new</span> <span class="title class_">Carrier</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">  Carrier.Sink&lt;String&gt; sink = carrier.sink();</span><br><span class="line">  sink.send(<span class="string">&quot;message1&quot;</span>);</span><br><span class="line">  sink.send(<span class="string">&quot;message2&quot;</span>);</span><br><span class="line">  sink.closeExceptionally(<span class="keyword">new</span> <span class="title class_">InternalError</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> (Carrier.Source&lt;String&gt; source = carrier.source()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> source.receive();</span><br><span class="line">      System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;consumer: &quot;</span> + e + <span class="string">&quot; cause: &quot;</span> + e.getCause());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">producer.join();</span><br><span class="line">consumer.join();</span><br></pre></td></tr></table></figure>

<p>除此之外，Java在简洁性上又输了…相较之下，Kotlin提供了许多集合的常用函数，比如上面用到的分块<code>chucked</code>（类似的还有切片<code>slice</code>）、求和<code>sum</code>等。</p>
<h1 id="Example-3-Range-and-Close"><a href="#Example-3-Range-and-Close" class="headerlink" title="Example 3. Range and Close"></a>Example 3. Range and Close</h1><p>第三个示例还是关于_channel_，展示如何在_channel_上遍历以及如何关闭一个_channel_。</p>
<p><strong>Go：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例使用协程计算了指定范围的斐波那契数列，计算完成后将结果发到_channel_中，然后关闭_channel_。消费者可以使用<code>range</code>操作从_channel_中获取数据。</p>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">interface</span> <span class="title class_">TakeResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">GotValue</span>&lt;T&gt;(T value) <span class="keyword">implements</span> <span class="title class_">TakeResult</span>&lt;T&gt; &#123;&#125;</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">NoValue</span>&lt;T&gt;() <span class="keyword">implements</span> <span class="title class_">TakeResult</span>&lt;T&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n, BlockingQueue&lt;TakeResult&lt;Integer&gt;&gt; queue)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue.put(<span class="keyword">new</span> <span class="title class_">TakeResult</span>.GotValue&lt;&gt;(x));</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp + x;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.put(<span class="keyword">new</span> <span class="title class_">TakeResult</span>.NoValue&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;TakeResult&lt;Integer&gt;&gt;(<span class="number">10</span>);</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                fibonacci(queue.remainingCapacity(), queue);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 从阻塞队列中读，只有GotValue是有效的，读到NoValue时停止</span></span><br><span class="line">            <span class="keyword">while</span> (queue.take() <span class="keyword">instanceof</span> TakeResult.GotValue&lt;Integer&gt; gotValue) &#123;</span><br><span class="line">                System.out.println(gotValue.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>BlockingQueue</code>不支持关闭，这里使用了<code>record</code>关键字声明了两个数据类<code>GotValue</code>和<code>NoValue</code>用来包装实际的结果，消费者通过<code>while</code>循环判断读到的是不是<code>GotValue</code>，当读到<code>NoValue</code>时停止接收。</p>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">(n: <span class="type">Int</span>, channel: <span class="type">Channel</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.n) &#123;</span><br><span class="line">        channel.send(x)</span><br><span class="line">        <span class="keyword">val</span> temp = x</span><br><span class="line">        x = y</span><br><span class="line">        y = temp + x</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;(n)</span><br><span class="line">        launch &#123;</span><br><span class="line">            fibonacci(n, channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (item <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            println(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin中可以使用<code>for</code>循环从_channel_中取值，非常方便，当然也可以使用<code>channel.consumeEach</code>一类的方法实现。</p>
<p>Go里的_channel_只有一种，而在Kotlin中，_channel_可以根据收&#x2F;发分成<code>SendChannel</code>和<code>ReceiveChannel</code>，也可以根据容量的配置分成UNLIMITED&#x2F;RENDEZVOUS&#x2F;CONFLATED&#x2F;BUFFERED 等类型，这个示例中的_channel_使用了带缓冲的_channel_。</p>
<p>Java的代码实现由于使用了_BlockingQueue_模拟，因此显得有些别扭。还有一个问题是如果有多个消费者的话，上面的代码会导致第一个消费者从<code>queue</code>里拿走<code>NoValue</code>值之后，其他消费者陷入阻塞。这正是上面所说的_BlockingQueue_无法代替_channel_的关键区别：_BlockingQueue_无法清晰地表述”数据传输完成”，也无法在完成后关闭。</p>
<h1 id="Example-4-Select"><a href="#Example-4-Select" class="headerlink" title="Example 4. Select"></a>Example 4. Select</h1><p>第四个示例展示_channel_的_select_操作。</p>
<p><strong>Go:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;- quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go提供了一个<code>select</code>操作，可以实现多个_channel_间的多路复用（跟Linux的<code>select</code>系统调用一样）。上面的示例中，假设需要中断计算，就可以通过给<code>quit</code>这个_channel_发送数据来实现。</p>
<p><strong>Java:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectQueues</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fibonacci</span><span class="params">(BlockingQueue&lt;Integer&gt; queue, AtomicBoolean quit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!quit.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.offer(x)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp + x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">quit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor())&#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(queue.take());</span><br><span class="line">                &#125;</span><br><span class="line">                quit.set(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            fibonacci(queue, quit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java没有<code>select</code>操作，因此折中方案是使用一个<code>AtomicBoolean</code>类型的<code>quit</code>值来作为退出标识，然后在<code>while</code>循环中遍历这个标识。说实话就这个示例而言我感觉这种方式更容易理解。</p>
<p><strong>Kotlin:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">fibonacci</span><span class="params">()</span></span> = produce &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        send(x)</span><br><span class="line">        <span class="keyword">val</span> temp = x</span><br><span class="line">        x = y</span><br><span class="line">        y = temp + x</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">quit</span><span class="params">()</span></span> = produce &#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    send(-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">val</span> fibonacci = fibonacci()</span><br><span class="line">            <span class="keyword">val</span> quit = quit()</span><br><span class="line">            <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">                select&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">                    fibonacci.onReceive &#123;</span><br><span class="line">                        println(it)</span><br><span class="line">                    &#125;</span><br><span class="line">                    quit.onReceiveCatching &#123;</span><br><span class="line">                        println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">                        coroutineContext.cancel()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin支持<code>select</code>操作（实验性feature），具体的用法可以参考<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/select-expression.html">官方文档</a>。上面的_select_语句块会等待两个_channel_的数据，哪个可用时就从哪个读取，在<code>quit</code>触发时调用<code>coroutineContext.cancel()</code>方法退出协程。</p>
<h1 id="Example-5-sync-Mutex"><a href="#Example-5-sync-Mutex" class="headerlink" title="Example 5: sync.Mutex"></a>Example 5: sync.Mutex</h1><p><a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/249741">前一篇文章</a>里有提到：多线程开发里容易出现的各种并发问题，例如共享变量的使用，在虚拟线程&#x2F;协程中一样免不了。那么怎么解决呢？答案是：加锁就对了…</p>
<blockquote>
<p>有两类程序员几乎不出多线程bug：一类是啥也不懂，只要涉及到多线程就直接上锁；另一类熟读内存模型、体系结构、缓存一致性协议、内存屏障、竞态条件、指令重排……然后决定只要涉及到多线程就直接上锁。 – 推上的段子，来自@象牙山刘能</p>
</blockquote>
<p><strong>Go：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">	v  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	c.v[key]++</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">	c.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line">	key := <span class="string">&quot;somekey&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> c.Inc(key)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(c.Value(key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个”协程安全”的计数器的示例。在Go中处理并发竞争的手段比较简单（或者说简陋？），那就是使用<code>sync.Mutext</code>加锁。原例中用的是<code>sync.Mutex</code>，这里我改成了读写锁<code>sync.RWMutext</code>，主要是为了跟Java版作对比。</p>
<p><strong>Java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.v = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v.put(key, v.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeCounter</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;somekey&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            Thread.startVirtualThread(() -&gt; c.inc(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        System.out.println(c.value(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java版本使用了读写锁<code>ReentrantReadWriteLock</code>，与Go中使用<code>defer</code>关键字释放锁类似，Java中对应的是<code>try-finally</code>。作为对比，Java的并发工具箱更加丰富，其实直接使用<code>AtomicInteger</code>或者<code>LongAdder</code>就可以了。</p>
<p>Kotlin版本写出来的代码与Java类似，这里就省略了。</p>
<p>这里比较有趣的一点是，Go里面没有可重入锁，因此你如果在同个goroutine中lock再lock，goroutine就会陷入死锁。Go语言的设计者认为”Recursive (aka reentrant) mutexes are a bad idea.”（<a target="_blank" rel="noopener" href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J?pli=1">原post参考这里</a>），如果你的代码中有对重入锁的诉求，那需要反过来思考下代码的合理性。</p>
<p>按照Go的理念，在工程中使用互斥锁（Mutex）的根本原因是：确保共享变量在程序执行时的关键点上能够保证不变性（invariant）。基于此，Go 在互斥锁设计上会遵守这几个原则：</p>
<ul>
<li>当一个goroutine在调用 <code>mutex.Lock</code> 方法获得了一个互斥锁时，能够确保被互斥锁保护的变量正处于不变状态，即没有其他代码块正在读写共享变量。</li>
<li>在调用 <code>mutex.Unlock</code> 方法释放互锁锁时，则说明程序不再需要依赖那些不变量，并且如果程序在互斥锁加锁期间破坏了它们，则需要确保已经恢复了它们。</li>
</ul>
<p>上面这段描述翻译过来比较拗口，我的理解是，调用方调用<code>mutex.Lock</code>时，需要能够得到保证，即调用方对被锁住的部分有完全的控制权（例如：锁住的共享变量不会在其他地方被改变），直到调用<code>mutex.Unlock</code>释放锁为止。可重入的设计违反了前面所提到的设计理念，也就是：”要保证这些变量的不变性保持，不会在后续的过程中被破坏”。</p>
<p>假设我们有这样一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    ... do some stuff ...</span><br><span class="line">    G()</span><br><span class="line">    ... do some more stuff ...</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    ... do some stuff ...</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们在 <code>F</code> 方法中调用 <code>mu.Lock</code> 方法加上了锁。如果支持可重入锁，那么 <code>G</code> 方法中就可以继续获取到锁并执行，<code>F</code>和<code>G</code>对彼此间对不变量的改动可能一无所知，实际项目这种情况会更糟糕，因此<code>F</code>和<code>G</code>中间可能还隔了好几层其他调用。</p>
<p>如何解决？一个通用的解决方案是将一个函数分离为多个函数，如下代码增加了一个不导出的方法<code>g</code>，调用<code>g</code>会执行实际的操作，而加锁的逻辑则放在外层的导出方法<code>F</code>和<code>G</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    ... do some stuff ...</span><br><span class="line">    g()</span><br><span class="line">    ... do some more stuff ...</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ... do some stuff ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">G</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    g()</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Go的互斥锁也<del>不支持非阻塞式地获取锁</del>（<code>tryLock</code>，直到1.18才有）或者超时获取锁（<code>lock(timeout)</code>），可能是觉得协程阻塞的代价很低？也可能这也是Go的设计理念，大道至简吧？<del>我个人是理解不了。</del></p>
<h1 id="Example-6-Web-Crawler"><a href="#Example-6-Web-Crawler" class="headerlink" title="Example 6: Web Crawler"></a>Example 6: Web Crawler</h1><p>最后的示例稍微复杂一些，是使用协程做web爬虫的示例。爬虫是典型的IO密集的场景，使用协程非常适合。</p>
<p><strong>Go:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Fetch Fetch方法接收一个url字符串，返回body体和包含的其他url</span></span><br><span class="line">	Fetch(url <span class="type">string</span>) (body <span class="type">string</span>, urls []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl 使用fetcher来递归地获取，直到最大深度depth为止，获取的结果保存到sync.Map中，使用sync.WaitGroup做同步控制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="type">string</span>, depth <span class="type">int</span>, fetcher Fetcher, urlMap *sync.Map, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	body, urls, err := fetcher.Fetch(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	urlMap.Store(url, body)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := urlMap.Load(u); !ok &#123;</span><br><span class="line">			wg.Add(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">go</span> Crawl(u, depth<span class="number">-1</span>, fetcher, urlMap, wg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	body <span class="type">string</span></span><br><span class="line">	urls []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher会返回预定义好的一组结果，当然用http.Client库实现一个真实的Fetcher也很简单</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="type">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span></span> Fetch(url <span class="type">string</span>) (<span class="type">string</span>, []<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;not found: %s&quot;</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">	<span class="string">&quot;https://golang.org/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;https://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;</span><br><span class="line">		<span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">		[]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">			<span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	urlMap := sync.Map&#123;&#125;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> Crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>, fetcher, &amp;urlMap, &amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	urlMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(url, body any)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;found: %s %q\n&quot;</span>, url, body)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个url的爬虫任务会启动一个协程，用<code>sync.WaitGroup</code>做同步控制。最终的结果需要保存到协程安全的map中，因此原始例子里自定义了一个<code>SafeUrlMap</code>，内部使用<code>sync.Mutex</code>加锁，这里我替换成了Go 1.9后新引入的<code>sync.Map</code>。</p>
<p><strong>Java版本1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fetcher</span> &#123;</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Result</span><span class="params">(String body, String[] urls)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">fetch</span><span class="params">(String url)</span> <span class="keyword">throws</span> FetcherException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FetcherException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    FetcherException(String message) &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是Java，面向接口编程，上来先定义对应的<code>Fetcher</code>接口。Java跟Go对于错误处理机制有不同的设计哲学：Go的错误是直接返回err，然后写<code>if err != nil</code>来处理错误，应该算是Unix C风格的沿袭；而在Java中是通过异常的抛出和捕获处理错误。另外，Go支持多返回值（这点好评），Java需要将结果封装到一个数据类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FakeFetcher</span> <span class="keyword">implements</span> <span class="title class_">Fetcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Result&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FakeFetcher</span><span class="params">(Map&lt;String, Result&gt; results)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.results = results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">fetch</span><span class="params">(String url)</span> <span class="keyword">throws</span> FetcherException &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> results.get(url);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FetcherException</span>(<span class="string">&quot;Not found: &quot;</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fetcher <span class="title function_">example</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FakeFetcher</span>(Map.of(</span><br><span class="line">            <span class="string">&quot;https://golang.org/&quot;</span>, <span class="keyword">new</span> <span class="title class_">Fetcher</span>.Result(</span><br><span class="line">                <span class="string">&quot;The Go Programming Language&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/cmd/&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/&quot;</span>, <span class="keyword">new</span> <span class="title class_">Fetcher</span>.Result(</span><br><span class="line">                <span class="string">&quot;Packages&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/cmd/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/pkg/os/&quot;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/fmt/&quot;</span>, <span class="keyword">new</span> <span class="title class_">Fetcher</span>.Result(</span><br><span class="line">                <span class="string">&quot;Package fmt&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="string">&quot;https://golang.org/pkg/os/&quot;</span>, <span class="keyword">new</span> <span class="title class_">Fetcher</span>.Result(</span><br><span class="line">                <span class="string">&quot;Package os&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">                    <span class="string">&quot;https://golang.org/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;https://golang.org/pkg/&quot;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现类<code>FakeFetcher</code>的实现与Go中大体类似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个与Go的sync.WaitGroup类似的WaitGroup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitGroup</span> &#123;</span><br><span class="line">    <span class="type">Phaser</span> <span class="variable">phaser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phaser</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        phaser.bulkRegister(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123;</span><br><span class="line">        phaser.arrive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> &#123;</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebCrawler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Fetcher fetcher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Fetcher.Result&gt; results = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebCrawler</span><span class="params">(Fetcher fetcher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fetcher = fetcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Fetcher.Result&gt; getResults() &#123;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">crawlTask</span><span class="params">(String url, <span class="type">int</span> depth, ExecutorService executor, WaitGroup waitGroup)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Fetcher.Result result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = fetcher.fetch(url);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FetcherException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            results.put(url, result);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String u : result.urls()) &#123;</span><br><span class="line">                <span class="comment">// 虽然用了ConcurrentHashMap，但实际上这一步可能会导致多个协程同时进入，不过对结果没有影响</span></span><br><span class="line">                <span class="keyword">if</span> (!results.containsKey(u)) &#123;</span><br><span class="line">                    waitGroup.add(<span class="number">1</span>);</span><br><span class="line">                    executor.submit(() -&gt; crawlTask(</span><br><span class="line">                        u,</span><br><span class="line">                        depth - <span class="number">1</span>,</span><br><span class="line">                        executor,</span><br><span class="line">                        waitGroup</span><br><span class="line">                    ));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            waitGroup.done();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crawl</span><span class="params">(String url, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">            <span class="type">WaitGroup</span> <span class="variable">waitGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitGroup</span>();</span><br><span class="line">            waitGroup.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            executor.submit(() -&gt; crawlTask(</span><br><span class="line">                url,</span><br><span class="line">                depth,</span><br><span class="line">                executor,</span><br><span class="line">                waitGroup</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">            waitGroup.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WebCrawler</span> <span class="variable">crawler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebCrawler</span>(FakeFetcher.example());</span><br><span class="line">        crawler.crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        crawler.getResults().forEach((url, result) -&gt; &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;Found %s %s\n&quot;</span>, url, result.body());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是爬虫任务的主要实现。Java中与Go的<code>sync.WaitGroup</code>功能类似的是<code>CountDownLatch</code>，但<code>CountDownLatch</code>只能在初始化时设置数量，不支持动态的<code>add()</code>。不过我们可以简单地用<code>Phaser</code>实现一个同样功能的<code>WaitGroup</code>（原始的例子中用了<code>synchronized</code>关键字实现）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WaitGroup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">jobs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        jobs += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (--jobs == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> </span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (jobs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java版本2：</strong></p>
<p>在上面的示例里，启动一个爬虫的任务会启动子任务<code>crawlTask</code>，在每个子任务中又会派生出新的子任务，为了等待所有这些子任务的完成，需要用<code>WaitGroup</code>来计数和等待。但换个角度看，这所有的任务归属于同一组，应该有相同的生命周期。进一步，思考这几个问题：</p>
<ol>
<li>当将一个任务拆分成多个子任务运行时，如何等待所有子任务完成？</li>
<li>结束一个任务时，如何同时结束这个任务中创建的子任务？</li>
<li>当某个子任务在执行时出错或被中断，如何结束其他尚未完成的子任务？</li>
</ol>
<p>我们可能已经习惯于使用共享标记位，或者使用<code>CountDownLatch/CyclicBarrier</code> 等辅助工具来解决上面的这些问题。Java 19引入了一个孵化中的特性：<strong>结构化并发（Structured Concurrency）</strong>，提供更优雅的解决方案。简单地说，结构化并发支持设置统一的作用域（scope），将在不同线程中运行的多个子任务视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观察性。</p>
<blockquote>
<p>关于结构化并发的更多介绍可以参考官方的<a target="_blank" rel="noopener" href="https://openjdk.org/jeps/428">JEP</a>，讲得很详细。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">crawlTask</span><span class="params">(String url, <span class="type">int</span> depth,</span></span><br><span class="line"><span class="params">                       StructuredTaskScope.ShutdownOnFailure structuredTaskScope)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fetcher.Result result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = fetcher.fetch(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FetcherException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    results.put(url, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String u : result.urls()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!results.containsKey(u)) &#123;</span><br><span class="line">            submitTask(u, depth - <span class="number">1</span>, structuredTaskScope);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitTask</span><span class="params">(String url, <span class="type">int</span> depth,</span></span><br><span class="line"><span class="params">                        StructuredTaskScope.ShutdownOnFailure structuredTaskScope)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用structuredTaskScope.fork会创建一个新的虚拟线程执行任务</span></span><br><span class="line">    structuredTaskScope.fork(() -&gt; &#123;</span><br><span class="line">            crawlTask(</span><br><span class="line">                url,</span><br><span class="line">                depth,</span><br><span class="line">                structuredTaskScope</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crawl</span><span class="params">(String url, <span class="type">int</span> depth)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 使用结构化并发将所有任务置于同一scope内</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">structuredTaskScope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">        submitTask(url, depth, structuredTaskScope);</span><br><span class="line">        structuredTaskScope.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Kotlin:</strong></p>
<p>Kotlin天然就支持结构化并发，只要把任务放在同一个<code>CoroutineScope</code>即可。比如在kotlin代码里，应用入口往往有一个<code>runBlocking</code>调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebCrawler</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fetcher: Fetcher, <span class="keyword">val</span> results: MutableMap&lt;String, Result&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">crawl</span><span class="params">(url: <span class="type">String</span>, depth: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result: Result</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = fetcher.fetch(url)</span><br><span class="line">            results[url] = result</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: FetcherException) &#123;</span><br><span class="line">            println(e.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一组子任务放到同一个coroutineScope中</span></span><br><span class="line">        coroutineScope &#123;</span><br><span class="line">            <span class="keyword">for</span> (u <span class="keyword">in</span> result.urls) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!results.contains(u)) &#123;</span><br><span class="line">                    launch &#123; crawl(u, depth - <span class="number">1</span>) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// runBlocking会阻塞等待所有协程完成</span></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> crawler = WebCrawler(FakeFetcher.example(), ConcurrentHashMap())</span><br><span class="line">        crawler.crawl(<span class="string">&quot;https://golang.org/&quot;</span>, <span class="number">4</span>)</span><br><span class="line">        crawler.results.forEach &#123; (url, result) -&gt; println(<span class="string">&quot;Found <span class="variable">$url</span> <span class="subst">$&#123;result.body&#125;</span>&quot;</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单地做个小结：</p>
<ol>
<li>Go &amp; Java &amp; Kotlin的协程API设计得都非常简单易用，一定要比较的话，Java的历史包袱拖了一些后腿，不像另外两者生来就对协程有很好的支持（例如：可以用一个关键词或库函数就启动协程）。</li>
<li>相比起Go和Kotlin，Java缺少了对_channel_的支持，虽然可以用_BlockingQueue_替代一些场景，但_BlockingQueue_无法清晰地表达”数据传输完成”和”数据传输失败”这两者的区别，也不支持_Range_、_Close_、_Select_等操作。不过我相信在未来的版本里很快就能见到Java版_channel_。</li>
<li>Go的优势在于足够简单，而Java的优势在于有丰富的并发API。当然两者都在不断完善，像Go的新版本标准库中引入了<code>sync.Map</code>、<code>mutex.tryLock()</code>等特性。</li>
<li>如果想简洁和功能性兼具，不妨考虑下Kotlin。</li>
</ol>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-1-Hello-World"><span class="top-box-text">Example 1. Hello World</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-2-Channel"><span class="top-box-text">Example 2. Channel</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-3-Range-and-Close"><span class="top-box-text">Example 3. Range and Close</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-4-Select"><span class="top-box-text">Example 4. Select</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-5-sync-Mutex"><span class="top-box-text">Example 5: sync.Mutex</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#Example-6-Web-Crawler"><span class="top-box-text">Example 6: Web Crawler</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2022/10/25/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9AJava%E7%9A%84%E6%96%B0%E5%88%A9%E5%99%A8%EF%BC%9F/">
          <h3 class="post-title">
            下一篇：虚拟线程：Java的新利器？
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>


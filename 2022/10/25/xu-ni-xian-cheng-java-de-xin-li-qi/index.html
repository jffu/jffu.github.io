<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>虚拟线程：Java的新利器？</title>
<meta name="keywords" content="虚拟线程：Java的新利器？, jffu&#39;s blog">
<meta name="description" content="深入聊聊Java的新特性：虚拟线程。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="虚拟线程：Java的新利器？">
<meta property="og:description" content="深入聊聊Java的新特性：虚拟线程。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">虚拟线程：Java的新利器？</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2022-10-25</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>之前写了一篇文章《一些杂想：Java老矣，尚能饭否？》，里面简单聊了一下<a target="_blank" rel="noopener" href="https://openjdk.org/projects/loom/">Project Loom</a>和Java版的协程。自从Go凭着goroutine又带火了协程这个概念，连近亲Kotlin也有了协程，Java终于坐不住了，最新的release 19里带来了Java版协程，即虚拟线程（_Virtual Thread_）。不过目前还只是Preview阶段，按以往的尿性判断，正式可用估计要等到起码Java 21了<del>（不过，对于万年Java 8的我们有区别吗？）</del>。写这篇文章的目的，就是梳理一下我的理解，顺便捋一捋Java线程的过去、现在和未来。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fnvb21RW8gECNivquhaf_0EyXvEL.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fnvb21RW8gECNivquhaf_0EyXvEL.png"  lazyload></a></p>
<h1 id="线程简史"><a href="#线程简史" class="headerlink" title="线程简史"></a>线程简史</h1><h2 id="Java线程发展史"><a href="#Java线程发展史" class="headerlink" title="Java线程发展史"></a>Java线程发展史</h2><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmqDISaj7MwGQSD2esFIK_Z29imA.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmqDISaj7MwGQSD2esFIK_Z29imA.png"  lazyload></a><br>在Java刚被创建出来时，JVM使用的是绿色线程（_Green Thread_）。实际上在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_thread">维基百科的绿色线程定义</a>里，绿色线程和虚拟线程是等价的，即由运行库或虚拟机而非底层OS负责调度的线程。关于绿色线程，很重要的两点：</p>
<ul>
<li>用户态线程，而非内核线程</li>
<li>由应用层（譬如JVM或者其他Runtime）负责调度，而非OS</li>
</ul>
<p>彼时像 Sun Solaris 这样的系统一次只能处理一个绿色线程，虽然在用户态有多个绿色线程，但所有线程都映射到同一个OS线程中执行，所以说实际上这是一种多对一的线程模型，无法真正利用CPU的多核能力。还会带来一些副作用，譬如说：</p>
<ul>
<li>系统调用会阻塞所有绿色线程 </li>
<li>内核级别的Page Fault会影响所有绿色线程</li>
</ul>
<p>因此Sun在后面的实现里就废弃了绿色线程，而改用一对一的线程模型。</p>
<blockquote>
<p>线程模型（参考<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3461/6jck06gqe/index.html">JDK 1.1 for Solaris Developer’s Guide</a>）：</p>
<ul>
<li>多对一<br>即绿色线程使用的线程模型，多条用户态的绿色线程映射到同一条OS线程。</li>
</ul>
</blockquote>
<blockquote>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb6.eps.gif#id=p36AD&originHeight=337&originWidth=262&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img   src="/images/loading.svg" data-src="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb6.eps.gif#id=p36AD&originHeight=337&originWidth=262&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="  lazyload></a></p>
<ul>
<li>一对一<br>目前大部分语言实现采用的线程模型，用户态的线程一对一映射到内核线程上，好处是实现简单，统一由操作系统负责调度，需要注意不要创建过多的线程。</li>
</ul>
</blockquote>
<blockquote>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb7.eps.gif#id=a2YCe&originHeight=343&originWidth=212&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img   src="/images/loading.svg" data-src="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb7.eps.gif#id=a2YCe&originHeight=343&originWidth=212&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="  lazyload></a></p>
<ul>
<li>多对多<br>经典的就是Erlang的进程和Go的goroutine，M:N 的映射关系，大量（M）虚拟的线程被调度在较少数量（N）的操作系统线程上运行。用户态的运行时负责调度用户态线程，OS则只需要负责OS线程，各司其职。灵活度更高，开发者基本不用担心线程数爆炸的问题。</li>
</ul>
</blockquote>
<blockquote>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb8.eps.gif#id=ZkfHW&originHeight=337&originWidth=311&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img   src="/images/loading.svg" data-src="https://docs.oracle.com/cd/E19455-01/806-3461/images/nancb8.eps.gif#id=ZkfHW&originHeight=337&originWidth=311&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="  lazyload></a></p>
</blockquote>
<p>不过，需要指明的是，Java规范本身并没有规定说需要采用哪种线程模型，事实上，它特别指出：</p>
<blockquote>
<p>“These semantics do not prescribe how a multithreaded program should be executed. Rather, they describe the behaviors that multithreaded programs are allowed to exhibit. Any execution strategy that generates only allowed behaviors is an acceptable execution strategy.”</p>
</blockquote>
<p>与此对应的是直到今天仍有像<a target="_blank" rel="noopener" href="http://www.jikesrvm.org/">Jikes RVM</a>之类的虚拟机还在使用绿色线程。绿色线程并非完全一无是处，它可以在不支持多线程的平台上模拟多线程。由于映射到同一个CPU核，所有的内容都在一个系统进程里面执行，还可以带来一些好处，这些优势在后面的虚拟线程里也能看到：</p>
<ul>
<li>线程的切换很快</li>
<li>分配线程的开销很低：一方面是创建和销毁很快，另一方面内存使用也更少</li>
<li>竞态条件和线程同步处理起来更简单</li>
</ul>
<p>我猜测Java最开始使用绿色线程是响应其 “Write Once，Run Anywhere” 的slogan，因为绿色线程是用户态的，并不依赖具体OS（可能有些操作系统根本就没有提供多线程能力）。</p>
<blockquote>
<p>为什么叫”绿色”线程？这个我没有找到标准答案，一种有趣的说法是：在美国，如果你不是原生的 (Native) ，那你就要有一张绿卡（Green Card）。</p>
</blockquote>
<p>JDK1.2中增加了一个可以切换绿色线程和本地线程的开关，然后在JDK 1.3之后被彻底弃用，在此之后其实Java的底层线程模型就没有大的改动了，更多的是API层面的：</p>
<ol>
<li>JDK 1.4引入了NIO包（<code>java.nio</code>），与此对应的是BIO（Blocking IO），很多Java Web容器的线程模型介绍里都能看到过这两个概念。</li>
<li>JDK 1.5算是一个里程碑版本，J.U.C（<code>java.util.concurrent</code>）下新增了<code>Executor</code>, <code>Semaphore</code>, <code>Lock</code>、<code>CyclicBarrier</code>, <code>CountDownLatch</code>, <code>BlockingQueue</code>、<code>Atomic Variables</code>以及一系列现在我们常用的并发集合类。在这之前，程序员只能使用像<code>synchronized</code>、<code>volatile</code>、 <code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>这些低级并发原语来控制并发。</li>
<li>JDK 1.7 引入了<code>ForkJoinPool</code>和<code>NIO2</code>（主要是<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/10/docs/api/java/nio/file/package-summary.html">java.nio.file</a>），此外还有<code>TransferQueue</code>, <code>ConcurrentLinkedDeque</code>, <code>ThreadLocalRandom</code>等小更新。</li>
<li>JDK 1.8的<code>Parallel Steam</code>API，<code>CompletableFuture</code>特性。</li>
<li>Java 9 ~ Java 18：<code>return Optional.empty();</code>…</li>
</ol>
<p>现在，虚拟线程来啦。<br><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fo8JEjW1D5XqADgobGw4wLx7TkO7.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fo8JEjW1D5XqADgobGw4wLx7TkO7.png"  lazyload></a></p>
<h2 id="为什么要有虚拟线程？"><a href="#为什么要有虚拟线程？" class="headerlink" title="为什么要有虚拟线程？"></a>为什么要有虚拟线程？</h2><p>先看看虚拟线程能带来什么。虚拟线程拥有与上面所说的绿色线程的一样的优点，简而言之：虚拟线程相比普通线程更轻量，分配和切换的开销更小。所以如果你需要很多的线程，并且线程之间经常发生切换，那就可以考虑换成虚拟线程。</p>
<p>Java现有的线程实现是OS线程的一层thin wrapper，OS线程的优点是它足够通用，不管是什么语言&#x2F;什么应用场景，但OS线程的问题也正是来自于此：</p>
<ul>
<li>OS不知道用户态的程序会如何使用线程，它会给每条线程分配一个固定大小的堆栈，通常会比实际使用的要大很多</li>
<li>线程的上下文切换要通过内核调度进行，相对更慢</li>
<li>线程的调度算法需要做兼顾和妥协，很难做特定的优化，像web server中处理请求的线程和视频编解码的线程行为有很大的区别</li>
</ul>
<p>OS线程的昂贵开销限制了Java程序不能创建太多的线程。在其他资源（例如 CPU 或网络连接）耗尽之前，线程的数量往往会成为限制因素，导致硬件资源不能得到充分利用。如果没有很好的编程技巧，不小心写了会导致线程阻塞的逻辑，那就GG了。这就形成了一种尴尬的局面：我用Java写代码，还需要特别小心线程怎么使用，线程池怎么配置等等跟我业务无关的东东，<del>我用goroutine一把梭不香吗？</del>从这个层面讲，使用虚拟线程的好处，就像程序不用关心虚拟内存和物理内存一样，开发者可以专注于编写简单的、也许会阻塞的代码 —— 然后交由JVM负责调度到共享的OS线程，以将阻塞成本降低到接近于零。虚拟线程与虚拟内存如此相似，可能这也是为何命名从一开始的纤程（Fiber）改为”虚拟线程”的原因。</p>
<table>
<thead>
<tr>
<th></th>
<th>OS线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>堆栈大小</strong></td>
<td>&gt;2KB 元数据</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>&#x3D;1M栈 | 200-300B 元数据<br>灵活伸缩的栈大小 |<br>| <strong>上下文切换</strong> | 1-10μs | 200ns |</p>
</blockquote>
<p>另一方面，虚拟线程不能带来什么？要意识到虚拟线程是更轻量的线程，但并不是”更快”的线程，它每秒执行的CPU指令并不会比普通线程要多。还是举之前写的例子，假设有这样一个场景，需要同时启动10000个任务做一些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个虚拟线程的Executor，该Executor每执行一个任务就会创建一个新的虚拟线程</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; &#123;</span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  <span class="comment">// executor.close() is called implicitly, and waits</span></span><br></pre></td></tr></table></figure>

<p>考虑两种场景：</p>
<ol>
<li>如果<code>doSomething()</code>里执行的是某类IO操作，那么使用虚拟线程是非常合适的，因为虚拟线程创建和切换的代价很低，底层对应的可能只需要几个OS线程。如果没有虚拟线程，不考虑<code>ForkJoin</code>之类的工具，使用普通线程的话：</li>
</ol>
<ul>
<li>把<code>Executors.newVirtualThreadPerTaskExecutor()</code>换成<code>Executors.newCachedThreadPool()</code>。结果是程序会崩溃，因为大多数操作系统和硬件不支持这种规模的线程数。 </li>
<li>换成<code>Executors.newFixedThreadPool(200)</code>或者其他自定义的线程池，那这10000个任务将会共享200个线程，许多任务将按顺序运行而不是同时运行，并且程序需要很长时间才能完成。</li>
</ul>
<ol start="2">
<li>如果<code>doSomething()</code>里执行的是某类计算任务，例如给一个大数组排序，那么虚拟线程反而还可能带来多余的开销。</li>
</ol>
<p>总结一下，虚拟线程真正擅长的是<strong>等待</strong>，等待大量阻塞操作完成。它能提供的是 scale（更高的吞吐量），而不是 speed（更低的延迟）。虚拟线程最适合的是原来需要更多线程数来处理计算无关业务的场景，典型的就是像web容器、数据库、文件操作一类的IO密集型的应用。</p>
<h2 id="为什么现在才有虚拟线程？"><a href="#为什么现在才有虚拟线程？" class="headerlink" title="为什么现在才有虚拟线程？"></a>为什么现在才有虚拟线程？</h2><p>为什么Java迟迟没有引入协程，而是等到今天才有了虚拟线程？我个人觉得，一方面是Java说好听点叫保守，说难听点就是有点”不思进取”，另一方面是Java现有的工具箱不是不能用，只是不够好用。Java语言本身发展到现在已经非常成熟，加上很神奇的一点是它的生态里有各种框架帮它添砖加瓦，譬如：</p>
<ol>
<li>创建和销毁线程的开销太大？Java给了你线程池，前提是你要清楚怎么配置好一个线程池；</li>
<li>线程池搭配 one thread per connection 的BIO在碰到大量连接+阻塞时不好用，于是Java引入了NIO，IO多路复用后几条线程就能支撑海量的连接数；</li>
<li>原生的NIO API实在太难用，于是就有了Netty，现在已经是Java世界的通用网络IO库；</li>
<li>异步+回调写起来很麻烦，可以试试响应式编程的思路， <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">RxJava</a> 或者 <a target="_blank" rel="noopener" href="https://projectreactor.io/">Project Reactor</a>  ，当然 <a target="_blank" rel="noopener" href="https://vertx.io/">Vert.x</a> 也不错；</li>
</ol>
<p>这么一看，确实没有什么一定要用虚拟线程才能解决的事情，而多线程开发里容易出现的各种并发问题，例如共享变量的使用，在虚拟线程中一样免不了，可以理解为什么Java在推进这个事情上动力不足了。</p>
<p>但是，正如这篇OpenJDK官网上的Loom提案<a target="_blank" rel="noopener" href="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html">《Project Loom: Fibers and Continuations for the Java Virtual Machine》</a>里所说，我们使用这些异步 API ，并不是因为它们更容易理解和编写 —— 实际上它们更难；不是因为它们更容易调试或分析 —— 实际上它们甚至不会产生有意义的堆栈跟踪；不是因为它们比同步 API 编写得更好——它们编写得不那么优雅；不是因为它们更适合这门语言或是与现有代码能更好地集成——它们更不适合。归根到底，原因是线程作为 Java 中并发编程的基础单元，从占用空间和性能的角度来看是不够的。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FurRtPn8YO5kSWKU37q0bTp-dE_n.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FurRtPn8YO5kSWKU37q0bTp-dE_n.png"  lazyload></a><br>为了最大化性能，开发者确实太难了。有没有可能”既要，又要，还要”呢？虚拟线程带来了希望之光，那就是用同步编程的方式，写出跟异步一样性能的代码。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FiTqomfjsAf_W9J1WTzZPvBrX1d6.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FiTqomfjsAf_W9J1WTzZPvBrX1d6.png"  lazyload></a></p>
<h2 id="曲线救国的实现"><a href="#曲线救国的实现" class="headerlink" title="曲线救国的实现"></a>曲线救国的实现</h2><p>既然官方一直没有提供，而人民确实有需求，民间自然涌现了一些曲线救国的实现，像<a target="_blank" rel="noopener" href="https://github.com/puniverse/quasar">Quasar</a>、<a target="_blank" rel="noopener" href="https://github.com/kilim/kilim">Kilim</a>、<a target="_blank" rel="noopener" href="https://github.com/electronicarts/ea-async">ea-async</a>。</p>
<p>Quasar的项目作者<a target="_blank" rel="noopener" href="https://github.com/pron">Ron Pressler</a>同样也是Project Loom的主导者之一，所以我重点看了下Quasar的实现原理。简单说其实现思路是通过字节码注入的方式在方法调用前后做堆栈的保存和恢复，其他几个库的实现原理也大体类似，大体流程如下：</p>
<ol>
<li>在class被加载时，Quasar的<code>instrumentation</code>模块（通常是以Java agent的方式挂载，也支持AOT编译）查找其中的<code>Suspendable</code>方法</li>
<li>为每个<code>Suspendable</code>方法<code>f</code>做instrument，先查找对其他<code>Suspendable</code>方法<code>g</code>的调用，在调用的前后插入保存和恢复栈帧的指令，每个 fiber 有一个自己的 fiber 栈</li>
<li>记录对方法<code>g</code>的调用是一个可能的挂起点</li>
<li>在这个“可挂起调用链”的末尾，有一个对<code>Fiber.park</code>的调用。<code>park</code>通过抛出<code>SuspendExecution</code>异常来挂起 fiber</li>
<li>如果<code>g</code>确实阻塞，那么<code>Fiber</code>类将捕获<code>SuspendExecution</code>异常。当fiber被<code>unpark</code>时，将调用方法<code>f</code>，然后执行记录将显示是在调用<code>g</code>时被阻塞，因此将立即跳到<code>f</code>中调用<code>g</code>的行，并调用它</li>
<li>最后到达实际的挂起点（对<code>park</code>的调用处），在调用后立即恢复执行。当<code>g</code>返回时，插入<code>f</code>中的代码将从 fiber 栈中恢复<code>f</code>的局部变量</li>
</ol>
<blockquote>
<p>这个流程看上去比较复杂，Quasar号称性能损失不会超过3%-5%。感兴趣的可以研究下源代码，注入的逻辑主要在<code>InstrumentMethod</code>这个类里。</p>
</blockquote>
<p>从上面的流程里可以看到，关键的一点是开发者需要手动标记哪些方法是<code>Suspendable</code>方法，这有几种方式：</p>
<ul>
<li>方法上加了 <code>@Suspendable</code> 注解 </li>
<li>方法抛出了<code>SuspendExecution</code>（这是Quasar定义的异常类型） </li>
<li>在<code>META-INF/suspendables</code>和<code>META-INF/suspendable-supers</code>下指定，主要是用于无法直接修改代码的第三方库 </li>
<li>其他的像是反射调用的方法，lambda调用等</li>
</ul>
<p>Quasar默认使用一个 <code>[FiberForkJoinScheduler](http://docs.paralleluniverse.co/quasar/javadoc/co/paralleluniverse/fibers/FiberForkJoinScheduler.html)</code> 来调度fiber，底层使用了<code>ForkJoinPool</code>。当然你也可以设置其他的线程池。</p>
<p>Quasar项目在18年之后就不再更新，这哥们转头就加入Oracle搞Project Loom去了。像Quasar这类工具，并没有流行起来，我觉得除去Java协程这个概念的接受度不高的因素外，工具本身的成熟度也不够，最致命的是存在侵入性，比如说<code>Suspendable</code>方法的声明，运行期的agent挂载。</p>
<h1 id="上手虚拟线程"><a href="#上手虚拟线程" class="headerlink" title="上手虚拟线程"></a>上手虚拟线程</h1><h2 id="API上手"><a href="#API上手" class="headerlink" title="API上手"></a>API上手</h2><blockquote>
<p>由于虚拟线程在Java 19中还是预览特性，因此需要启用<code>--enable-preview</code>才能运行。如果在idea中跑，选择Jdk-19版本后，记得设置 Language Level 为 19（Preview）。</p>
</blockquote>
<p>虚拟线程的API非常非常简单，在设计上与现有的<code>Thread</code>类完全兼容。虚拟线程创建出来后也是<code>Thread</code>实例，因此很多原先的代码可以无缝迁移。</p>
<p>可以使用<code>Thread</code>类的新增API直接创建虚拟线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接启动一个虚拟线程</span></span><br><span class="line">Thread.startVirtualThread(runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用新的builder API创建一个命名虚拟线程</span></span><br><span class="line"><span class="type">var</span> <span class="variable">builder</span> <span class="operator">=</span> Thread.ofVirtual()</span><br><span class="line">    .name(<span class="string">&quot;VT-1&quot;</span>)</span><br><span class="line">    .uncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .allowSetThreadLocals(<span class="literal">false</span>);</span><br><span class="line">builder.start(runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟线程的ThreadFactory</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> Thread.ofVirtual().factory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前Thread是否虚拟线程</span></span><br><span class="line">thread.isVirtual();</span><br></pre></td></tr></table></figure>

<p>或是使用虚拟线程的<code>Executor</code>来代替线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecutorService现在可以自动伸缩，需要用try-with-resource包裹</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">future1</span> <span class="operator">=</span> executor.submit(() -&gt; doSomeThing1());</span><br><span class="line">    <span class="type">var</span> <span class="variable">future2</span> <span class="operator">=</span> executor.submit(() -&gt; doSomeThing2());</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> future1.get() + future2.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>先来个简单的对比，我的机器是19款i7+16GB的Macbook pro。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCreateInfiniteThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">job</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        adder.increment();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread count = &quot;</span> + adder.longValue());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动普通线程</span></span><br><span class="line">    startThreads(() -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(job));</span><br><span class="line">    <span class="comment">// 或是启动虚拟线程</span></span><br><span class="line">    startThreads(() -&gt; Thread.ofVirtual().unstarted(job));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThreads</span><span class="params">(Supplier&lt;Thread&gt; threadSupplier)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> threadSupplier.get();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>普通线程</strong>：创建到4064个线程后程序报OOM错误崩溃。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">Thread count = 4063</span><br><span class="line">Thread count = 4064</span><br><span class="line">[0.927s][warning][os,thread] Failed to start thread &quot;Unknown thread&quot; - pthread_create failed (EAGAIN) for attributes: stacksize: 1024k, guardsize: 4k, detached.</span><br><span class="line">[0.927s][warning][os,thread] Failed to start the native thread for java.lang.Thread &quot;Thread-4064&quot;</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached</span><br><span class="line">	at java.base/java.lang.Thread.start0(Native Method)</span><br><span class="line">	at java.base/java.lang.Thread.start(Thread.java:1535)</span><br><span class="line">	at com.rhino.vt.VtExample.startThread(VtExample.java:24)</span><br><span class="line">	at com.rhino.vt.VtExample.main(VtExample.java:13)</span><br></pre></td></tr></table></figure>

<p><strong>虚拟线程：</strong>创建了超过360万个虚拟线程后被挂起，但没有崩溃，虚拟线程的计数一直在缓慢增长，这是因为被 <code>park</code> 的虚拟线程会被垃圾回收，然后 JVM 能够创建更多的虚拟线程并将其分配给底层的平台线程。</p>
<p>Github上有位老哥做了个更接近真实场景的<a target="_blank" rel="noopener" href="https://github.com/ebarlas/project-loom-comparison">测试</a>，模拟远程服务请求数据，比较了使用普通线程阻塞式请求、<code>CompletableFeature</code>异步请求、虚拟线程的三种方式的差异，结果显示在连接数少的时候三者差别不大，连接数上去后虚拟线程在吞吐量、内存占用、延迟、CPU占用率方面都有比较大的优势，如下图：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fs002ES_yYE8nXg-VB0owEcz2yZO.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fs002ES_yYE8nXg-VB0owEcz2yZO.png"  lazyload></a><br>可能这么对比还是不够公平，毕竟一般我们不会直接用这么简单的异步编程，还是会通过各种框架轮子搞。Oracle 的<a target="_blank" rel="noopener" href="https://helidon.io/">Helidon Níma</a> 号称是第一个采用了虚拟线程的微服务框架，主要的卖点也是性能，可以参考其<a target="_blank" rel="noopener" href="https://medium.com/helidon/helidon-n%C3%ADma-helidon-on-virtual-threads-130bb2ea2088">QPS性能测试数据</a>：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fm1R-S2tVBkRTmFP_oPrH9vlayv5.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fm1R-S2tVBkRTmFP_oPrH9vlayv5.png"  lazyload></a><br>可以看到使用了虚拟线程的web服务器性能很好，与用Netty的差距很小，这也符合预期。相比起来虚拟线程使用起来更简单。</p>
<h2 id="“最佳”实践"><a href="#“最佳”实践" class="headerlink" title="“最佳”实践"></a>“最佳”实践</h2><p>总结一下”最佳”实践（为啥带引号？因为预览特性在正式发布前可能变化很大）：</p>
<ul>
<li><p>虚拟线程的开销很低，因此不需要像普通线程池一样被池化，可以为单个RPC请求或者JDBC查询创建一个虚拟线程。另外，如果之前有用线程池来控制并发任务的数目，建议改成信号量的方式。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WITH THREAD POOL</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span></span><br><span class="line">  <span class="variable">DB_POOL</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">queryDatabase</span><span class="params">(</span></span><br><span class="line"><span class="params">    Callable&lt;T&gt; query)</span> &#123;</span><br><span class="line">  <span class="comment">// pool limits to 16 concurrent queries</span></span><br><span class="line">  <span class="keyword">return</span> DB_POOL.submit(query);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// WITH SEMAPHORE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span></span><br><span class="line">  <span class="variable">DB_SEMAPHORE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">queryDatabase</span><span class="params">(</span></span><br><span class="line"><span class="params">    Callable&lt;T&gt; query)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// semaphore limits to 16 concurrent queries</span></span><br><span class="line">  DB_SEMAPHORE.acquire();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> query.call();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    DB_SEMAPHORE.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>虚拟线程支持<code>ThreadLocal</code>和<code>InheritableThreadLocal</code>，就像普通线程一样。但要注意虚拟线程的数目可能很多，需要慎用 </p>
</li>
<li><p>可以使用与普通线程一样的同步机制进行并发编程，但要注意有两种特定情况会导致虚拟线程阻塞平台线程： </p>
<ul>
<li>在<code>synchronized</code>同步块中</li>
<li>执行本地方法或外部函数时</li>
</ul>
</li>
</ul>
<p>因此碰到这类代码要小心，考虑将其替换为<code>ReentrantLock</code>机制： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// with synchronization (pinning 👎🏾):</span></span><br><span class="line"><span class="comment">// synchronized guarantees sequential access</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">accessResource</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> access();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// with ReentrantLock (not pinning 👍🏾):</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span></span><br><span class="line">  <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">accessResource</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// lock guarantees sequential access</span></span><br><span class="line">  LOCK.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> access();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    LOCK.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS. JEP里说，在未来的版本里这些限制可能会得到解决。 </p>
<ul>
<li>可以通过<code>JFR</code>实时分析和监控虚拟线程，也可以通过<code>jcmd</code>命令执行线程转储。注意虚拟线程对操作系统是不可见的，因此像<code>top -H</code>一类的命令只能看到Java进程使用的普通线程。</li>
</ul>
<h1 id="深入虚拟线程"><a href="#深入虚拟线程" class="headerlink" title="深入虚拟线程"></a>深入虚拟线程</h1><h2 id="thread-x3D-continuation-scheduler"><a href="#thread-x3D-continuation-scheduler" class="headerlink" title="thread &#x3D; continuation + scheduler"></a>thread &#x3D; continuation + scheduler</h2><p>回过头来讨论下：到底什么是**”线程”**？简单的定义是，”线程”是顺序执行的一系列计算机指令。由于我们处理的操作可能不仅涉及计算，还涉及 IO、定时暂停和同步等，线程会有包括运行、阻塞、等待在内的各种状态，并在状态之间调度流转。当一个线程阻塞或等待时，它应该腾出计算资源（CPU内核），并允许另一个线程运行，然后在等待的事件发生时恢复执行。这其中涉及到两个概念：</p>
<ol>
<li>_continuation_（这个词实在不知道怎么翻译才恰当）：一系列顺序执行的指令序列，可能会暂停或阻塞，然后恢复执行 </li>
<li>_scheduler_：顾名思义，负责协调调度线程的机制</li>
</ol>
<p>两者是独立的，因此我们可以选择不同的实现。之前的普通线程，在VM层面仅仅是对OS线程的一层简单封装，_continuation_和_scheduler_都是交给OS管理，而虚拟线程实现则是在VM里完成这两件事情，当然底层还是需要有相应的OS线程作为_载体线程_（_CarrierThread_），并且这个对应并不是固定不变的，在虚拟线程恢复后，完全可能被调度到另一个载体线程。</p>
<table>
<thead>
<tr>
<th>组合</th>
<th><em>scheduler</em>-OS</th>
<th><em>scheduler</em>-Runtime</th>
</tr>
</thead>
<tbody><tr>
<td><strong><em>continuation</em>-OS</strong></td>
<td>Java现在的<code>Thread</code></td>
<td>谷歌对Linux内核修改的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KXuZi9aeGTw">User-Level Threads</a></td>
</tr>
<tr>
<td><strong><em>continuation</em>-Runtime</strong></td>
<td>糟糕的选择？</td>
<td>虚拟线程</td>
</tr>
</tbody></table>
<p>虚拟线程的调用堆栈存在Java堆上，而不是OS分配的栈区内。其内存占用开始时只有几百字节，并可以随着调用堆栈自动伸缩。虚拟线程的运行其实就是两个操作：</p>
<ul>
<li>挂载（_mount_）：挂载虚拟线程意味着将所需的栈帧从堆中临时复制到载体线程的堆栈中，并在挂载时借用载体堆栈执行。</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmnxTZLf2AnzAFGAHu1F5pcVu5dV.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmnxTZLf2AnzAFGAHu1F5pcVu5dV.png"  lazyload></a></p>
<ul>
<li>卸载（_unmount_）：当在虚拟线程中运行的代码因为 IO、锁等原因阻塞后，它可以从载体线程中_卸载_，然后将修改的栈帧复制回堆中，从而释放载体线程以进行其他操作（例如运行另一个虚拟线程）。对应的，JDK 中几乎所有的阻塞点都已经过调整，因此当在虚拟线程上遇到阻塞操作时，虚拟线程会从其载体上卸载而不是阻塞。</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgfTph6OZe_NLhoDfd3TPDpDedYa.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgfTph6OZe_NLhoDfd3TPDpDedYa.png"  lazyload></a><br>关于_scheduler_就比较简单了，因为JDK中有现成的<code>ForkJoinPool</code>可以用。<code>work-stealing</code> + <code>FIFO</code>，性能很好。_scheduler_的并行性是可用于调度虚拟线程的OS线程数。默认情况下，它等于可用CPU核数，也可以使用系统属性<code>jdk.virtualThreadScheduler.parallelism</code>进行调整。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqY6l0Gx5_IBGWnhM_8VeHwZk6F1.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqY6l0Gx5_IBGWnhM_8VeHwZk6F1.png"  lazyload></a><br>需靠注意的是，JDK中的绝大多数阻塞操作将卸载虚拟线程，释放其载体线程来承担新的工作。但是，JDK中的一些阻塞操作不会卸载虚拟线程，因此会阻塞其载体线程。这是因为操作系统级别（例如，许多文件系统操作）或JDK级别（例如，<code>Object.wait()</code>）的限制。这些阻塞操作的解决方式是，通过临时扩展_scheduler_的并行性来补偿操作系统线程的捕获。因此，_scheduler_的<code>ForkJoinPool</code>中的平台线程数量可能暂时超过CPU核数。_scheduler_可用的最大平台线程数可以使用系统属性<code>jdk.virtualThreadScheduler.maxPoolSize</code>进行调整。</p>
<h2 id="源码一窥"><a href="#源码一窥" class="headerlink" title="源码一窥"></a>源码一窥</h2><p>试着写一个使用虚拟线程进行网络IO的例子，来窥视下虚拟线程底层的魔法。</p>
<p>下面代码使用了基于虚拟线程的<code>ExecutorService</code>来获取一组URL的响应。每个URL任务会启动一个虚拟线程进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// record是JDK 14中引入的，这里作为简单的数据类，保存url和响应</span></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">URLData</span> (URL url, <span class="type">byte</span>[] response) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;URLData&gt; <span class="title function_">retrieveURLs</span><span class="params">(URL... urls)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">tasks</span> <span class="operator">=</span> Arrays.stream(urls)</span><br><span class="line">            .map(url -&gt; (Callable&lt;URLData&gt;)() -&gt; getURL(url))</span><br><span class="line">            .toList();</span><br><span class="line">        <span class="keyword">return</span> executor.invokeAll(tasks)</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(Future::isDone)</span><br><span class="line">            .map(<span class="built_in">this</span>::getFutureResult)</span><br><span class="line">            .toList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取响应的逻辑在<code>getURL</code>中实现，使用同步的<code>URLConnection</code>API来读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URLData <span class="title function_">getURL</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> url.openStream()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">URLData</span>(url, in.readAllBytes());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我模拟了两个HTTP接口，其中一个响应很慢，因此在运行后不会马上完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1接口sleep 1s返回，test2接口则sleep 100s</span></span><br><span class="line">example.retrieveURLs(<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:7001/test1&quot;</span>), <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:7001/test2&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这样就可以用<code>jcmd</code>命令进行线程转储。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jcmd `jps | grep VtExample | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>` Thread.dump_to_file -format=json thread_dump.json</span></span><br></pre></td></tr></table></figure>

<p>把结果中的普通线程堆栈去掉后，就得到了虚拟线程的堆栈：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;container&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.util.concurrent.ThreadPerTaskExecutor@5d5a133a&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;parent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;root&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;threads&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;java.base\/jdk.internal.vm.Continuation.yield(Continuation.java:357)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.lang.VirtualThread.yieldContinuation(VirtualThread.java:370)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.lang.VirtualThread.park(VirtualThread.java:499)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.lang.System$2.parkVirtualThread(System.java:2596)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/jdk.internal.misc.VirtualThreads.park(VirtualThreads.java:54)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.util.concurrent.locks.LockSupport.park(LockSupport.java:369)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.Poller.poll2(Poller.java:139)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.Poller.poll(Poller.java:102)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.Poller.poll(Poller.java:87)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.park(NioSocketImpl.java:175)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.park(NioSocketImpl.java:196)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:304)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:340)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:789)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.net.Socket$SocketInputStream.read(Socket.java:1025)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.io.BufferedInputStream.fill(BufferedInputStream.java:255)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.io.BufferedInputStream.read1(BufferedInputStream.java:310)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.io.BufferedInputStream.implRead(BufferedInputStream.java:382)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.io.BufferedInputStream.read(BufferedInputStream.java:361)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:827)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:759)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1684)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1585)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.net.URL.openStream(URL.java:1162)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;com.rhino.vt.VtExample.getURL(VtExample.java:59)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;com.rhino.vt.VtExample.lambda$retrieveURLs$0(VtExample.java:40)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.util.concurrent.ThreadPerTaskExecutor$ThreadBoundFuture.run(ThreadPerTaskExecutor.java:352)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.lang.VirtualThread.run(VirtualThread.java:287)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/java.lang.VirtualThread$VThreadContinuation.lambda$new$0(VirtualThread.java:174)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/jdk.internal.vm.Continuation.enter0(Continuation.java:327)&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;java.base\/jdk.internal.vm.Continuation.enter(Continuation.java:320)&quot;</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;threadCount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>作为对比，把代码中的<code>executor</code>改成<code>Executors.newCachedThreadPool()</code>，再dump出直接使用普通线程的堆栈：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;23&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pool-1-thread-2&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.SocketDispatcher.read0(Native Method)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:47)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.tryRead(NioSocketImpl.java:251)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:302)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:340)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:789)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.net.Socket$SocketInputStream.read(Socket.java:1025)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.io.BufferedInputStream.fill(BufferedInputStream.java:255)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.io.BufferedInputStream.read1(BufferedInputStream.java:310)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.io.BufferedInputStream.implRead(BufferedInputStream.java:382)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.io.BufferedInputStream.read(BufferedInputStream.java:361)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.net.www.http.HttpClient.parseHTTPHeader(HttpClient.java:827)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.net.www.http.HttpClient.parseHTTP(HttpClient.java:759)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1684)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1585)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.net.URL.openStream(URL.java:1162)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;com.rhino.vt.VtExample.getURL(VtExample.java:59)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;com.rhino.vt.VtExample.lambda$retrieveURLs$0(VtExample.java:40)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.util.concurrent.FutureTask.run(FutureTask.java:317)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.lang.Thread.run(Thread.java:1589)&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>两个堆栈对比一下会发现，除了中间执行的业务逻辑部分是一致的，有两点不同：</p>
<ol>
<li>普通线程的入口是<code>Thread.run</code>，而虚拟线程的入口是<code>Continuation</code>，这个类是虚拟线程的核心类，是VM内部对上面所说的_continuation_的抽象。<code>Continuation</code>有两个关键方法：<code>yield()</code>和<code>run()</code>。<br>可以试着跑一下这段代码看看输出结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testContinuation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContinuationScope</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">continuation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Continuation</span>(scope, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C1&quot;</span>);</span><br><span class="line">        Continuation.<span class="keyword">yield</span>(scope);</span><br><span class="line">        System.out.println(<span class="string">&quot;C2&quot;</span>);</span><br><span class="line">        Continuation.<span class="keyword">yield</span>(scope);</span><br><span class="line">        System.out.println(<span class="string">&quot;C3&quot;</span>);</span><br><span class="line">        Continuation.<span class="keyword">yield</span>(scope);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    continuation.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;came back&quot;</span>);</span><br><span class="line">    continuation.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;back again&quot;</span>);</span><br><span class="line">    continuation.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;back again again&quot;</span>);</span><br><span class="line">    continuation.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">start</span><br><span class="line">C1</span><br><span class="line">came back</span><br><span class="line">C2</span><br><span class="line">back again</span><br><span class="line">C3</span><br><span class="line">back again again</span><br></pre></td></tr></table></figure></li>
</ol>
<p>PS. 记得在跑的时候加上下面的参数：  </p>
<ol start="2">
<li>普通线程会阻塞在<code>read</code>本地方法调用上（底层应该就是<code>read</code>系统调用），而虚拟线程则会通过<code>VirtualThread#park</code>挂起，这也对应了上面说的，JDK中几乎所有的阻塞点都已经过调整了。<code>VirtualThread</code>维护了一组<code>state</code>状态，调用<code>park</code>后就会设置成<code>PARKING</code>，可以在注释里看到状态之间的流转逻辑。</li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FsTiCehbgRlZwBj6bidkaBiIt2MI.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FsTiCehbgRlZwBj6bidkaBiIt2MI.png"  lazyload></a><br>在线程dump文件里还能找到一个叫_Read-Poller_的线程（对应的还有一个写操作的 _Write-Poller_线程）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;27&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Read-Poller&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.KQueue.poll(Native Method)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.KQueuePoller.poll(KQueuePoller.java:66)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.Poller.poll(Poller.java:363)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/sun.nio.ch.Poller.pollLoop(Poller.java:270)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/java.lang.Thread.run(Thread.java:1589)&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="string">&quot;java.base\/jdk.internal.misc.InnocuousThread.run(InnocuousThread.java:186)&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>JDK底层做了什么调整呢？从_Read-Poller_可以看出，其实就是把原来的阻塞调用改为了非阻塞的IO调用。流程如下：</p>
<ol>
<li>在阻塞调用中，检查是否虚拟线程，如果是的话，就注册一个NIO handler，即将文件描述符注册到_Read-Poller_的<code>selector</code>上。然后调用<code>Continuation.yield()</code>暂停自身。因为我本机是mac，所以线程堆栈里显示的NIO handler用的是<code>KQueue</code>，如果换成Linux，那就是我们熟悉的<code>epoll</code>了。 </li>
<li>_Read-Poller_底层维护了一组文件描述符 - 虚拟线程的映射，当一个文件描述符被注册到_Read-Poller_上时，同样也会将对应的虚拟线程加到这个映射里。 </li>
<li>当Socket可读时，这个_Read-Poller_就会得到通知，随即调用<code>wakeup()</code>方法，从映射里找到文件描述符对应的虚拟线程，再将之前<code>park()</code>的虚拟线程<code>unpark()</code>，这样就完成了虚拟线程的唤醒。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unparks any thread that is polling the given file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">int</span> fdVal)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> map.remove(fdVal);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        LockSupport.unpark(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>虚拟线程的<code>unpark()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Re-enables this virtual thread for scheduling. If the virtual thread was</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #park() parked&#125; then it will be unblocked, otherwise its next call</span></span><br><span class="line"><span class="comment"> * to &#123;<span class="doctag">@code</span> park&#125; or &#123;<span class="doctag">@linkplain</span> #parkNanos(long) parkNanos&#125; is guaranteed</span></span><br><span class="line"><span class="comment"> * not to block.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if the scheduler cannot accept a task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@ChangesCurrentThread</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (!getAndSetParkPermit(<span class="literal">true</span>) &amp;&amp; currentThread != <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state();</span><br><span class="line">        <span class="comment">// CAS设置线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (s == PARKED &amp;&amp; compareAndSetState(PARKED, RUNNABLE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentThread <span class="keyword">instanceof</span> VirtualThread vthread) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">carrier</span> <span class="operator">=</span> vthread.carrierThread;</span><br><span class="line">                carrier.setCurrentThread(carrier);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 提交给scheduler执行</span></span><br><span class="line">                    submitRunContinuation();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    carrier.setCurrentThread(vthread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                submitRunContinuation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == PINNED) &#123;</span><br><span class="line">            <span class="comment">// unpark carrier thread when pinned.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (carrierThreadAccessLock()) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">carrier</span> <span class="operator">=</span> carrierThread;</span><br><span class="line">                <span class="keyword">if</span> (carrier != <span class="literal">null</span> &amp;&amp; state() == PINNED) &#123;</span><br><span class="line">                    U.unpark(carrier);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>unpark()</code>中，会将虚拟线程的状态重新设置为<code>RUNNABLE</code>，并且调用<code>submitRunContinuation()</code>方法将任务交给调度器执行，真正执行时，就会调用到<code>Continuation.run()</code>方法。另外，上面调用<code>executor.invokeAll()</code>方法提交任务时，底层同样也是调用了<code>VirtualThread.submitRunContinuation()</code>方法，这里的<code>scheduler</code>默认就是<code>ForkJoinPool</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Submits the runContinuation task to the scheduler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="doctag">@code</span> lazySubmit&#125; to lazy submit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ForkJoinPool#lazySubmit(ForkJoinTask)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">submitRunContinuation</span><span class="params">(<span class="type">boolean</span> lazySubmit)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySubmit &amp;&amp; scheduler <span class="keyword">instanceof</span> ForkJoinPool pool) &#123;</span><br><span class="line">            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 默认shceduler就是ForkJoinPool</span></span><br><span class="line">            scheduler.execute(runContinuation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">        <span class="comment">// 省略异常处理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>park()</code>里，虚拟线程让出资源的关键方法是<code>VirtualThread.yieldContinuation()</code>，可以发现<code>mount()</code>和<code>unmount()</code>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unmounts this virtual thread, invokes Continuation.yield, and re-mounts the</span></span><br><span class="line"><span class="comment"> * thread when continued. When enabled, JVMTI must be notified from this method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the yield was successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChangesCurrentThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">yieldContinuation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">notifyJvmti</span> <span class="operator">=</span> notifyJvmtiEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unmount</span></span><br><span class="line">    <span class="keyword">if</span> (notifyJvmti) notifyJvmtiUnmountBegin(<span class="literal">false</span>);</span><br><span class="line">    unmount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Continuation.<span class="keyword">yield</span>(VTHREAD_SCOPE);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// re-mount</span></span><br><span class="line">        mount();</span><br><span class="line">        <span class="keyword">if</span> (notifyJvmti) notifyJvmtiMountEnd(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mount()</code>和<code>unmount()</code>会在Java堆和本地线程栈之间做栈帧的拷贝，这是Project Loom中为数不多的在JVM层面实现的本地方法，感兴趣的可以去Loom的<a target="_blank" rel="noopener" href="https://github.com/openjdk/loom">github库</a>里搜一下<code>continuationFreezeThaw.cpp</code>。其余的大部分代码在JDK中实现， 参见<code>java.base</code>模块下的<code>jdk.internal.vm</code>包。</p>
<h1 id="未来？"><a href="#未来？" class="headerlink" title="未来？"></a>未来？</h1><p>在我看来，将近而立之年的Java仍然充满活力。虚拟线程的到来，给我们展示了一种新的可能性，在处理IO密集这类特定场景的任务时，可以有”Code Like Sync, Scale Like Async”的两全之法。</p>
<p>随便瞎YY下，作为向前兼容性做得最好的语言（可能没有之一），现有的线程机制会跟新的虚拟线程共存很久。对于普通开发者而言，虚拟线程应该不会有太大的影响，大部分情况下我们都是直接使用各种封装好的类库来操作线程。但虚拟线程在性能、可扩展性、代码可维护性等方面的优势，对于类库的开发者会有很大的吸引力。相信很快我们能看到”Tomcat on VT”、”Netty on VT”或者”Spring on VT”。</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8F%B2"><span class="top-box-text">线程简史</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Java%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="top-box-text">Java线程发展史</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="top-box-text">为什么要有虚拟线程？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E6%89%8D%E6%9C%89%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="top-box-text">为什么现在才有虚拟线程？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="top-box-text">曲线救国的实现</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%B8%8A%E6%89%8B%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="top-box-text">上手虚拟线程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#API%E4%B8%8A%E6%89%8B"><span class="top-box-text">API上手</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="top-box-text">性能对比</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E2%80%9C%E6%9C%80%E4%BD%B3%E2%80%9D%E5%AE%9E%E8%B7%B5"><span class="top-box-text">“最佳”实践</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%B7%B1%E5%85%A5%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="top-box-text">深入虚拟线程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#thread-x3D-continuation-scheduler"><span class="top-box-text">thread &#x3D; continuation + scheduler</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%BA%90%E7%A0%81%E4%B8%80%E7%AA%A5"><span class="top-box-text">源码一窥</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%9C%AA%E6%9D%A5%EF%BC%9F"><span class="top-box-text">未来？</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2022/04/13/yi-xie-za-xiang-java-lao-yi-shang-neng-fan-fou/">
          <h3 class="post-title">
            下一篇：一些杂想：Java老矣，尚能饭否？
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>UUID过时了？来了解下NanoID</title>
<meta name="keywords" content="UUID过时了？来了解下NanoID, jffu&#39;s blog">
<meta name="description" content="一个轻量的UUID生成库介绍。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="UUID过时了？来了解下NanoID">
<meta property="og:description" content="一个轻量的UUID生成库介绍。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">UUID过时了？来了解下NanoID</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2021-11-02</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/JavaScript/">
              JavaScript
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="NanoID是什么"><a href="#NanoID是什么" class="headerlink" title="NanoID是什么"></a>NanoID是什么</h1><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://ai.github.io/nanoid/logo.svg"><img   src="/images/loading.svg" data-src="https://ai.github.io/nanoid/logo.svg"  align="right"
     alt="Nano ID logo by Anton Lovchikov" width="180" height="94" lazyload></a></p>
<blockquote>
<p>A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</p>
</blockquote>
<p>按官方介绍，<a target="_blank" rel="noopener" href="https://github.com/ai/nanoid">NanoID</a>是一个小巧、安全、URL友好的JavaScript唯一ID生成器。它的特性包括：</p>
<ul>
<li><p><strong>小巧.</strong> （库大小）只有130 bytes (已压缩和 gzipped)。 没有其他依赖。 <a target="_blank" rel="noopener" href="https://github.com/ai/size-limit">Size Limit</a> 控制大小。</p>
<blockquote>
<p>相比之下，UUID库的大小为483 bytes。</p>
</blockquote>
</li>
<li><p><strong>快速.</strong> 比 UUID 快 60%。</p>
</li>
<li><p><strong>安全.</strong> 使用加密的强随机 API。可在集群中使用。</p>
</li>
<li><p><strong>紧凑.</strong> 使用比 UUID（<code>A-Za-z0-9_-</code>）更大的字母表。 相比UUID的36个字符大小，NanoID只有21个字符。</p>
</li>
<li><p><strong>易用.</strong> Nano ID 已被移植到 <a target="_blank" rel="noopener" href="https://github.com/ai/nanoid/blob/main/README.zh-CN.md#%E5%85%B6%E4%BB%96%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">20种编程语言</a>。</p>
<blockquote>
<p>虽然NanoID更多地是被用在前端领域生成唯一ID，不过它也完全可以被用在后端。</p>
</blockquote>
</li>
</ul>
<h1 id="NanoID与UUID有什么区别"><a href="#NanoID与UUID有什么区别" class="headerlink" title="NanoID与UUID有什么区别"></a>NanoID与UUID有什么区别</h1><p>UUID的标准实现有几个不同的变体和版本，日常中用的最多的是是UUID V4版本，这个版本基于随机数生成UUID。以UUID V4版本为例，看区别之前先看有什么相似点：</p>
<ol>
<li><p><strong>唯一性</strong>：NanoID 与 UUID v4 类似， 它们在 ID 中有相似数量的随机位 (NanoID 为126，UUID 为122)，因此两者的碰撞概率相似</p>
<blockquote>
<p>UUID的碰撞概率是103万亿个生成的ID中找到重复项的概率是十亿分之一，NanoID的碰撞概率可以通过<a target="_blank" rel="noopener" href="https://zelark.github.io/nano-id-cc/">这里</a>计算，基本都可以忽略不计。</p>
</blockquote>
</li>
<li><p><strong>无序性</strong>：生成的ID都是的无序的（这里不考虑UUID的特殊版本）。</p>
</li>
<li><p><strong>不连续性</strong>：生成的ID都不是连续的。</p>
<blockquote>
<p>考虑到UUID和NanoID都无法保证趋势递增，并且长度还是太长了一点，这两者都不太适合拿来当数据库的主键。</p>
</blockquote>
</li>
<li><p><strong>安全性</strong>：都足够安全。以Java中的实现为例，都使用了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html">SecureRandom</a>来生成随机数。另外，NanoID 在 ID 生成器的实现过程中使用了一种称为 <strong>“uniform formula”</strong> 的算法，而不是使用 <code>random % alphabet</code>的方式。</p>
</li>
</ol>
<p>再来看看区别，Nano ID 和 UUID v4之间有几个主要区别。</p>
<p>首先是<strong>NanoID的长度更短</strong>。NanoID 使用更大的字母表，生成的字符串长度为21个字符，比UUID的36个字符短不少。当然UUID中的分隔符”-“是可以去掉的，去掉后还剩32个字符。</p>
<blockquote>
<p>解释一下为什么NanoID用的字母表（<code>A-Za-z0-9_-</code>）比UUID更大，因为UUID生成的ID本质上是一个16字节（128位）的数字，32个字符的字符串是这个数字的16进制表示，因此实际上UUID的字母表是<code>a-e0-9</code>，且大小写无关。</p>
</blockquote>
<p>其次是<strong>NanoID的生成速度更快</strong>。以JavaScript库为例，官方号称快60%：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">node ./test/benchmark.js</span></span><br><span class="line">crypto.randomUUID         28,387,114 ops/sec</span><br><span class="line">uid/secure                 8,633,795 ops/sec</span><br><span class="line">@lukeed/uuid               6,888,704 ops/sec</span><br><span class="line">nanoid                     6,166,399 ops/sec</span><br><span class="line">customAlphabet             3,290,342 ops/sec</span><br><span class="line">uuid v4                    1,662,373 ops/sec</span><br><span class="line">secure-random-string         415,340 ops/sec</span><br><span class="line">uid-safe.sync                400,875 ops/sec</span><br><span class="line">cuid                         212,669 ops/sec</span><br><span class="line">shortid                       53,453 ops/sec</span><br><span class="line"></span><br><span class="line">Async:</span><br><span class="line">nanoid/async                 102,823 ops/sec</span><br><span class="line">async customAlphabet         101,574 ops/sec</span><br><span class="line">async secure-random-string    96,540 ops/sec</span><br><span class="line">uid-safe                      93,395 ops/sec</span><br><span class="line"></span><br><span class="line">Non-secure:</span><br><span class="line">uid                       70,055,975 ops/sec</span><br><span class="line">nanoid/non-secure          2,985,368 ops/sec</span><br><span class="line">rndm                       2,800,961 ops/sec</span><br></pre></td></tr></table></figure>

<p>不过其他语言的性能对比可能没这么夸张，我在本机做了一个不严谨的测试，用Java默认的生成方法<code>UUID.randomUUID()</code>和<code>NanoIdUtils.randomNanoId()</code>生成ID，1000万次的耗时分别是6132ms和7493ms。</p>
<p>最后是<strong>NanoID的功能更多</strong>，比如：</p>
<ul>
<li>支持自定义字母表和长度来生成ID</li>
<li>支持指定随机数生成器来生成ID</li>
<li>支持异步生成</li>
</ul>
<p>这使得NanoID生成的ID可以被使用在更多的场合，比如用于生成url短链：UUID产生的结果过长，所以不太适合于URL短链随机id这个应用场景。这个时候就可以用NanoID的自定义字符串集和长度的特性了。</p>
<p>从npm的下载趋势来看，UUID仍然是最常用的，但NanoID过去两年的增长非常快，github star数也更高（14.5k VS 11.6k），这还要考虑到NanoID比UUID年轻了7岁。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FvSLax0qZB8WWItKA4qVLDuZ0G2D.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FvSLax0qZB8WWItKA4qVLDuZ0G2D.png"  lazyload></a></p>
<h1 id="NanoID怎么用"><a href="#NanoID怎么用" class="headerlink" title="NanoID怎么用"></a>NanoID怎么用</h1><p>JavaScript中引入和使用NanoID非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install --save nanoid</span></span><br><span class="line"><span class="comment">// 生成id</span></span><br><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span>;</span><br><span class="line">model.<span class="property">id</span> = <span class="title function_">nanoid</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义字母表和长度  </span></span><br><span class="line"><span class="keyword">import</span> &#123; customAlphabet &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> nanoid = <span class="title function_">customAlphabet</span>(<span class="string">&#x27;ABCDEF1234567890&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">model.<span class="property">id</span> = <span class="title function_">nanoid</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步生成</span></span><br><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid/async&#x27;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">createUser</span> () &#123;</span><br><span class="line">  user.<span class="property">id</span> = <span class="keyword">await</span> <span class="title function_">nanoid</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中使用NanoID稍微麻烦一点，不像JDK中自带了UUID的实现，需要额外引包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aventrix.jnanoid<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jnanoid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Java的实现比较简单，包里只有一个<code>NanoIdUtils</code>工具类，玩法没有JavaScript库那么多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认方法生成ID</span></span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> NanoIdUtils.randomNanoId(); <span class="comment">// &quot;ku-qLNv1wDmIS5_EcT3j7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Random代替默认的SecureRandom生成随机数，生成的速度更快，缺点是不太安全</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一张只有a/b/c的字母表</span></span><br><span class="line"><span class="type">char</span>[] alphabet = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定生成的ID长度为10</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定随机数生成器、字母表和长度生成ID</span></span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> NanoIdUtils.randomNanoId(random, alphabet, <span class="number">10</span>); <span class="comment">// &quot;babbcaabcb&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="NanoID是怎么实现的"><a href="#NanoID是怎么实现的" class="headerlink" title="NanoID是怎么实现的"></a>NanoID是怎么实现的</h1><p>UUID 的5个版本：</p>
<blockquote>
<ul>
<li>空<code>UUID</code>（特殊版本<code>0</code>），用<code>00000000-0000-0000-0000-000000000000</code>表示，也就是所有的比特都是<code>0</code></li>
<li><code>date-time and MAC address</code>（版本<code>1</code>）：基于时间和<code>MAC</code>地址的版本，通过计算当前时间戳、随机数和机器<code>MAC</code>地址得到。由于有<code>MAC</code>地址，这个可以保证其在全球的唯一性。但是使用了<code>MAC</code>地址，就会有<code>MAC</code>地址暴露问题。若是局域网，可以用<code>IP</code>地址代替</li>
<li><code>date-time and MAC address, DCE security version</code>（版本<code>2</code>）：分布式计算环境安全的<code>UUID</code>，算法和版本<code>1</code>基本一致，但会把时间戳的前<code>4</code>位置换为<code>POSIX</code>的<code>UID</code>或<code>GID</code></li>
<li><code>namespace name-based MD5</code>（版本<code>3</code>）：通过计算名字和命名空间的<code>MD5</code>散列值得到。这个版本的<code>UUID</code>保证了：相同命名空间中不同名字生成的<code>UUID</code>的唯一性；不同命名空间中的<code>UUID</code>的唯一性；相同命名空间中相同名字的<code>UUID</code>重复生成是相同的</li>
<li><code>random</code>（版本<code>4</code>）：根据随机数，或者伪随机数生成<code>UUID</code>。这种<code>UUID</code>产生重复的概率是可以计算出来的，还有一个特点就是预留了<code>6</code>比特存放变体和版本属性，所以随机生成的位一共有<code>122</code>个，总量为<code>2^122</code>，比其他变体的总量要偏少</li>
<li><code>namespace name-based SHA-1</code>（版本<code>5</code>）：和版本<code>3</code>类似，散列算法换成了<code>SHA-1</code></li>
</ul>
</blockquote>
<p>基于随机数的 版本4用得相对更多一点，比如JDK中的<code>UUID</code>工具类就只提供了<code>namespace name-based MD5</code>（版本3）和<code>random</code>（版本4）两个版本的实现。默认的<code>UUID.randomUUID()</code>方法使用的是版本4的实现。</p>
<p>相比起UUID的众多版本，NanoID只提供了基于随机数的生成方式。实现的代码非常精简（130个字节的库大小已经能很好地说明这点了），JavaScript版本<a target="_blank" rel="noopener" href="https://github.com/ai/nanoid/blob/main/index.js">核心的代码</a>加上注释不到100行。其他语言的实现也基本类似，区别主要在于获取随机数的方式，比如Java版本使用<code>SecureRandom</code>，JavaScript版本借助<code>crypto</code>模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; urlAlphabet &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./url-alphabet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// It is best to make fewer, larger requests to the crypto module to</span></span><br><span class="line"><span class="comment">// avoid system call overhead. So, random numbers are generated in a</span></span><br><span class="line"><span class="comment">// pool. The pool is a Buffer that is larger than the initial random</span></span><br><span class="line"><span class="comment">// request size by this multiplier. The pool is enlarged if subsequent</span></span><br><span class="line"><span class="comment">// requests exceed the maximum buffer size.</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">POOL_SIZE_MULTIPLIER</span> = <span class="number">128</span></span><br><span class="line"><span class="keyword">let</span> pool, poolOffset</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fillPool</span> = bytes =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pool || pool.<span class="property">length</span> &lt; bytes) &#123;</span><br><span class="line">    pool = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(bytes * <span class="variable constant_">POOL_SIZE_MULTIPLIER</span>)</span><br><span class="line">    crypto.<span class="title function_">randomFillSync</span>(pool)</span><br><span class="line">    poolOffset = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (poolOffset + bytes &gt; pool.<span class="property">length</span>) &#123;</span><br><span class="line">    crypto.<span class="title function_">randomFillSync</span>(pool)</span><br><span class="line">    poolOffset = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  poolOffset += bytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">random</span> = bytes =&gt; &#123;</span><br><span class="line">  <span class="title function_">fillPool</span>(bytes)</span><br><span class="line">  <span class="keyword">return</span> pool.<span class="title function_">subarray</span>(poolOffset - bytes, poolOffset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">customRandom</span> = (<span class="params">alphabet, size, getRandom</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// First, a bitmask is necessary to generate the ID. The bitmask makes bytes</span></span><br><span class="line">  <span class="comment">// values closer to the alphabet size. The bitmask calculates the closest</span></span><br><span class="line">  <span class="comment">// `2^31 - 1` number, which exceeds the alphabet size.</span></span><br><span class="line">  <span class="comment">// For example, the bitmask for the alphabet size 30 is 31 (00011111).</span></span><br><span class="line">  <span class="keyword">let</span> mask = (<span class="number">2</span> &lt;&lt; (<span class="number">31</span> - <span class="title class_">Math</span>.<span class="title function_">clz32</span>((alphabet.<span class="property">length</span> - <span class="number">1</span>) | <span class="number">1</span>))) - <span class="number">1</span></span><br><span class="line">  <span class="comment">// Though, the bitmask solution is not perfect since the bytes exceeding</span></span><br><span class="line">  <span class="comment">// the alphabet size are refused. Therefore, to reliably generate the ID,</span></span><br><span class="line">  <span class="comment">// the random bytes redundancy has to be satisfied.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: every hardware random generator call is performance expensive,</span></span><br><span class="line">  <span class="comment">// because the system call for entropy collection takes a lot of time.</span></span><br><span class="line">  <span class="comment">// So, to avoid additional system calls, extra bytes are requested in advance.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, a step determines how many random bytes to generate.</span></span><br><span class="line">  <span class="comment">// The number of random bytes gets decided upon the ID size, mask,</span></span><br><span class="line">  <span class="comment">// alphabet size, and magic number 1.6 (using 1.6 peaks at performance</span></span><br><span class="line">  <span class="comment">// according to benchmarks).</span></span><br><span class="line">  <span class="keyword">let</span> step = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((<span class="number">1.6</span> * mask * size) / alphabet.<span class="property">length</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> bytes = <span class="title function_">getRandom</span>(step)</span><br><span class="line">      <span class="comment">// A compact alternative for `for (let i = 0; i &lt; step; i++)`.</span></span><br><span class="line">      <span class="keyword">let</span> i = step</span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// Adding `|| &#x27;&#x27;` refuses a random byte that exceeds the alphabet size.</span></span><br><span class="line">        id += alphabet[bytes[i] &amp; mask] || <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (id.<span class="property">length</span> === size) <span class="keyword">return</span> id</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">customAlphabet</span> = (<span class="params">alphabet, size</span>) =&gt; <span class="title function_">customRandom</span>(alphabet, size, random)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">nanoid</span> = (<span class="params">size = <span class="number">21</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">fillPool</span>(size)</span><br><span class="line">  <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// We are reading directly from the random pool to avoid creating new array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = poolOffset - size; i &lt; poolOffset; i++) &#123;</span><br><span class="line">    <span class="comment">// It is incorrect to use bytes exceeding the alphabet size.</span></span><br><span class="line">    <span class="comment">// The following mask reduces the random byte in the 0-255 value</span></span><br><span class="line">    <span class="comment">// range to the 0-63 value range. Therefore, adding hacks, such</span></span><br><span class="line">    <span class="comment">// as empty string fallback or magic numbers, is unneccessary because</span></span><br><span class="line">    <span class="comment">// the bitmask trims bytes down to the alphabet size.</span></span><br><span class="line">    id += urlAlphabet[pool[i] &amp; <span class="number">63</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; nanoid, customAlphabet, customRandom, urlAlphabet, random &#125;</span><br></pre></td></tr></table></figure>

<p>如果单纯看<code>nanoid</code>函数，会发现它简单到像是糊弄人，主要的就这一句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id += urlAlphabet[pool[i] &amp; <span class="number">63</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的第一反应是：这不就是拿输入的随机数跟字母表取模吗…</p>
</blockquote>
<p>NanoID的实现关键其实是上面重重注释的<code>customRandom</code>函数，这个函数的输入是<code>alphabet, size, getRandom</code>，分别代表字母表，生成的id长度和随机数值，输出是一个生成最终的ID的函数。</p>
<p>首先是计算一个用于位计算的掩码<code>mask</code>，保证<code>mask</code>是一个比字母表长度大并且满足<code>2^n - 1</code>的值。比如字母表长度是<code>&#123;5, 11, 31, 64, 100, 200&#125;</code>时，生成的<code>mask</code>分别是<code>&#123;7，15, 31, 63, 127, 255&#125;</code>。这种特殊的位掩码值在很多hash的场合都能见到，对一个随机数执行<code>random &amp; mask</code>位运算后，得到的结果只保留低的n位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mask = (<span class="number">2</span> &lt;&lt; (<span class="number">31</span> - <span class="title class_">Math</span>.<span class="title function_">clz32</span>((alphabet.<span class="property">length</span> - <span class="number">1</span>) | <span class="number">1</span>))) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后计算一个<code>step</code>值用于确定需要用到多少个随机数字节，后面可以看到为什么要计算这个值而不是直接用id的长度<code>size</code>个字节。这里出现了1.6这个魔法数字，看注释是说做了基准测试后发现能达到最佳性能的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> step = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((<span class="number">1.6</span> * mask * size) / alphabet.<span class="property">length</span>)</span><br></pre></td></tr></table></figure>

<p>最后就是获取<code>step</code>个随机数字节，然后计算最终的结果了。计算的过程比较简单，就是对输入的随机数数组依次跟<code>mask</code>做位与运算，如果结果大小超出了字母表范围，则舍弃，否则就保留到最终的结果id中，直到达到id的长度为止。这是一种比较常见的消除<code>modulo bias</code>的做法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bytes = <span class="title function_">getRandom</span>(step)</span><br><span class="line"><span class="keyword">let</span> i = step</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">  <span class="comment">// Adding `|| &#x27;&#x27;` refuses a random byte that exceeds the alphabet size.</span></span><br><span class="line">  id += alphabet[bytes[i] &amp; mask] || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (id.<span class="property">length</span> === size) <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我看这段代码的时候有一个疑惑，如果碰上了极端情况，导致生成的随机数数组中的值执行完<code>bytes[i] &amp; mask</code>后都比<code>alphabet.length</code>大，那不就生成不了最终的id了？理论上，如果<code>size</code>越大且字母表<code>alphabet</code>大小与计算得到的<code>mask</code>相差越大，就越容易出现这种极端情况。举个例子，字母表大小为33和63时，<code>mask</code>的大小都是64，但很明显前者出现<code>bytes[i] &amp; mask &gt; alphabet.length</code>的几率要大很多。不过实际上这两者越大时，<code>step</code>也越大，能够选取更多的随机数，只不过效率上会差一些。</p>
</blockquote>
<p>有一个比较有意思的点可以展开说一下，NanoID的文档提到了它没有使用 <code>random % alphabet</code>的方式来生成随机数（这是一个很容易犯的错误），因为这会导致最终结果中有些字符出现的概率比其他字符更低，称之为<code>modulo bias</code>。为什么会有这个问题？可以用一个简单的例子说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随机数范围：0-4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字母表：0，1，2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用random % alphabet 的方式计算，结果如下：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0,1,2,3,4 % 3</span></span><br><span class="line">0 =&gt; 0</span><br><span class="line">1 =&gt; 1</span><br><span class="line">2 =&gt; 2</span><br><span class="line">3 =&gt; 0</span><br><span class="line">4 =&gt; 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到字母表中的0和1出现的概率是2/5，而2出现的概率只有1/5</span></span><br></pre></td></tr></table></figure>

<p>其实更泛化地讲，如果随机数的范围大小不是字母表的大小的倍数，就会有这个问题。不过NanoID在默认情况下，随机数的范围是单个字节的0-255，而字母表<code>A-Za-z0-9_-</code>的大小刚好是64，使用 <code>random % alphabet</code>是完全OK的。</p>
<p>NanoID的代码实现中使用了一些小技巧来提升性能，比如：</p>
<ul>
<li><p>NanoID依赖crypto模块生成随机数，为了避免频繁调用产生的系统调用开销，使用了一个<code>bytes * POOL_SIZE_MULTIPLIER</code>大小（默认是21 * 128）的随机数池，初始化时一次性填充，能直接使用128次，用完时再一次性申请一组。</p>
</li>
<li><p>为了更好地做gzip和brotli压缩，字母表<code>urlAlphabet</code>的值是<code>useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict</code>，而不是正常的<code>A-Za-z0-9_-</code>。</p>
</li>
<li><p>使用位操作代替<code>%</code>或<code>*</code>。</p>
</li>
</ul>
<h1 id="NanoID是否能完全代替UUID"><a href="#NanoID是否能完全代替UUID" class="headerlink" title="NanoID是否能完全代替UUID"></a>NanoID是否能完全代替UUID</h1><p>回到标题，NanoID是否能真的完美地替代UUID？</p>
<p>我的看法是，在一些简单场景下确实可以，比如说只是想生成一个足够随机不用担心重复的唯一ID，但完全代替是不可能的。原因在于UUID是一套更完备更通用的体系。它是有像<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4122">RFC4122</a>这样的标准规范支撑的。它有许多不同的变体和版本用于不同的场景，而NanoID只有一个基于随机数的版本，更像是程序员灵感迸发的玩具。</p>
<p>正因为UUID的通用性，许多系统或者编程语言都内置了UUID的支持，用起来更方便。比如许多数据库（例如PostgreSQL）都内置了UUID类型或者函数。实际上比较存储空间的话，NanoID占的字节数反而更多（21个字节），而UUID只需要16个字节。</p>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NanoID%E6%98%AF%E4%BB%80%E4%B9%88"><span class="top-box-text">NanoID是什么</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NanoID%E4%B8%8EUUID%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="top-box-text">NanoID与UUID有什么区别</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NanoID%E6%80%8E%E4%B9%88%E7%94%A8"><span class="top-box-text">NanoID怎么用</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NanoID%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="top-box-text">NanoID是怎么实现的</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NanoID%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%8C%E5%85%A8%E4%BB%A3%E6%9B%BFUUID"><span class="top-box-text">NanoID是否能完全代替UUID</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2021/10/19/yun-yuan-sheng-ru-men-zhi-bei-serverless/">
          <h3 class="post-title">
            下一篇：云原生入门指北-Serverless
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


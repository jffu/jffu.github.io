<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>云原生入门指北-Kubernetes</title>
<meta name="keywords" content="云原生入门指北-Kubernetes, jffu&#39;s blog">
<meta name="description" content="云原生入门指北系列第二篇，从Docker到Kubernetes。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="云原生入门指北-Kubernetes">
<meta property="og:description" content="云原生入门指北系列第二篇，从Docker到Kubernetes。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">云原生入门指北-Kubernetes</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2021-10-16</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">
              云原生
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>Kubernetes能记录得实在太多了，这里主要是对自己学习的过程做个记录。如果想系统学习，推荐下《Kubernetes In Action》这本书。</p>
</blockquote>
<h2 id="从Docker到Kubernetes"><a href="#从Docker到Kubernetes" class="headerlink" title="从Docker到Kubernetes"></a>从Docker到Kubernetes</h2><p>Docker提供了在一个完全隔离的环境中打包和运行应用程序的能力，这个隔离的环境被称为容器。</p>
<p>Docker解决的问题：</p>
<ul>
<li>保证程序运行环境的一致性；</li>
<li>降低配置开发环境、生产环境的复杂度和成本；</li>
<li>实现程序的快速部署和分发。</li>
</ul>
<p>现在，如果你要部署和运维一堆容器（可能成千上万），你会怎么做？</p>
<ol>
<li>按照一定规则，把docker镜像分发到不同的主机上（每个主机的配置可能都不一样）。一些容器可能需要互相配合才能工作，所以，这些容器必须被部署在同一台主机上； </li>
<li>通过某种方式拉起容器（可能有先后顺序） </li>
<li>以某种机制监控容器的运行；</li>
</ol>
<p>接下来，扩缩容？升级？</p>
<p>这时候需要的是一个容器编排系统，他要提供的能力包括但不仅限于：</p>
<ul>
<li>自动化的部署和回滚 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Automated rollouts and rollbacks</a> </li>
<li>服务发现和负载均衡 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">Service discovery and load balancing</a> </li>
<li>水平伸缩 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/run-application/horizontal-%60pod%60-autoscale/">Horizontal scaling</a> </li>
<li>存储编排 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">Storage orchestration</a> </li>
<li>配置管理 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/configuration/secret/">Secret and configuration management</a> </li>
<li>自动装箱 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">Automatic bin packing</a> </li>
<li>批量执行 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Batch execution</a> </li>
<li>自我修复 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/%60ReplicationController%60/#how-a-%60ReplicationController%60-works">Self-healing</a> </li>
<li>可扩展 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/extend-kubernetes/">Designed for extensibility</a></li>
</ul>
<p>主流的选择：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://mesos.apache.org/">Apache Mesos</a> </li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/">Docker Swarm</a> </li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> （事实上的标准）</li>
</ul>
<p>DevOps流程：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fm5McJLsJitCZoHoq2d3-7tp0Gu7.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fm5McJLsJitCZoHoq2d3-7tp0Gu7.png"  lazyload></a></p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmlZ-IZwAewOda7BvHLlucRIh4Z6.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmlZ-IZwAewOda7BvHLlucRIh4Z6.png"  lazyload></a></p>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">Kubernetes</a>是用于自动部署，扩展和管理容器化应用程序的开源系统。</p>
<p>Kubernetes，构建在Docker技术之上，为跨主机的容器化应用提供资源调度、服务发现、高可用管理和弹性伸缩等一整套功能，它提供了完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。它的目标不仅仅是一个编排系统，更是提供一个规范，可以让你来描述集群的架构，定义服务的最终状态，Kubernetes可以帮你将系统自动达到和维持在这个状态。</p>
<p>经典的Kubernetes集群架构：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fpq5XcA3c49wVFcpJWthJvab2Yiv.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fpq5XcA3c49wVFcpJWthJvab2Yiv.png"  lazyload></a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>简单的单机环境搭建：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://minikube.sigs.k8s.io/docs/start/">minikube</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tools/">kubectl</a></li>
</ul>
<blockquote>
<p>如果不想在本机上折腾，可以体验下在线启动一个minikube环境：<a target="_blank" rel="noopener" href="https://www.katacoda.com/courses/kubernetes">katacoda</a></p>
</blockquote>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fh8tlKg-zVjb76jUL5YxmxNDgLWk.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fh8tlKg-zVjb76jUL5YxmxNDgLWk.png"  lazyload></a></p>
<h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>[pod](https://kubernetes.io/zh/docs/concepts/workloads/%60pod%60s/)</code>是Kubernetes的最基本的部署调度单元，Kubernetes不直接操作单个容器，所有容器都在<code>pod</code>中运行。<code>pod</code>是一组紧密相关的容器。关于<code>pod</code>的基础知识：</p>
<ul>
<li><p>—个<code>pod</code>的所有容器都运行在同—个节点node上; 一个<code>pod</code>绝不跨越两个节点 </p>
</li>
<li><p>一个<code>pod</code>中的容器共享PID、IPC、Network 和 UTS namespace等 </p>
<blockquote>
<p>虽然网络存储都是共享的，但是CPU和Memory就不是。多容器之间可以有属于自己的Cgroup，也就是说我们可以单独的对<code>pod</code>中的容器做资源（MEM&#x2F;CPU）使用的限制。</p>
</blockquote>
</li>
<li><p>在外部看来，每个<code>pod</code>都是一个独立的逻辑机器，拥有独立的IP、主机名、进程等</p>
</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtGREflYeibmk60Ro-ghMMEct9yX.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtGREflYeibmk60Ro-ghMMEct9yX.png"  lazyload></a></p>
<blockquote>
<p>为什么需要<code>pod</code>而不是直接使用容器？因为不管是Docker还是Kubernetes，都期望让每个进程运行于自己的容器中，容器被设计为每个容器只运行一个进程（即容器的“单进程模型”，但并不是指容器里只能运行“一个”进程，像Nginx在启动后主进程会再开启若干个Worker进程负责请求的处理，Apache则是会为每个请求创建一个进程，而是指容器没有管理多个进程的能力）。有的时候，除了运行我们的主应用程序之外，还需要运行一些与该应用紧密相关的进程，如监控用的agent，日志收集器等等。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymagic/p/10553335.html">Kubernetes — 为什么我们需要pod？</a></p>
</blockquote>
<p>由于 <code>pod</code> 比较轻量， 我们可以在几乎不导致任何额外开销的前提下拥有尽可能多的<code>pod</code>。 与将所有内容填充到一个 <code>pod</code> 中不同， 我们应该将应用程序组织到多个 <code>pod</code> 中， 而每个 <code>pod</code> 只包含紧密相关的组件或进程。</p>
<blockquote>
<p>想象一下一个简单的web应用，可能包含了前端应用，Nginx，后端应用Tomcat，数据库MySQL等多个进程，应该怎样设计容器和<code>pod</code>？需要考虑的几个因素：是否需要一起运行？资源利用率？扩缩容？</p>
</blockquote>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>可以通过<code>kubectl</code>命令简单地创建一个<code>pod</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run kubia --image=luksa/kubia --port=8080</span><br></pre></td></tr></table></figure>

<p>底层做的事情如下图所示。执行<code>kubectl</code>命令时，实际上是由客户端的<code>kubectl</code>命令行工具发送REST请求到master节点的<code>API Server</code>，然后工作节点上的<code>kubelet</code>收到监听的通知执行Docker镜像拉取、启动等<code>pod</code>创建工作。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fu30_xgbE6-11BJzMw4p6Q10QZTz.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fu30_xgbE6-11BJzMw4p6Q10QZTz.png"  lazyload></a><br>作为Kubernetes老手<del>（资深yaml工程师）</del>，更常见的创建方式是使用yaml描述一个<code>pod</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">`pod`</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>kubectl explain pod</code>命令查看API对象字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-manual.yaml</span><br></pre></td></tr></table></figure>

<p><code>pod</code>创建后，就可以请求Kubernetes来获得<code>pod</code>的详细信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po kubia-manual -o yaml</span><br></pre></td></tr></table></figure>

<p>如果想获取<code>pod</code>的日志，那可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs kubia-manual</span><br></pre></td></tr></table></figure>

<p>如何向<code>pod</code>发送请求？可以使用<code>kubectl expose</code>命令创建一个service，调试时也可以设置将本地网络端口转发到<code>pod</code>中的端口，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward kubia-manual 8888:8080</span><br></pre></td></tr></table></figure>

<h3 id="删除、停止"><a href="#删除、停止" class="headerlink" title="删除、停止"></a>删除、停止</h3><p>删除一个<code>pod</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按名称删除</span></span><br><span class="line">kubectl delete po kubia-manual</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用标签选择器删除 `pod`</span></span><br><span class="line">kubectl delete po -l creation method=manual</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除一个<code>pod</code>时，Kubenetes 会终止该 <code>pod</code> 中的所有容器 。 Kubenetes 向进程发送一个 <code>SIGTERM</code>信号并等待一定的秒数(默认为 30)，使其正常关闭。如果它没有及时关闭，则通过 <code>SIGKILL</code> 终止该进程 。 因此，为了确保你 的进程总是正常关闭，进程需要正确处理 <code>SIGTERM</code> 信号 。</p>
</blockquote>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Kubernetes中的标签（<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">label</a>）用于组织和分类<code>pod</code>和所有其他的资源，标签可以是任意key-value的键值对，一个资源可以有多个标签。可以通过标签选择器（selector）选择指定标签的资源。</p>
<p>创建<code>pod</code>时指定标签：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">`pod`</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual-v2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">creation_method:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>创建成功后就可以在get <code>pod</code>时加上–show-labels命令来展示标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod --show-labels</span><br></pre></td></tr></table></figure>

<p>添加或修改现有<code>pod</code>的标签：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加</span></span><br><span class="line">kubectl label pod kubia-manual creation_method=manual</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改时需要带上--overwrite</span></span><br><span class="line">kubectl label po kubia-manual-v2 env=debug --overwrite</span><br></pre></td></tr></table></figure>

<p>在打上标签后，就可以通过标签选择器过滤：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出标签creation_method=manual且<span class="built_in">env</span>!=debug的`pod`，其他的匹配方式：<span class="keyword">in</span>/notin等等</span></span><br><span class="line">kubectl get pod -l creation_method=manual,env!=debug</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出有<span class="built_in">env</span>标签的所有`pod`</span></span><br><span class="line">kubectl get po -l env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出没有<span class="built_in">env</span>的所有`pod`</span></span><br><span class="line">kubectl get po -l &#x27;!env&#x27;</span><br></pre></td></tr></table></figure>

<p>另一种过滤的方法：通过<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/field-selectors/">字段选择器Field-selector</a>。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/namespaces/">命名空间</a>（NameSpace）用来给对象名称提供一个作用域，资源只需在命名空间中保持唯一。除了隔离资源，命名空间还可用于仅允许某些用户访问某些特定资源，甚至限 制单个用户可用的计算资源数量 。 一些使用场景：</p>
<ul>
<li>多租户</li>
<li>多环境</li>
</ul>
<p>查看命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有的命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出一个命名空间下的`pod`</span></span><br><span class="line">kubectl get pod --namespace kube-system</span><br></pre></td></tr></table></figure>

<p>创建命名空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace my-namespace</span><br></pre></td></tr></table></figure>

<h3 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h3><p>将 <code>pod</code> 调度到某个节点后，该节点上的 Kubelet 会运行 <code>pod</code> 的容器，只要该 <code>pod</code> 存在， 就会保持运行。 如果容器的主进程崩溃，Kubelet 将重启容器。 假设应用中有一个导致它每隔一段时间就会崩溃的bug, Kubenetes 会自动重启应用。</p>
<p>Kubernetes的<code>pod</code>健康检查机制使用了存活探针 (liveness probe) ，主要有几类：</p>
<ul>
<li>HTTP GET探针：对容器的IP地址发起HTTP GET请求，如果返回2xx或3xx则认为容器正常</li>
<li>TCP Socket探针：与容器的指定端口建立TCP连接</li>
<li>Exec探针：在容器内执行任意命令，检查命令的退出状态码是否为0</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tasks/configure-%60pod%60-container/configure-liveness-readiness-startup-probes/">Kubernetes的探针</a>：</p>
<ul>
<li>livenessProbe：存活探针</li>
<li>readinessProbe：就绪探针，在就绪探针上报前，<code>pod</code>不会接受来自Service的流量</li>
<li>startupProbe：启动探针，可以对启动较慢的容器设置，如果在指定时间内没有启动成功，会杀死容器并按策略重启</li>
</ul>
</blockquote>
<h3 id="计算资源管理"><a href="#计算资源管理" class="headerlink" title="计算资源管理"></a>计算资源管理</h3><p>创建一个<code>pod</code>时，可以指定每个<code>pod</code>中容器对CPU和内存的资源请求量（requests，需要多少）和资源限制量（limits，能用多少）。也可以定义和申请自定义资源，例如可用GPU数量。</p>
<ul>
<li>资源requests会影响调度器调度</li>
<li>资源limits不受节点可分配资源量的限制（可以超卖）</li>
</ul>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/">官网文档</a></p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">`pod`</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/app:v4</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-aggregator</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/log-aggregator:v6</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="ReplicationController和ReplicaSet"><a href="#ReplicationController和ReplicaSet" class="headerlink" title="ReplicationController和ReplicaSet"></a>ReplicationController和ReplicaSet</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>正常情况下我们并不会直接创建<code>pod</code>，而是通过像<code>ReplicationController</code>和<code>ReplicaSet</code>这样的资源来管理<code>pod</code>。它们可以确保<code>pod</code>始终保持运行状态（通俗地讲，就是我告诉Kubernetes“我希望这个pod有多少个副本，请帮我管理好”）。</p>
<p><code>ReplicationController</code>会持续监控正在运行的<code>pod</code>列表， 并保证相应 ” 类型” 的 <code>pod</code>的数目与期望相符。 如正在运行的<code>pod</code>太少， 它会根据<code>pod</code>模板创建新的副本。如正在运行的<code>pod</code>太多， 它将删除多余的副本。</p>
<blockquote>
<p>即使只有一个<code>pod</code>，也应该使用<code>RelicationController</code>管理。如果可能，不要使用独立的 pods（即，未绑定到 <code>[ReplicaSet](https://kubernetes.io/zh/docs/concepts/workloads/controllers/%60ReplicaSet%60/)</code> 或 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a> 的 <code>pod</code>）。 如果节点发生故障，将不会重新调度独立的 <code>pod</code>。</p>
</blockquote>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><code>ReplicationController</code>的创建示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">`ReplicationController`</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>主要包含3个部分：</p>
<ol>
<li><p><code>selector</code>：通过标签选择器决定创建和管理哪些pod </p>
<blockquote>
<p>尝试删除<code>pod</code>或者修改<code>pod</code>标签，<code>ReplicationController</code>会检查实际的<code>pod</code>数量，并创建新的<code>pod</code>。</p>
</blockquote>
</li>
<li><p><code>replicas</code> : 表示需要运行几个副本 </p>
</li>
<li><p><code>template</code>: 用于创建新pod副本的模板</p>
</li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtrEPMyT5aWMsljMrcRccdXNLwMM.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtrEPMyT5aWMsljMrcRccdXNLwMM.png"  lazyload></a><br>在创建后，<code>ReplicationController</code>会根据标签选择器查找匹配的<code>pod</code>，并与期望的副本数对比：太少则根据<code>pod</code>模板创建新的<code>pod</code>，太多则删除多余的<code>pod</code>。</p>
<h3 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过命令</span><br><span class="line">kubectl scale rc kubia --replicas 5</span><br><span class="line"></span><br><span class="line">// 修改rc定义中的spec.replicas</span><br><span class="line">kubectl edit rc kubia</span><br></pre></td></tr></table></figure>

<h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p><code>[ReplicaSet](https://kubernetes.io/zh/docs/concepts/workloads/controllers/%60ReplicaSet%60/)</code>的行为与<code>ReplicationController</code>完全相同，区别是<code>pod</code>选择器的表达能力更强。<code>ReplicationController</code> 的标签选择器只允许包含某个标签的匹配 <code>pod</code>, 但 <code>ReplicaSet</code> 的选择器还允许匹配缺少某个标签的 <code>pod</code>, 或包含特定标签名的 <code>pod</code>。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">selector:</span><br><span class="line">	matchExpressions:</span><br><span class="line">  	- key: app</span><br><span class="line">    	operator: In</span><br><span class="line">      values:</span><br><span class="line">      	- kubia</span><br></pre></td></tr></table></figure>

<p>支持的operator：In、NotIn、Exists（包含指定标签名，值不关心）、DoesNotExist等。</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>[Deployment](https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/)</code>用来支持声明式地升级应用。</p>
<p>如果不使用<code>Deployment</code>，升级的就要这么做：</p>
<ul>
<li>直接删除所有现有的 <code>pod</code>, 然后创建新的 <code>pod</code> - 简单粗暴，但需要接受服务暂时不可用</li>
<li>先创建新的 <code>pod</code>, 并等待它们成功运行之后， 再删除旧的 <code>pod</code>。 可以先创建所有新的 <code>pod</code>, 然后一次性删除所有旧的 <code>pod</code>, 或者按顺序创建新的<code>pod</code>, 然后逐渐删除旧的 <code>pod</code> - 需要兼容新老应用同时运行</li>
</ul>
<p>实际上，Kubernetes确实提供了一个<code>rolling-update</code>命令，它通过创建一个新的<code>ReplicationController</code>并动态地替换<code>pod</code>来支持滚动升级。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FrV0mhM4sQWin9unTDEeqbDxLTRG.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FrV0mhM4sQWin9unTDEeqbDxLTRG.png"  lazyload></a><br>与<code>ReplicationController</code>和<code>ReplicaSet</code>相比，<code>Deployment</code>是更高级别的Kubernetes资源，它基于<code>ReplicaSet</code>来管理<code>pod</code>，它的机制与<code>rolling-update</code>命令类似，通过对两个<code>ReplicaSet</code>的协调来实现升级。</p>
<h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nodejs</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia:v1</span></span><br></pre></td></tr></table></figure>

<p><code>Deployment</code>创建会同时创建一个受其管理的<code>ReplicaSet</code>，实际的<code>pod</code>是由 <code>Deployment</code> 的 <code>ReplicaSet</code> 创建和管理的。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p><code>Deployment</code>支持上面所说的两种升级策略：</p>
<ul>
<li><code>RollingUpdate</code>：滚动升级</li>
<li><code>Recreate</code>：一次性删除旧的<code>pod</code>，然后创建新版本的<code>pod</code></li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置最小可用时间（指定新创建的`pod`至少要成功运行多久之后，才能将其视为可用）</span></span><br><span class="line">kubectl patch deployment kubia -p &#x27;&#123;&quot;spec&quot;: &#123;&quot;minReadySeconds&quot;: 10&#125;&#125;&#x27; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察升级过程</span></span><br><span class="line">while true; do curl http://10.96.17.217; sleep 1; don</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新镜像</span></span><br><span class="line">kubectl set image deployment kubia nodejs=luksa/kubia:v2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观察`ReplicaSet`</span></span><br><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure>

<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到上一个版本</span></span><br><span class="line">kubectl rollout undo deployment kubia</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示版本</span></span><br><span class="line">kubectl rollout history deployment kubia</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以回滚到特定版本</span></span><br><span class="line">kubectl rollout undo deployment kubia --to-revision 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">暂停升级</span></span><br><span class="line">kubectl rollout pause deployment kubia</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复升级</span></span><br><span class="line">kubectl rollout resume deployment kubia</span><br></pre></td></tr></table></figure>

<h2 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tasks/run-application/horizontal-%60pod%60-autoscale/">HPA</a>(Horizontal pod Autoscaler)用于支持<code>pod</code>的水平伸缩，它可以基于CPU利用率&#x2F;内存（或者其他<a target="_blank" rel="noopener" href="https://git.k8s.io/community/contributors/design-proposals/instrumentation/custom-metrics-api.md">自定义度量指标</a>）自动扩缩 <code>ReplicationController</code>、<code>Deployment</code>、<code>ReplicaSet</code> 和 <code>StatefulSet</code> 中的 Pod 数量。工作机制如下图：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FlepXUnG5qGxdWoIwfwuzucByb1c.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FlepXUnG5qGxdWoIwfwuzucByb1c.png"  lazyload></a></p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><code>[Service](https://kubernetes.io/zh/docs/concepts/services-networking/service/)</code>是一种抽象的对象，它定义了一组<code>pod</code>的逻辑集合和一个用于访问它们的策略。在Kubernetes的世界里，<code>pod</code>的生命是短暂的，可能会被动态创建和销毁，<code>ReplicaSet</code>&#x2F;<code>Deployment</code>这些组件会对<code>pod</code>进行扩缩容，而<code>Service</code>组件提供类似负载均衡的能力。应该通过<code>Service</code>访问<code>pod</code>提供的服务，而不是直接请求<code>pod</code>。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fjjo1HJJejpynjvtXVRNT0pbyNoL.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fjjo1HJJejpynjvtXVRNT0pbyNoL.png"  lazyload></a></p>
<h3 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h3><p>示例：创建一个<code>Service</code>，使用端口80接收请求，并将请求路由到标签<code>app=kubia</code>的<code>pod</code>的8080端口上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name:  kubia</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app:  kubia</span><br><span class="line">  # type:  LoadBalancer | ClusterIP | NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port:  80</span><br><span class="line">    targetPort:  8080</span><br></pre></td></tr></table></figure>

<p>创建成功后，可以查看<code>Service</code>的信息，并在集群内部访问。</p>
<p>服务的<code>spec.type</code>用于指定类型，决定了<code>Service</code>如何对外提供服务，可选项包括：</p>
<ul>
<li>ClusterIP：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的ServiceType。 </li>
<li>NodePort：通过每个工作节点上的IP和指定的端口暴露服务。可以通过访问任意:访问到该服务，发送到该主机端口的请求会被kubernetes路由到提供服务的Pod上。</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtATEsI24dvDsIDgAXEnJZdB33sh.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtATEsI24dvDsIDgAXEnJZdB33sh.png"  lazyload></a></p>
<ul>
<li>LoadBalancer：使用云提供商的负载局衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnWtz43vnNp5WNWpkQOF3UO8XTgx.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnWtz43vnNp5WNWpkQOF3UO8XTgx.png"  lazyload></a></p>
<ul>
<li>ExternalName：将服务映射到 DNS 名称（例如：externalName: my.database.example.com），而不是典型的选择器。</li>
</ul>
<p>Kubernetes支持配置service的<code>spec.sessionAffinity</code>属性来设置会话亲和策略，可选项包括：</p>
<ul>
<li>None：随机转发</li>
<li>ClientIP：将来自同一个client ip的请求转发到同一个<code>pod</code></li>
</ul>
<blockquote>
<p>因为工作在传输层，因此不支持cookie亲和之类的策略。</p>
</blockquote>
<blockquote>
<p>Kubernetes中的IP类型：</p>
<ul>
<li>Node IP：Node节点的IP地址，是Kubernetes集群中节点的物理网卡IP地址(一般为内网)，所有属于这个网络的服务器之间都可以直接通信，所以Kubernetes集群外要想访问Kubernetes集群内部的某个节点或者服务，肯定得通过Node IP进行通信（这个时候一般是通过外网IP了）</li>
<li>pod IP: <code>pod</code>的IP地址，它是Docker Engine根据docker0网桥的IP地址段进行分配的（我们这里使用的是flannel这种网络插件保证所有节点的<code>pod</code> IP不会冲突）</li>
<li>Cluster IP: Service的IP地址，是一个虚拟的IP，仅仅作用于Kubernetes Service这个对象，由Kubernetes自己来进行管理和分配地址，当然我们也无法ping这个地址，他没有一个真正的实体对象来响应，他只能结合Service Port来组成一个可以通信的服务。</li>
</ul>
</blockquote>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>客户端可以通过环境变量来或者服务的IP地址和端口等信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec kubia-rs-7kww9 env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">KUBIA_PORT=tcp://10.103.97.185:80</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">KUBIA_PORT_80_TCP_PORT=80</span></span><br></pre></td></tr></table></figure>

<p>也可以通过dns访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it kubia-rs-7kww9 bash</span><br><span class="line"></span><br><span class="line">root@kubia-rs-7kww9:/# curl http://kubia</span><br><span class="line">You&#x27;ve hit kubia-rs-87s7w</span><br><span class="line">root@kubia-rs-7kww9:/# curl http://kubia.default</span><br><span class="line">You&#x27;ve hit kubia-rs-87s7w</span><br><span class="line">root@kubia-rs-7kww9:/# curl http://kubia.default.svc</span><br><span class="line">You&#x27;ve hit kubia-rs-8xpzx</span><br><span class="line">root@kubia-rs-7kww9:/# curl http://kubia.default.svc.cluster.local</span><br><span class="line">You&#x27;ve hit kubia-rs-8xpzx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minikube不支持LoadBalancer类型的服务，因此没有外部IP，可以通过一下命令从外部访问：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service kubia</span><br></pre></td></tr></table></figure>

<h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>对外暴露服务时，每个LoadBalancer Service都需要自己的负载均衡器和独立的公网IP，而<code>Ingress</code>只需要一个公网IP就能为许多服务提供入口。它位于HTTP层，因此可以提供cookie会话亲和性等功能。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fv6Pr8TTXYC9UzIUBb9d2slI7ctS.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fv6Pr8TTXYC9UzIUBb9d2slI7ctS.png"  lazyload></a><br>如下图所示，客户端访问<code>Ingress</code>控制器时，会首先执行DNS查找kubia.example.com，DNS服务器会返回<code>Ingress</code>控制器的IP。客户端然后向 <code>Ingress</code> 控制器发送 HTTP 请求，并在 Host 头 中指定 kubia.example.com。控制器从该头部确定客户端尝试访问哪个服务，通 过与该服务关联的 <code>Endpoint</code>对象查看 <code>pod</code> IP， 并将客户端的请求转发给其中一个 <code>pod</code> 。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FhTEKN9TAVqEuTTEWhlpe5M9J7ZH.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FhTEKN9TAVqEuTTEWhlpe5M9J7ZH.png"  lazyload></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p><code>Volume</code>有点像Docker中的数据卷，用于持久化数据，（正常容器重启后，写入到文件系统中的数据就丢失了）。主要有几类<code>Volume</code>：</p>
<ul>
<li><strong>emptyDir</strong>：最简单，用于存储临时数据的空目录，常用于在同一个pod的容器之间共享文件。会在<code>pod</code>被删除时被删除。</li>
<li><strong>gitRepo</strong>：顾名思义，会从git仓库clone数据初始化，但不会跟对应仓库保持同步（可以看成是一个特殊的<code>emptyDir</code>）</li>
<li><strong>HostPath</strong>：挂载工作节点的文件系统上的特定文件或目录，因此同一个节点上运行的pod间可以看到相同的文件。不会在<code>pod</code>被删除时删除。</li>
<li><strong>PersistentVolumes</strong>、<strong>PersistentVolumesClaim</strong>：其他的持久卷类型都要求开发人员了解集群中可用的真实网络存储的基础结构，而PV和PVC是Kubernetes对底层存储的抽象，用来屏蔽基础设施的细节。集群管理员可以设置底层存储（比如NFS、OSS等），开发者则创建PVC（持久卷声明），指定所需要的容量和访问模式，由Kubernetes匹配可用的PV并分配。</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgkW5RReHAQ0j4Ytna3d28caWSuf.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgkW5RReHAQ0j4Ytna3d28caWSuf.png"  lazyload></a></p>
<h3 id="ConfigMap和Secret"><a href="#ConfigMap和Secret" class="headerlink" title="ConfigMap和Secret"></a>ConfigMap和Secret</h3><p>配置应用的几种方式：</p>
<ul>
<li>向容器传递命令行参数 </li>
<li>为每个容器设置自定义环境变量 </li>
<li>通过特殊类型的<code>Volume</code>（比如<code>gitRepo</code>）将配置文件挂载到容器中</li>
</ul>
<p>前两者基本类似于硬编码的方式，而第3种依赖于特定的存储类型。Kubernetes提供了<code>ConfigMap</code>和<code>Secret</code>提供配置信息管理。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/">ConfigMap</a>：Kubenetes 允许将配置选项分离到单独的资源对象 <code>ConfigMap</code> 中， 本质上就是一个键&#x2F;值对映射，值可以是短字面量，也可以是完整的配置文件。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/configuration/secret/">Secret</a>：对象类型用来保存敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 <code>Secret</code> 中比放在<code>pod</code>的定义或者容器镜像中来说更加安全和灵活。</li>
</ul>
<p>在<code>Pod</code>中使用<code>ConfigMap</code>有几种方式：</p>
<ol>
<li>设置环境变量的值 </li>
<li>在容器里设置命令行参数 </li>
<li>在只读卷里面添加一个文件，让应用来读取 </li>
<li>编写代码在 <code>Pod</code> 中运行，使用 Kubernetes API 来读取 <code>ConfigMap</code></li>
</ol>
<p><code>pod</code>通过名称引用<code>ConfigMap</code>，在不同的环境下可以通过配置<code>ConfigMap</code>来实现类似auto-config的效果。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fvfx6YBO00SClVcPvyWV-HP0s_nv.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fvfx6YBO00SClVcPvyWV-HP0s_nv.png"  lazyload></a><br><code>Secret</code>与<code>ConfigMap</code>的结构类似，也是键值对形式，使用方法也相同。区别在于：</p>
<ul>
<li>Kubenetes会只将 <code>Secret</code> 分发到需要访问 <code>Secret</code> 的 <code>pod</code> 所在的机器节点。</li>
<li><code>Secret</code> 只会存储在节点的内存中， 永不写入物理存储，从节点上删除 <code>Secret</code> 时不需要擦除磁盘。</li>
</ul>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/job/">Job</a>负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个<code>pod</code>成功结束。<br>Job 会创建一个或者多个 <code>pod</code>，并将继续重试 <code>pod</code> 的执行，直到指定数量的 <code>pod</code> 成功终止。 随着 <code>pod</code> 成功结束，<code>Job</code> 跟踪记录成功完成的 <code>pod</code> 个数。 当数量达到指定的成功个数阈值时，任务（即 <code>Job</code>）结束。 删除 <code>Job</code> 的操作会清除所创建的全部 <code>pod</code>。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnVHJ8nmbUYKRySAiU3s8MchfMS_.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnVHJ8nmbUYKRySAiU3s8MchfMS_.png"  lazyload></a><br>Kubernetes支持以下几种<code>Job</code>：</p>
<ul>
<li>非并行Job：通常创建一个<code>pod</code>直至其成功结束 </li>
<li>固定结束次数的<code>Job</code>：设置<code>.spec.completions</code>，创建多个<code>pod</code>，直到<code>.spec.completions</code>个<code>pod</code>成功结束 </li>
<li>带有工作队列的并行<code>Job</code>：设置<code>.spec.Parallelism</code>但不设置<code>.spec.completions</code>，当所有<code>pod</code>结束并且至少一个成功时，<code>Job</code>就认为是成功</li>
</ul>
<p>根据<code>.spec.completions</code>和<code>.spec.Parallelism</code>的设置，可以将Job划分为以下几种类型：</p>
<table>
<thead>
<tr>
<th>Job类型</th>
<th>使用示例</th>
<th>行为</th>
<th>completions</th>
<th>Parallelism</th>
</tr>
</thead>
<tbody><tr>
<td>一次性Job</td>
<td>数据库迁移</td>
<td>创建一个pod直至其成功结束</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>固定结束次数的Job</td>
<td>处理工作队列的pod</td>
<td>依次创建一个pod运行直至completions个成功结束</td>
<td>2+</td>
<td>1</td>
</tr>
<tr>
<td>固定结束次数的并行Job</td>
<td>多个pod同时处理工作队列</td>
<td>依次创建多个pod运行直至completions个成功结束</td>
<td>2+</td>
<td>2+</td>
</tr>
<tr>
<td>并行Job</td>
<td>多个pod同时处理工作队列</td>
<td>创建一个或多个pod直至有一个成功结束</td>
<td>1</td>
<td>2+</td>
</tr>
</tbody></table>
<h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>用来在工作节点上运行并且只运行1个pod实例，通常用于像日志收集、资源监控这一类的工作。还有个例子是Kubernetes的<code>kube-proxy</code>进程，用来在每个节点上运行以支持<code>Service</code>组件。</p>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 是用来管理有状态应用的工作负载 API 对象。<code>StatefulSet</code> 用来管理 <code>[pod](https://kubernetes.io/docs/concepts/workloads/%60pod%60s/%60pod%60-overview/)</code> 集合的部署和扩缩， 并为这些 <code>pod</code> 提供持久存储和持久标识符。<code>StatefulSet</code>能提供的：</p>
<ul>
<li>稳定的、唯一的网络标识符（<code>pod</code>名称、主机名等）</li>
<li><ul>
<li>由<code>StatefulSet</code>创建的<code>pod</code>拥有规则有序的标识，例如A-0，A-1</li>
<li>在扩容时，<code>StatefulSet</code>会使用下一个还没用到的顺序索引值创建一个新的<code>pod</code>实例；在缩容时，<code>Statefulset</code>将会最先删除最高索引值的实例</li>
</ul>
</li>
<li>稳定的、持久的存储 <ul>
<li>每个 Statefulset的 <code>pod</code>都需要关联到不同的持久卷声明， 与独自的持久卷相对应。</li>
<li>在扩容时，会自动创建持久卷；在缩容时，只会删除<code>pod</code>，但不会删除与之绑定的持久卷，并会在扩容时重新挂载上</li>
</ul>
</li>
<li>有序的、优雅的部署和缩放</li>
<li>有序的、自动的滚动更新</li>
</ul>
<blockquote>
<p>与<code>ReplicaSet</code>或<code>ReplicationController</code>相比，就类似于宠物（PetSet）与牛的区别。</p>
<ul>
<li><code>StatefulSet</code>：在<code>pod</code>被重新调度后会保留标识和状态。 </li>
<li><code>ReplicaSet</code>：<code>pod</code>副本可以随时被替换，替换后的<code>pod</code>有全新的标识符、存储等等</li>
</ul>
</blockquote>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftcki3A65VDmxVpdBKExgRvhTGFE.svg"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftcki3A65VDmxVpdBKExgRvhTGFE.svg"  lazyload></a></p>
<p>Kubernetes集群分为两部分：控制平面和工作节点。控制平面负责控制整个集群的运作，而工作节点则负责运行<code>pod</code>和相关的组件。Kubernetes的这些组件都是单独的进程，之间通过apiserver通信。除了工作节点的组件需要运行在同一个物理节点之上，控制平面组件可以分布在不同节点上，为了保证高可用，一般还有部多个实例。</p>
<h2 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h2><p>控制平面的组件包括<code>etcd</code>、<code>apiserver</code>、<code>scheduler</code>、<code>controller-manager</code>等。</p>
<p><code>etcd</code> 分布式持久化存储，保存了整个集群的状态，一些关键特性：</p>
<ul>
<li>key-value存储</li>
<li>唯一能直接和<code>etcd</code> 通信的是<code>apiserver</code>。所有其他组件通过API 服务器间接地读取、写入数据到<code>etcd</code></li>
<li>分布式，通过RAFT协议达成一致性</li>
</ul>
<p><code>apiserver</code> 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制，提供RESTful API给其他组件和<code>kubectl</code>调用，整体流程如下：</p>
<ol>
<li><code>kubectl</code>发起HTTP POST请求给<code>apiserver</code> </li>
<li>通过认证插件认证客户端 </li>
<li>通过鉴权插件授权客户端 </li>
<li>通过准入控制插件验证资源修改请求 </li>
<li>验证资源 </li>
<li>将状态存储到<code>etcd</code></li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fh-VRMi_Jx19lvULSFL7ED8BLp21.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fh-VRMi_Jx19lvULSFL7ED8BLp21.png"  lazyload></a><br><code>scheduler</code> 负责资源的调度，按照预定的调度策略将 <code>pod</code> 调度到相应的机器上。它使用调度算法决定将<code>pod</code>部署到哪个节点上，默认的算法如下：</p>
<ul>
<li>过滤所有节点，找出能分配给<code>pod</code>的可用节点列表 </li>
<li>对可用节点列表按优先级排序，找出最优节点。如果多个节点都有最高优先级，那么则循环分配，确保平均分配给<code>pod</code></li>
</ul>
<p>查找可用节点的逻辑：</p>
<ul>
<li>节点是否能满足<code>pod</code>对硬件资源的请求 </li>
<li>节点是否耗尽资源(是否报告过内存&#x2F;硬盘压力参数) ? </li>
<li><code>pod</code>是否要求被调度到指定节点(通过名字)， 是否是当前节点? </li>
<li>节点是否有和<code>pod</code>规格定义里的节点选择器一致的标签(如果定义了的话)? </li>
<li>如果<code>pod</code>要求绑定指定的主机端口，那么这个节点上的这个端口是否已经 被占用? </li>
<li>如果<code>pod</code>要求有特定类型的卷， 该节点是否能为此<code>pod</code>加载此卷， 或者说该节点上是否已经有<code>pod</code>在使用该卷了? </li>
<li><code>pod</code>是否能够容忍节点的污点？ </li>
<li><code>pod</code>是否定义了节点、<code>pod</code>的亲缘性以及非亲缘性规则?如果是，那么调度节点给该<code>pod</code>是否会违反规则?</li>
</ul>
<p><code>scheduler</code>不会命令选中的节点(或者节点上运行的<code>Kubelet</code>) 去运行<code>pod</code>。 <code>scheduler</code>做的就是通过 <code>apiserver</code>更新 <code>pod</code>的定义。 然后<code>apiserver</code>再去通知 <code>Kubelet</code>该 <code>pod</code> 已经被调度过。 当目标节点上的 <code>Kubelet</code> 发现该 <code>pod</code> 被调度到本节点， 它就会创建并且运行 <code>pod</code> 的容器。</p>
<p><code>controller-manager</code> 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。</p>
<blockquote>
<p><code>apiserver</code>只做了存储资源到 <code>etcd</code> 和通知客户端有变更的工作。 <code>scheduler</code>则只是给 <code>pod</code> 分配节点， 所以需要有活跃的组件确保系统真实状态朝 <code>apiserver</code>定义的期望的状态收敛。 这个工作由<code>controller-manager</code>里的控制器来实现。</p>
</blockquote>
<p>控制器通过<code>apiserver</code>监听资源变更，对变更执行对应的操作。控制器类型包括：</p>
<ul>
<li>Replication管理器 (<code>ReplicationController</code>资源的管理器)</li>
<li><code>ReplicaSet</code>、 <code>DaemonSet</code> 以及 <code>Job</code> 控制器</li>
<li><code>Deployment</code>控制器</li>
<li><code>StatefulSet</code>控制器</li>
<li><code>Node</code>控制器</li>
<li><code>Service</code>控制器</li>
<li><code>Endpoints</code>控制器</li>
<li><code>Namespace</code>控制器</li>
<li><code>PersistentVolume</code>控制器</li>
<li>其他</li>
</ul>
<p>Kubernetes的控制器运行机制总体来说是执行一个控制循环，不断地调整实际状态来满足期望状态。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuPs5k0WK3wyL37ptXNiikKMD0nT.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuPs5k0WK3wyL37ptXNiikKMD0nT.png"  lazyload></a></p>
<p>多个控制器之间互相协作完成<code>pod</code>的创建：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkcKleqYQARzbCazi4IfseAzLF1y.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkcKleqYQARzbCazi4IfseAzLF1y.png"  lazyload></a></p>
<h2 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h2><p>工作节点上的组件包括<code>Kubelet</code>、<code>kube-proxy</code>、容器运行时（Docker、rkt或其他运行时）。</p>
<p><code>kubelet</code> 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理，它的工作内容：</p>
<ul>
<li>首先通过<code>apiserver</code>创建一个Node资源来注册该节点</li>
<li>然后持续监控<code>apiserver</code>是否把该节点分配给<code>pod</code>，如果有，则启动<code>pod</code>容器（具体实现是告诉容器运行时，例如Docker，拉取指定的镜像启动）</li>
<li>随后持续健康容器的运行状态，向<code>apiserver</code>上报状态、事件和资源消耗</li>
<li>运行容器存活探针，当探针报错时重启容器</li>
<li>当<code>pod</code>从<code>apiserver</code>删除时，终止容器，并通知<code>apiserver</code></li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuXlaQOK8IBA0AzRxaaPHDXEZqSE.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuXlaQOK8IBA0AzRxaaPHDXEZqSE.png"  lazyload></a><br><code>kube-proxy</code> 负责为 <code>Service</code> 提供集群内部的服务发现和负载均衡。具体来说，就是实现了内部从<code>Pod</code>到<code>Service</code>和外部的从NodePort向<code>Service</code>的访问。实现方式有两种，具体的可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">官方文档</a>。</p>
<ul>
<li>userspace：在用户空间通过<code>kuber-proxy</code>实现LB的代理服务，这个是<code>kube-proxy</code>的最初的版本，稳定但效率不高。 </li>
<li>iptables：是纯采用iptables来实现LB，性能更好，是目前<code>kube-proxy</code>默认的方式。</li>
</ul>
<p>具体实现上，在Kubernetes集群中，每个Node会运行一个<code>kube-proxy</code>进程, 负责为<code>Service</code>实现clusterIP（VIP）的代理形式，默认使用iptables模式来代理，<code>kube-proxy</code>会监视Kubernetes master对 <code>Service</code> 对象和 <code>Endpoints</code> 对象的添加和移除。 对每个 <code>Service</code>，它会添加上 iptables 规则，从而捕获到达该 <code>Service</code> 的 clusterIP和端口的请求，进而将请求重定向到 <code>Service</code> 的一组 backend 中的某一个上面。 对于每个 <code>Endpoints</code> 对象，它也会安装 iptables 规则，这个规则会选择一个 backend <code>pod</code>。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftnbpo2tiZquRpRQlfZIg3v0rOyi.svg"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftnbpo2tiZquRpRQlfZIg3v0rOyi.svg"  lazyload></a></p>
<p>容器运行时则负责镜像管理以及 <code>pod</code> 和容器的真正运行（CRI，底层是Docker、rkt或其他）。</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p>除了核心组件，还有一些推荐的插件，其中有的已经成为 CNCF 中的托管项目：</p>
<ul>
<li>CoreDNS 负责为整个集群提供 DNS 服务 </li>
<li>Ingress Controller 为服务提供外网入口 </li>
<li>Prometheus 提供资源监控 </li>
<li>Dashboard 提供 GUI </li>
<li>Federation 提供跨可用区的集群</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Kubernetes In Action</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/home/">Kubernetes官方文档</a></li>
</ol>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%A6%82%E8%BF%B0"><span class="top-box-text">概述</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BB%8EDocker%E5%88%B0Kubernetes"><span class="top-box-text">从Docker到Kubernetes</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Kubernetes"><span class="top-box-text">Kubernetes</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="top-box-text">环境搭建</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E7%BB%84%E4%BB%B6"><span class="top-box-text">组件</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pod"><span class="top-box-text">pod</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A6%82%E5%BF%B5"><span class="top-box-text">概念</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA"><span class="top-box-text">创建</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%A0%E9%99%A4%E3%80%81%E5%81%9C%E6%AD%A2"><span class="top-box-text">删除、停止</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A0%87%E7%AD%BE"><span class="top-box-text">标签</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="top-box-text">命名空间</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B"><span class="top-box-text">健康监测</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="top-box-text">计算资源管理</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#ReplicationController%E5%92%8CReplicaSet"><span class="top-box-text">ReplicationController和ReplicaSet</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="top-box-text">概念</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="top-box-text">创建</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="top-box-text">扩缩容</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ReplicaSet"><span class="top-box-text">ReplicaSet</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Deployment"><span class="top-box-text">Deployment</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="top-box-text">概述</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA-2"><span class="top-box-text">创建</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8D%87%E7%BA%A7"><span class="top-box-text">升级</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9B%9E%E6%BB%9A"><span class="top-box-text">回滚</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#HPA"><span class="top-box-text">HPA</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Service"><span class="top-box-text">Service</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="top-box-text">概念</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%9B%E5%BB%BA-3"><span class="top-box-text">创建</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="top-box-text">服务发现</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Ingress"><span class="top-box-text">Ingress</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%85%B6%E4%BB%96"><span class="top-box-text">其他</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Volume"><span class="top-box-text">Volume</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ConfigMap%E5%92%8CSecret"><span class="top-box-text">ConfigMap和Secret</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Job"><span class="top-box-text">Job</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#DaemonSet"><span class="top-box-text">DaemonSet</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#StatefulSet"><span class="top-box-text">StatefulSet</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%9E%B6%E6%9E%84"><span class="top-box-text">架构</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="top-box-text">集群架构</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="top-box-text">控制平面</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="top-box-text">工作节点</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%85%B6%E4%BB%96-1"><span class="top-box-text">其他</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%8F%82%E8%80%83"><span class="top-box-text">参考</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2021/10/15/yun-yuan-sheng-ru-men-zhi-bei-docker/">
          <h3 class="post-title">
            下一篇：云原生入门指北-Docker
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>模块化单体的思考与实践</title>
<meta name="keywords" content="模块化单体的思考与实践, jffu&#39;s blog">
<meta name="description" content="反思微服务的利弊，模块化单体的思考，以及实现。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="模块化单体的思考与实践">
<meta property="og:description" content="反思微服务的利弊，模块化单体的思考，以及实现。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">模块化单体的思考与实践</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-04-18</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
                  ，
                
              </a>
            
              <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">
              微服务
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>去年大背景下，部门对技术资源进行了一轮梳理和降本增效。其中占大头的一块就是应用和应用关联的资源，像是容器、数据库、缓存等等。过程中有种感觉，我们可能“过度微服务化”了：从数据上看，平均一个开发同学负责十几个应用，还不包括二方包等。主要原因可能是由于业务初始对服务的边界划分没有清晰的概念，或者随着业务发展，边界变得模糊。同时也对服务的容量缺乏评估，导致了很多浪费，比如上来先分个10台机器，再搞个分库分表。后来才发现，制造类的toB业务更多的是其业务本身的复杂性，而不是什么高并发。</p>
<p>自从2005年“Micro-Web-Service”这个名词被Peter Rodgers提出，然后Martin Fowler 与 James Lewis 在《<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">Microservices: A Definition of This New Architectural Term</a>》中进一步做了明确定义，十几年发展下来微服务的思想已经深入人心。当一个概念已经烂大街的时候，热度肯定就不高了，但最近有几则新闻又引发了诸多争论：</p>
<p>其一，马斯克称推特现阶段的部分工作将是关闭臃肿的”微服务“，实际上，只有不到20%的微服务是推特需要的。起因是它认为推特的运行速度太慢，之所以如此则是因为推特App需要执行1000多个 “糟糕” 的批处理 RPC，而这只是为了渲染主页的时间线。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpmL_QVWdjxsGMBIdWgWol9ZrffF.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpmL_QVWdjxsGMBIdWgWol9ZrffF.png"  lazyload></a></p>
<p>其二，GitHub 前 CTO Jason Warner 在<a target="_blank" rel="noopener" href="https://twitter.com/jasoncwarner/status/1592227285024636928">推特</a>上表示：“我确信过去十年中，最大的架构错误之一就是全面使用微服务。” “任何构建过大型分布式系统的人都知道他们并不真的那样工作，但还必须适应它。”</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fk_fXgWCpNHn7Y3NAf29mMGkKGme.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fk_fXgWCpNHn7Y3NAf29mMGkKGme.png"  lazyload></a></p>
<p>其二，微服务的先驱和引领者之一的亚马逊的 Prime Video 团队发表了一个<a target="_blank" rel="noopener" href="https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90">案例</a>，将微服务+Serverless架构迁移到单体架构后，节约了90%的成本，引发了开发者社区的众多讨论。</p>
<p>这让我联想起大概两三年前，我们想对一个大的单体应用做优化，这个应用是钉钉小程序的统一后端服务，遇到了很典型的单体系统问题：一个应用同时承载了很多不同身份的业务，不同业务由混杂的团队开发，代码统一维护在一个git仓库中。由于不同开发者的习惯、设计、架构能力不同，且大部分以快速实现业务需求为主，没有合理的模块划分，不同业务功能代码耦合在一起，最后导致改起来很累，出了问题查起来也很累。</p>
<p>当初的第一个想法很自然，那就把这个大单体拆成不同的微服务吧。实际情况是，大多数业务身份的代码在几百到几千行上下，单独作为一个应用感觉又有点太细碎，资源的利用率也很低。另外，这些业务身份因为面向的是产业链上的不同群体，因此业务逻辑千差万别，不像中台有相对标准的流程，可以通过标准能力+扩展点的方式来串联。折腾了几套方案（包括后面讲的模块化方案），最终都没能落地。只能自我安慰下，虽然现状很糟糕，但好像也没到不能忍受的地步，又不是不能用，是吧？</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote>
<p>这部分主要是我个人的杂想，比较虚，不感兴趣的完全可以跳过。</p>
</blockquote>
<h3 id="单体-VS-微服务"><a href="#单体-VS-微服务" class="headerlink" title="单体 VS 微服务"></a>单体 VS 微服务</h3><p>关于单体和微服务的对比很多，虽然大部分都是人云亦云地认为微服务胜于单体，给出的理由不外乎单体应用存在种种痼疾：</p>
<blockquote>
<p><strong>1.复杂性高</strong></p>
<p>在项目初期应该有人可以做到对应用各个功能和实现了如指掌，随着业务需求的增多，各种业务流程错综复杂的揉在一起，整个系统变得庞大且复杂，以至于很少有开发者清楚每一个功能和业务流程细节。</p>
<p>这样会使得新业务的需求评估或者异常问题定位会占用较多的时间，同时也蕴含着未知风险。更糟糕的是，这种极度的复杂性会形成一种恶性循环，每一次更改都会使得系统变得更复杂，更难懂。</p>
<p><strong>2.技术债务多</strong></p>
<p>随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。比如，团队必须长期使用一套相同的技术栈，很难采用新的框架和编程语言。有时候想引入一些新的工具时，就会使得项目中需要同时维护多套技术框架，比如同时维护Hibernate和Mybatis，使得成本变高。</p>
<p><strong>3.错误难隔离</strong></p>
<p>由于业务项目的所有功能模块都在一个应用上承担，包括核心和非核心模块，任何一个模块或者一个小细节的地方，因为设计不合理、代码质量差等原因，都有可能造成应用实例的崩溃，从而使得业务全面受到影响。其根本原因就是核心和非核心功能的代码都运行在同一个环境中。</p>
<p><strong>4. 项目团队间协同成本高，业务响应越来越慢</strong></p>
<p>多个类似的业务项目之间势必会存在类似的功能模块，如果都采用单体模式，就会带来重复功能建设和维护。而且，有时候还需要互相产生交互，打通单体系统之间的交互集成和协作的成本也需要额外付出。</p>
<p>再者，当项目大到一定程度，不同的模块可能是不同的团队来维护，迭代联调的冲突，代码合并分支的冲突都会影响整个开发进度，从而使得业务响应速度越来越慢。</p>
<p><strong>5.扩展成本高</strong></p>
<p>随着业务的发展，系统在出现业务处理瓶颈的时候，往往是由于某一个或几个功能模块负载较高造成的，但因为所有功能都打包在一起，在出现此类问题时，只能通过增加应用实例的方式分担负载，没办法对单独的几个功能模块进行服务能力的扩展，从而带来资源额外配置的消耗，成本较高。</p>
</blockquote>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnveFjBRB2_EKEtCbs7CpnnfLDdJ.webp"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnveFjBRB2_EKEtCbs7CpnnfLDdJ.webp"  lazyload></a></p>
<p>这些问题确实可以通过微服务得到”一定程度”上的解决，可以为每个服务选择最好的语言和架构，可以以小的、垂直切块的形式灵活交付，可以独立扩展服务…然后单体架构的拥趸也能举出一大堆微服务引入的问题（这其中很大一部分是微服务化后的分布式带来的），例如：</p>
<ul>
<li>性能的损失，进程内调用的性能远远高于微服务间RPC</li>
<li>网络的不可靠性带来的种种问题，包括分区、超时等等</li>
<li>难以处理的分布式事务</li>
<li>跟踪，调试的困难，你必须配套建设一套完善的trace和日志系统</li>
<li>需要引入各种额外的支撑组件，例如RPC框架，服务治理，消息队列，熔断保护等等（对比下Spring Boot和Spring Cloud全家桶的规模）。这些还只是开发层面的，其实还有运维层面的，像是CI和自动化工具等</li>
<li>资源利用率问题，这个可以参考开篇</li>
<li>开发、运维还有测试的效率有可能不升反降，举几个例子： <ul>
<li>要拉好几个变更才能完成一个需求的开发，因为需要改动不同的应用或二方包</li>
<li>要特别考虑应用间的前后兼容性问题，比如A服务调B服务，B服务部署时流量会同时打到新老版本上</li>
</ul>
</li>
</ul>
<p>所以微服务的门槛其实挺高的，没有良好的中间件等基础设施支撑，小公司小团队根本玩不动。技术上的门槛也许不难解决，因为现在有很多轮子，也有云厂商提供现成的解决方案。但我认为<strong>微服务带来的最大挑战是架构上的</strong>，可以说对架构师的要求在微服务时代提升到了前所未有的高度，对微服务的设计充满了权衡和陷阱，包括但不限于：如何界定微服务的粒度，确定使用的语言框架，同时还要兼顾到服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通信、事务处理等等非功能需求。上面第二则新闻里， Jason Warner 是推动了GitHub从大型单体演进到微服务架构的大佬，然而他的建议是在合适的阶段再考虑采用微服务架构。这个阶段怎么定义呢？是公司规模？还是用户数？业务的复杂度？亦或是其他指标？这个就看架构师们怎么理解了。</p>
<p>我认同 Jason Warner 的观点，可能还更极端点，那就是<strong>除非到了一定要使用微服务不可的地步，在此之前，尽可能地坚持使用单体架构</strong>。什么时候会是非微服务不可呢，比如：</p>
<ol>
<li>需要使用不同语言来实现异构系统。有时候这不是你想或者不想的问题，而是没有选择，比如说某个功能只有另一种语言才提供类库，亦或是语言本身的性能限制。</li>
<li>模块间需要做隔离。比如一个模块的错误和不稳定已经影响到了整个系统的可用性，并且与系统内的其他模块的关系并不是密不可分的时候，将其切分出去的代价要小于使其稳定的代价。</li>
<li>系统的不同部分要求能够独立地做水平扩展。</li>
</ol>
<p>在此之前，单体架构面临的问题其实更多是<strong>领域划分不合理</strong>导致的，而这个问题并不能通过微服务解决。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FikJqj0P9Pmai4_Qu7SMux7ZfFj0.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FikJqj0P9Pmai4_Qu7SMux7ZfFj0.png"  lazyload></a></p>
<p>单体（Monolithic）并不意味着“不可拆分”，事实上我们普遍采用横向的业务功能维度，以及纵向的分层维度（最基础的，展示层 - 领域服务层 - 持久层）来设计架构。更进一步，可以借助DDD的思想，做好业务领域划分和领域模型的设计。解决了复杂度的问题，其他的问题也就迎刃而解了。当你觉得模块化单体确实已经给系统发展带来限制的时候，再将单独的模块拆分出去成为微服务也不迟。从这个角度看，微服务能带来的最大好处是能够将开发分配给多个较小的团队，而不会让他们互相绊倒，但这似乎是一个组织问题，而不是技术问题？</p>
<p>引用一段“Ruby on Rails 之父”David Heinemeier Hansson的话：</p>
<blockquote>
<p>Replacing method calls and module separations with network invocations and service partitioning within a single, coherent team and application is madness in almost all cases.</p>
</blockquote>
<h3 id="模块化？"><a href="#模块化？" class="headerlink" title="模块化？"></a>模块化？</h3><p>我们常说软件架构设计没有银弹，架构设计就是权衡的过程。在巨石化单体和微服务之间折中，还存在模块化单体这一条路。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqRCI2CI7vlrWd8FdzqIL26MobOW.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqRCI2CI7vlrWd8FdzqIL26MobOW.png"  lazyload></a></p>
<p>模块化（Modular）的思想跟微内核架构（Microkernel Architecture）或者插件式架构（Plug-in Architecture）有点类似。微内核的架构中，存在一个被所有业务系统共同依赖的核心（Kernel，也称为 Core System），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FvGIPG_hOvJCUExi4KIVSAVvzHYd.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FvGIPG_hOvJCUExi4KIVSAVvzHYd.png"  lazyload></a></p>
<p>微内核架构常用在桌面应用（例子：Eclipse）和Web应用（例子：Tomcat）中，它的缺陷在于其假设模块之间是互不通信的，但在实际系统中模块之间的交互很常见。我以前碰到过一个系统，它的两个模块以war包形式部署在同一个tomcat容器中，互相之间通信只能通过HTTP调用，虽然走的是本机lo但性能还是不够理想，最终还是将其合到同一个war包中。</p>
<p>模块之间的互相通信，一种常见的实现方案是import - export机制。一个模块可以显式地声明自己导出的功能（export）和需要依赖的其他模块的功能（import），由内核作为中间人负责管理。在后面的对比章节里可以看到，很多方案都采用了这套机制。不过在互相间依赖比较多的时候，这种 import -export 关系很容易变成一团乱麻。</p>
<p>这时候可以借鉴事件驱动架构的思想，内核提供消息队列（Event Channel）的能力，每个模块按需订阅和处理自己感兴趣的事件，并发布新的事件到队列里。更进一步，可以支持 Request - Reply 模式来用消息实现同步调用。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtSa3XQCG6jJK_xHYIJO9_i42m9T.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtSa3XQCG6jJK_xHYIJO9_i42m9T.png"  lazyload></a></p>
<p>一般来说，我们不能简单地说某某架构就是比某某架构要好，每一种架构的选择都是在给定的背景下做出的。譬如说，TMF作为中台的产物，就很适合交易这种共享一套内核，不同业务在不同分支点扩展自定义逻辑的架构，但如果接入的业务方不多（比如说，少于10个？），又要求足够轻量足够快速迭代的场景，TMF是否一定适合呢？</p>
<p>如果给定语境，模块化是个折中的好方案：</p>
<ol>
<li>模块化本身就是一个特殊的单体架构，因此继承了所有单体架构的优点。</li>
<li>拥有微服务架构的很多优点，但大大降低了复杂度，当然<strong>前提</strong>是合理规划好模块的边界，定义好模块间通信的机制。</li>
</ol>
<p>模块化相比微服务不太好解决的主要是两个问题。</p>
<ol>
<li>隔离问题。模块化同样可以实现一定程度上的隔离，这取决于隔离的粒度。以资源的隔离为例，模块化肯定做不到微服务的隔离级别，但像是租户维度的资源隔离能力也可以在ajdk中找到。</li>
<li>独立水平扩展问题。模块化单体并不是不能扩展（比如，可以通过只在一个容器中部署特定的模块集合的方式扩展），只是扩展的资源利用率不同。当你的应用只是需要拆分边界，提升开发和维护效率时，模块完全可以替代微服务。而当你的模块数量上升，各个模块的业务压力不均匀，集群体量越来越大，业务的上线频度越来越不同的时候，你才需要转向微服务。</li>
</ol>
<p>为了实现良好的模块化系统，避免陷入传统单体的问题，我们需要确保：</p>
<ol>
<li>模块必须是独立（包括：开发、部署、运行等）且可插拔的。</li>
<li>每个模块需要清晰地定义其对外提供的服务和依赖的服务。</li>
</ol>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>之前对比了集团内部和外部的模块化框架，在这里简单列一下作为参考，对比时选取了“3个隔离”的标准。</p>
<table>
<thead>
<tr>
<th>3个隔离</th>
<th>问题</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>开发态隔离</td>
<td>混杂的业务团队开发同一套代码，不同业务功能代码耦合在一起</td>
<td>不同业务在各自的git仓库上独立开发，互不影响。核心只提供宿主容器能力+通用能力</td>
</tr>
<tr>
<td>运行态：类隔离</td>
<td>不同业务功能的类由同一个ClassLoader加载，存在包依赖冲突，例如不同二方包引入不同版本Netty导致的依赖冲突问题</td>
<td>不同模块的类由不同的<code>ClassLoader</code></td>
</tr>
<tr>
<td>加载，进一步，模块将自身和依赖打包成FatJar，完全杜绝包依赖冲突</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运行态：实例隔离</td>
<td>以Spring程序为例，不同业务功能共享同一个Spring上下文，一个Bean的初始化失败导致整个应用不可用</td>
<td>每个业务拥有独立的Spring上下文，Spring Bean实例隔离，启动运行互不影响</td>
</tr>
<tr>
<td>运行态：资源隔离</td>
<td>单个业务的恶性bug（死循环等）耗尽整个系统的资源</td>
<td>为每个业务规划合理的资源限制，譬如以租户为单位运行</td>
</tr>
<tr>
<td>发布运维隔离</td>
<td>由于所有业务模块与宿主应用在同一个容器中，发布和运维都基于宿主应用，无法隔离。</td>
<td>业务可以基于自己节奏做热发布，模块粒度的管控运维能力</td>
</tr>
</tbody></table>
<h3 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h3><p>OSGi是Java模块化的始祖，有很强的模块化、动态化能力，但需要遵循OSGi规范开发，复杂度较高。</p>
<p>总体来说不推荐，首先考虑选择轻量化的框架。从经验上讲，之前也参与过开发过OSGI系统，基于Bundle的开发模式确实过于复杂，学习成本很高；OSGi在阿里内部的落地从历史上看也是失败的（参考毕玄：我在系统设计上犯过的14个错）。</p>
<h3 id="JPMS"><a href="#JPMS" class="headerlink" title="JPMS"></a>JPMS</h3><p>Java 9 中的模块是代码和数据的封装体，同时包含了需要导入的其他模块和需要导出的包列表等，在开发时，需要指定模块之间的依赖靠关系，可以exports给那些模块用，需要使用那些模块(requires)。</p>
<ol>
<li>不管是什么规模的Java应用，都需要依赖一个完整的JRE，在云时代格格不入；</li>
<li>Jar-Hell问题；</li>
<li>无法表达依赖；</li>
</ol>
<p>本质上Java 9的模块<a target="_blank" rel="noopener" href="https://developer.ibm.com/tutorials/java-modularity-1/">能解决的问题</a>有限，只是对代码结构做了静态模块化，并不支持热插拔等动态能力。</p>
<h3 id="Pandora"><a href="#Pandora" class="headerlink" title="Pandora"></a>Pandora</h3><p>Pandora是阿里内部的模块化框架，思想和设计上都很有启发性，大家都很熟悉了（之前还写过一篇剖析的文章：Pandora的设计与实现）。不过主要还是给中间件模块用的，没办法直接拿来用做应用层的隔离，要求将模块打成sar包形式的plugin运行在Pandora容器内，插件的开发和管理对业务有较大的侵入性。另外，Pandora隔离机制基于预编译的Sar包，需要事先将模块按照指定格式打包成plugin，同时配置导入导出，启动加载顺序等, 模块数目较少时这种方式尚且可行，但可以预见部署实施和运维成本会随着模块数的变大而线性增长。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjAFs2qYBOkQcqd91z1tZQ9ItlEh.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjAFs2qYBOkQcqd91z1tZQ9ItlEh.png"  lazyload></a></p>
<p>在这之上曾经有过一个Pandora Framework，可惜很久不维护了。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmdCG-rjSRE-eTpigWSPlCc5lNct.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmdCG-rjSRE-eTpigWSPlCc5lNct.png"  lazyload></a></p>
<h3 id="星环容器"><a href="#星环容器" class="headerlink" title="星环容器"></a>星环容器</h3><p>星环容器是阿里交易平台星环产品的重要一环，星环容器的环境隔离和热发布能力相比之前的开发模式非常提效（开发过交易二方包的同学肯定对以前的开发模式和发布流程有体会）。<br>限于数据安全，这里就不放出具体的架构了。有兴趣的可以参考下这篇：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/w3ztwqs9q4astbksd0mj">大麦交易融入阿里电商平台之路</a>。</p>
<h3 id="NBF"><a href="#NBF" class="headerlink" title="NBF"></a>NBF</h3><p>NBF模块化的能力主要体现在其服务中心中。这里限于数据安全只给出外网公开的信息。</p>
<p>NBF服务中心的能力包括服务的开发、运维和路由等整套服务化解决方案，帮助开发同学快速实现和发布服务，支持多业务场景服务路由，支持多商家伙伴快速接入。通过弹性扩缩容策略极大节省了机器资源，通过无侵入式服务降级和一键回滚的能力保障服务稳定性</p>
<p>物理架构上，Bundle可以做单独、混合、合并部署，以FAAS化的思路提供服务；逻辑架构上逻辑框架层面将业务快速扩张、开店、店铺运营抽象成标准流程（流程化），流程各节点可通过SPI、Bundle实现个性化定制（多态化）。</p>
<p>NBF的容器架构如下：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnTENMVMC2NwfS-u2PC9a85Mi6NH.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnTENMVMC2NwfS-u2PC9a85Mi6NH.png"  lazyload></a></p>
<p>NBF跟TMF都要求基于一个扩展点&#x2F;SPI多态化的实现，从这点上看TMF和NBF在技术思路很像，都是使用接口思路和流程沉淀，这对于目前的新制造业务来说可能在开发思维上有要求。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FprxWGqJeZ-4Ap-Xe3_CbGu6_X7U.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FprxWGqJeZ-4Ap-Xe3_CbGu6_X7U.png"  lazyload></a></p>
<h3 id="jarslink"><a href="#jarslink" class="headerlink" title="jarslink"></a>jarslink</h3><p>jarslink是蚂蚁微贷团队开源的轻量级模块化开源框架，参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/jarslink">github链接</a>。功能特性和实现思路都和星环容器非常类似。区别在于星环执行模块代码是通过扩展点，而Jarslink是要求把请求转发给模块，先根据模块名查找模块，再根据aciton name查找Action，最后执行Action。</p>
<p>jarslink的几个缺点：</p>
<ul>
<li>功能特性有点简单，只提供了简单的模块管理能力</li>
<li>需要手动指定需要隔离的类包，侵入性很大</li>
<li>同Pandora Framework一样，也处于不维护状态（蚂蚁官方已经统一切换到Sofa-Ark）。不支持一些必要的功能特性，例如注解类型Spring Bean等。需要做二次开发实现</li>
<li>与星环容器一样的一些缺陷，比如jar冲突，对模块依赖的类库没有能力隔离等</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FoKKEeziZq8bCOfd9T_oI61Xc7bn.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FoKKEeziZq8bCOfd9T_oI61Xc7bn.png"  lazyload></a></p>
<h3 id="Sofa-Ark"><a href="#Sofa-Ark" class="headerlink" title="Sofa-Ark"></a>Sofa-Ark</h3><p>Sofa-Ark是SofaBoot框架的类隔离容器，已经开源，具体介绍参考<a target="_blank" rel="noopener" href="https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/">链接</a>。产品能力包括：</p>
<ul>
<li>定义类加载模型，运行时底层插件、业务应用(模块)之间均相互隔离，单一插件和应用(模块)由不同的 ClassLoader 加载，可以有效避免相互之间的包冲突，提升插件和模块功能复用能力；</li>
<li>定义插件开发规范，提供 maven 打包工具，简单快速将多个二方包打包成插件（Ark Plugin，以下简称 Plugin）</li>
<li>定义模块开发规范，提供 maven 打包工具，简单快速将应用打包成模块 (Ark Biz，以下简称 Biz)</li>
<li>针对 Plugin、Biz 提供标准的编程界面，包括服务、事件、扩展点等机制</li>
<li>支持多 Biz 的合并部署，开发阶段将多个 Biz 打包成可执行 Fat Jar，或者运行时使用 API 或配置中心(Zookeeper)动态地安装卸载 Biz</li>
</ul>
<p>由于Sofa-Ark提供了自定义的打包机制，因此相比星环、jarslink等，可以进一步解决依赖包冲突问题，同时也有了动态合并部署能力，可以在运行时通过 API 或者配置中心（Zookeeper）来控制 Biz 的部署和卸载。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpDfQTvfjDZlZ_XyN9va4a5X_gow.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpDfQTvfjDZlZ_XyN9va4a5X_gow.png"  lazyload></a></p>
<p>Sofa-Ark的缺点主要是与集团用的Pandora Boot技术栈有差异，包括中间件管理，打包方式等。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjqvOMDOx_IJ9VyTYiZ3tKIT5XLK.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjqvOMDOx_IJ9VyTYiZ3tKIT5XLK.png"  lazyload></a></p>
<h2 id="开始设计"><a href="#开始设计" class="headerlink" title="开始设计"></a>开始设计</h2><p>说了那么多，Talk is cheap，直接上手吧。</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjP7p-fApEWU3wzfoc15ESLKdqi-.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FjP7p-fApEWU3wzfoc15ESLKdqi-.png"  lazyload></a></p>
<p>包含两大块：</p>
<ol>
<li>运行时容器</li>
</ol>
<ul>
<li>基础设施（Infrastructure） <ul>
<li>ModuleManager：基础的模块管理能力 <ul>
<li>Fetch：从OSS或Maven仓库，模块的管理第一期可以通过Diamond配置解决</li>
<li>Parse：解析模块Jar构建静态上下文</li>
<li>Start：模块初始化、加载、启动，构建动态上下文，包括独立的ModuleClassLoader和SpringContext</li>
<li>Stop：模块停止</li>
<li>Update：模块升级，支持灰度</li>
<li>Unload：模块卸载</li>
</ul>
</li>
<li>HttpAgent：接收外部命令，来对模块进行动态管理，例如后面与Aone打通热发布就通过HttpAgent下发命令</li>
<li>Monitor：模块的监控</li>
</ul>
</li>
<li>模块（Modules） <ul>
<li>CommonSharable：通用可共享的模块，对应通用且不需要隔离的组件，这类模块一般做静态引入</li>
<li>CommonIsolation：通用并隔离的模块，与CommonSharable的区别是会做模块间隔离</li>
<li>Biz：业务模块，默认是不通用且隔离</li>
</ul>
</li>
</ul>
<ol start="2">
<li>支撑能力</li>
</ol>
<ul>
<li>Module Market：模块市场，提供模块可视化管理，例如看有哪些模块，模块被哪些应用引用，模块间的依赖关系等</li>
<li>Maven Plugin：将模块源码打包成符合格式的FatJar</li>
<li>Aone HotDeploy：对接Aone实现热发布能力</li>
<li>Idea Plugin：支持本地开发、调试、快速生成模块代码的插件和工具</li>
</ul>
<h3 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h3><p>如果按功能来划分，模块可以分为更上层的业务模块（Biz）和底层的通用模块（Common），也可以按照隔离性划分两类模块：</p>
<ol>
<li>非隔离模块</li>
</ol>
<ul>
<li>运行态不隔离，使用双亲委派机制加载 </li>
<li>在maven pom中直接引入 </li>
<li>一般是通用共享模块</li>
</ul>
<ol start="2">
<li>隔离模块</li>
</ol>
<ul>
<li>运行态隔离，使用单独的ClassLoader加载机制 </li>
<li>打包成fatjar引入 </li>
<li>一般是业务模块</li>
</ul>
<p>每个模块里有一个<strong>rmf-module.properties</strong>的模块定义文件，放在resource目录下，用于描述模块的一些元信息，包括模块名，模块版本，模块描述等等，容器启动时，基于这些信息进行模块的解析和初始化。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.name=example-echo</span><br><span class="line">module.version=1.0.0-SNAPSHOT</span><br><span class="line">module.desc=echo example</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">支持Spring Bean的自动扫描</span></span><br><span class="line">module.spring-scan-base=com.alibaba.rhino.example</span><br></pre></td></tr></table></figure>

<p>这里多说一句，传统的实现，像是Sofa-Ark等模块间的依赖是通过上面说的 import-export 机制实现的，但为了避免模块之间出现错综复杂的耦合关系，可以借鉴jarslink，定义一个统一的模块服务<code>ModuleService</code>接口，一个模块只能暴露<code>ModuleService</code>给其他模块调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ModuleService</span>&lt;REQUEST, RESPONSE&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> actionRequest 请求对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RESPONSE <span class="title function_">execute</span><span class="params">(REQUEST actionRequest)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打包机制"><a href="#打包机制" class="headerlink" title="打包机制"></a>打包机制</h3><p>隔离模块支持加载同个GAV的jar包的不同版本，这就要求将模块打包成fatjar，并在容器运行时使用专门的ClassLoader加载，配套的需要有maven打包工具，因此还需要一个maven插件<code>rmf-fat-jar-maven-plugin</code>。</p>
<p>打包后的模块结构示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.alibaba.rhino.rmf</span><br><span class="line">│           └── example-remote</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">├── __fat__jar__</span><br><span class="line">├── com</span><br><span class="line">│   └── alibaba</span><br><span class="line">│       └── rhino</span><br><span class="line">│           └── example</span><br><span class="line">│               ├── ActionResponse.class</span><br><span class="line">│               └── RemoteTestModuleService.class</span><br><span class="line">├── example-remote-1.0.0-SNAPSHOT.rmf.module.jar</span><br><span class="line">├── lib</span><br><span class="line">│   ├── aligreen-service-1.0-SNAPSHOT.jar</span><br><span class="line">│   ├── commons-lang3-3.9.jar</span><br><span class="line">│   ├── jul-to-slf4j-1.7.26.jar</span><br><span class="line">│   ├── log4j-over-slf4j-1.7.26.jar</span><br><span class="line">│   ├── logback-classic-1.1.11.jar</span><br><span class="line">│   ├── logback-core-1.1.11.jar</span><br><span class="line">│   ├── lombok-1.16.22.jar</span><br><span class="line">│   ├── spring-aop-4.3.25.RELEASE.jar</span><br><span class="line">│   ├── spring-beans-4.3.25.RELEASE.jar</span><br><span class="line">│   ├── spring-boot-1.5.22.RELEASE.jar</span><br><span class="line">└── rmf-module.properties</span><br></pre></td></tr></table></figure>

<p>除了常见的jar包中的文件外，打包后的fatjar有一些特殊的文件，包括：</p>
<ul>
<li>_<strong>fat</strong>jar___：标识文件，标识这是个fatjar，在容器加载时会使用设置其ModuleClassLoader为隔离类型的IsolationModuleClassLoader。</li>
<li>_rmf-module.properties_：模块定义文件</li>
<li>_lib&#x2F;_：所有依赖的jar包</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h3><p>容器启动时会自动加载并启动所有的模块，加载的逻辑大致如下：</p>
<p>第一步，先从不同的<code>ModulePathRepository</code>中加载所有的模块路径<code>ModulePath</code>，默认支持的Repository有：</p>
<ul>
<li><code>ClassPathModulePathRepository</code>：从ClassPath下加载模块，逻辑上就是查询ClassPath下有哪些jar包包含了模块定义文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathModulePathRepository</span> <span class="keyword">implements</span> <span class="title class_">ModulePathRepository</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">			 <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ModulePath&gt; <span class="title function_">listModulePaths</span><span class="params">()</span> &#123;</span><br><span class="line">        URL[] resources = ResourceUtils.getResources(ModulePropConstants.RMF_MODULE_PROP_FILE);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(resources)</span><br><span class="line">            .map(url -&gt; ModulePath.ofPropertiesFileUrl(ModuleSourceEnum.CLASSPATH, url))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RemoteNexusModulePathRepository</code>：从远端的Nexus仓库加载模块 </li>
<li><code>RemoteOssModulePathRepository</code>：从远端的OSS加载模块</li>
</ul>
<p>第二步，有了模块的<code>ModulePath</code>后，就可以开始解析模块了。先由<code>ModuleSpecParser</code>对模块定义进行解析，具体就是读取和解析模块的<code>rmf-module.properties</code>文件，同时也从<code>pom.xml</code>中读取一下jar包的GAV。这一步的输出结果是模块的元信息定义<code>ModuleSpec</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleSpec</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块名，定义在rmf-module.properties中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块版本，定义在rmf-module.properties中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块描述，定义在rmf-module.properties中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * jar包信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JarInfo&gt; jarInfos;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring的scanBase包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String springScanBase;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义属性集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，对每个模块的<code>ModuleSpec</code>，构造<code>ModuleClassLoader</code>，用于加载模块中的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Module <span class="title function_">load</span><span class="params">(ModulePath modulePath)</span> &#123;</span><br><span class="line">    <span class="type">ModuleSpec</span> <span class="variable">moduleSpec</span> <span class="operator">=</span> moduleSpecParser.parse(modulePath);</span><br><span class="line">    <span class="keyword">if</span> (!moduleSpec.isValid()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Invalid module, moduleSpec=&#123;&#125;&quot;</span>, moduleSpec);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造ModuleClassLoader，根据模块的隔离性来build不同的ModuleClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> TCCL.getContextClassLoader();</span><br><span class="line">    <span class="type">ModuleClassLoader</span> <span class="variable">moduleClassLoader</span> <span class="operator">=</span> ModuleClassLoaderFactory.build(modulePath, moduleSpec, parentClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 区分是否spring模块</span></span><br><span class="line">    <span class="keyword">return</span> SpringModule.of(modulePath, moduleSpec, moduleClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载完成后模块还处于不可用状态，容器会自动启动所有已加载的模块。类和<code>ModuleService</code>的导入导出工作都在启动阶段完成，如果模块类型是<code>SpringModule</code>，那么还要为每个模块创建独立的Spring <code>ApplicationContext</code>并初始化。</p>
<p>启动过程，可能会涉及到执行插件内的初始化逻辑，因此，执行过程要基于TCCL切换<code>ThreadContextClassLoader</code>。</p>
<h3 id="模块生命周期管理"><a href="#模块生命周期管理" class="headerlink" title="模块生命周期管理"></a>模块生命周期管理</h3><p>模块的生命周期，是从加载到卸载的状态机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaded -&gt; starting -&gt; started -&gt; stopping -&gt; stopped -&gt; unloading -&gt; unloaded</span><br></pre></td></tr></table></figure>

<p>比较关键的节点是模块的加载、启动、停止和卸载，其中有些细节点值得关注下：</p>
<ol>
<li><p>模块加载时区分是否隔离模块，非隔离模块使用的是<code>NonIsolationModuleClassLoader</code>，在实现上就是个简单的双亲委派的<code>URLClassLoader</code>； </p>
</li>
<li><p>如果模块包含了HSF服务，记得加上这么一句，为每个模块注册一个HSF应用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationModelFactory.initApplication(appName, moduleClassLoader, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

</li>
<li><p>如果模块类型是<code>SpringModule</code>，在启动和停止时需要初始化<code>ApplicationContext</code>，以启动为例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.doStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是Spring类型的Module，创建独立的ApplicationContext</span></span><br><span class="line">    TCCL.switchClassLoader(moduleClassLoader, <span class="built_in">this</span>::initApplicationContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> ApplicationContextFactory.build(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        applicationContext.refresh();</span><br><span class="line">        loadServices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadServices</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ModuleService moduleService : applicationContext.getBeansOfType(ModuleService.class).values()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> moduleService.getName();</span><br><span class="line">        <span class="keyword">if</span> (serviceMap.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ModuleException</span>(<span class="string">&quot;Duplicated service found: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        serviceMap.put(name, moduleService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>卸载模块时一定要清理各种资源，我们都知道JVM对Metaspace的GC条件是很严苛的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清理类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clearClassResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ApplicationModelFactory.removeApplication(moduleClassLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Introspector缓存BeanInfo类来获得更好的性能。卸载时刷新所有Introspector的内部缓存。</span></span><br><span class="line">    Introspector.flushCaches();</span><br><span class="line">    <span class="comment">// 从已经使用给定类加载器加载的缓存中移除所有资源包</span></span><br><span class="line">    ResourceBundle.clearCache(moduleClassLoader);</span><br><span class="line">    <span class="comment">// Clear the introspection cache for the given ClassLoader</span></span><br><span class="line">    CachedIntrospectionResults.clearClassLoader(moduleClassLoader);</span><br><span class="line">    LogFactory.release(moduleClassLoader);</span><br><span class="line"></span><br><span class="line">    moduleClassLoader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类隔离机制"><a href="#类隔离机制" class="headerlink" title="类隔离机制"></a>类隔离机制</h3><p>类隔离机制核心思路是，使用不同的<code>ClassLoader</code>加载可能存在冲突的jar包，由于类型在JVM中的namespace是<code>ClassLoader</code>+<code>Class Qualified Name</code>，因此，通过不同的<code>ClassLoader</code>可以做到相同限定名的<code>Class</code>在同一个应用运行时共存。确保使用不同的<code>ClassLoader</code>加载的核心思路是打破其双亲委派加载机制。</p>
<p>隔离模块和非隔离模块都基于同一个<code>ModuleClassLoader</code>父类，它是一个<code>URLClassLoader</code>，并定义了基础的获取资源方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ModuleClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; ignoreParentResources = ThreadLocal.withInitial(() -&gt; <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ModuleClassLoader</span><span class="params">(URL[] urls)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(urls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ModuleClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(urls, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title function_">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (ignoreParentResources.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> findResources(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.getResources(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> URL <span class="title function_">getResource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> findResource(name);</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.getResource(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIgnoreParentResources</span><span class="params">(<span class="type">boolean</span> ignoreParentResources)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ignoreParentResources.set(ignoreParentResources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非隔离模块使用的<code>ClassLoader</code>非常简单，它直接使用双亲委派机制进行类加载，因此类和类之间并没有隔离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonIsolationModuleClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ModuleClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">NonIsolationModuleClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(urls, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隔离模块的<code>ClassLoader</code>则相对复杂点，它要使用不同的<code>ClassLoader</code>加载不同的类，譬如用Pandora的<code>appClassLoader</code>加载中间件导出的类，用容器自身的<code>rmfClassLoader</code>加载容器的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(className)) &#123;</span><br><span class="line">        <span class="comment">// 1. loaded class</span></span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. jdk class</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadJdkClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. rmf class</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadRmfClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. pandora class</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadPandoraExportClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. container shared class</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadContainerSharedClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 6. imported class</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadImportedClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 7. class path</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = loadClassInClasspath(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终demo"><a href="#最终demo" class="headerlink" title="最终demo"></a>最终demo</h2><p>最后，我用乐高搭了一个小的demo，作为这个学习+实验性质的RMF框架的总结。</p>
<p>demo的说明：</p>
<ol>
<li>默认通过pom.xml引入了两个静态的模块<code>example-http</code>和<code>example-echo</code>，模拟调用其接口。</li>
<li>在控制台上可以操作启动或者停止模块，或者查看模块的jar包详情。</li>
<li>在控制台上可以新增模块，会从指定的OSS路径下载并加载模块<code>example-remote</code>的fatjar，启动后就可以调用其接口。</li>
<li>卸载<code>example-remote</code>模块，更新到1.0.1-SNAPSHOT版本，调用接口查看其差异。</li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/lmEXBo5o1BIC6pxY0TqYuaKt9-g0.gif"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/lmEXBo5o1BIC6pxY0TqYuaKt9-g0.gif"  lazyload></a></p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BC%95%E5%AD%90"><span class="top-box-text">引子</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%9D%E8%80%83"><span class="top-box-text">思考</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8D%95%E4%BD%93-VS-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="top-box-text">单体 VS 微服务</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="top-box-text">模块化？</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AF%B9%E6%AF%94"><span class="top-box-text">对比</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#OSGi"><span class="top-box-text">OSGi</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#JPMS"><span class="top-box-text">JPMS</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Pandora"><span class="top-box-text">Pandora</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%98%9F%E7%8E%AF%E5%AE%B9%E5%99%A8"><span class="top-box-text">星环容器</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#NBF"><span class="top-box-text">NBF</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#jarslink"><span class="top-box-text">jarslink</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Sofa-Ark"><span class="top-box-text">Sofa-Ark</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BC%80%E5%A7%8B%E8%AE%BE%E8%AE%A1"><span class="top-box-text">开始设计</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="top-box-text">架构设计</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89"><span class="top-box-text">模块定义</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%89%93%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="top-box-text">打包机制</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="top-box-text">实现细节</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="top-box-text">容器启动</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A8%A1%E5%9D%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="top-box-text">模块生命周期管理</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6"><span class="top-box-text">类隔离机制</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%9C%80%E7%BB%88demo"><span class="top-box-text">最终demo</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2022/11/14/go-vs-java-vs-kotlin-xie-cheng-shi-li-pk-he-si-kao/">
          <h3 class="post-title">
            下一篇：Go VS Java VS Kotlin：协程示例PK和思考
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>一个Spring事件触发问题的定位过程</title>
<meta name="keywords" content="一个Spring事件触发问题的定位过程, jffu&#39;s blog">
<meta name="description" content="由一个日常的Spring事件触发问题引发的定位过程。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="一个Spring事件触发问题的定位过程">
<meta property="og:description" content="由一个日常的Spring事件触发问题引发的定位过程。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">一个Spring事件触发问题的定位过程</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2019-08-07</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Spring/">
              Spring
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>开发中用到了Spring框架的<code>ApplicationEvent</code>做应用内部事件分发，<code>ApplicationEvent</code>的使用本身很简单，偶尔用起来也没出问题，但这次却碰到一个非常奇怪的问题，有个事件的监听器方法一直收不到消息。</p>
<p>事件监听器的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DingUserEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUserSave</span><span class="params">(DingUserSaveEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUserLeave</span><span class="params">(DingUserLeaveEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发事件的大致逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUserList</span><span class="params">(String corpId, List&lt;DingTalkUserDTO&gt; dingTalkUserList)</span> &#123;</span><br><span class="line">    <span class="comment">// 一些数据库操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送员工保存事件</span></span><br><span class="line">    applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">DingUserSaveEvent</span>(<span class="built_in">this</span>, dingTalkUserList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h1><p>我的定位思路是从发送事件的源代码开始跟踪。</p>
<p>通过跟踪<code>applicationEventPublisher#publishEvent</code>方法，可以看到实际广播事件是通过<code>ApplicationEventMulticaster#multicastEvent</code>方法实现的，而<code>ApplicationEventMulticaster</code>接口的默认实现是<code>SimpleApplicationEventMulticaster</code>，其广播的逻辑简单得不能再简单：找到一组匹配的监听器，挨个调用其<code>onApplicationEvent</code>方法。</p>
<blockquote>
<p>当然Spring在其中做了一定的优化，例如会根据<code>eventType</code>和<code>sourceType</code>做为key缓存对应的监听器列表，加速查找过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;</span><br><span class="line">	<span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">		<span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">		<span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">			executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					invokeListener(listener, event);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			invokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么配置的监听器是否在返回的监听器列表中呢？</p>
<p>下面是我debug中截出来Spring找到的匹配的监听器，在这茫茫多的监听器列表中还是能一眼看出哪几个有可能是的。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkQIaaR_yY5_HVIKTMcd32sJRnjU.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkQIaaR_yY5_HVIKTMcd32sJRnjU.png"  lazyload></a></p>
<p>再跟进去，发现实际上真正的监听器是<code>ApplicationListenerMethodTransactionalAdapter</code>这个类。</p>
<p>这里插入需要说明一下，由于代码里配置<code>ApplicationEvent</code>监听器时并没有采用实现<code>ApplicationEventListener</code>接口的方式，而是用了<code>@TransactionalEventListener</code>（<code>@EventListener</code>同理）注解，所以Spring会生成一个<code>ApplicationListenerMethodTransactionalAdapter</code>来作为适配器处理事件监听。</p>
<p>因此实际上调用的是<code>ApplicationListenerMethodTransactionalAdapter</code>的<code>onApplicationEvent</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">  <span class="comment">// 先判断当前是不是在一个事务中</span></span><br><span class="line">  <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">    <span class="type">TransactionSynchronization</span> <span class="variable">transactionSynchronization</span> <span class="operator">=</span> createTransactionSynchronization(event);</span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再判断是否启用了回退策略</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Processing &quot;</span> + event + <span class="string">&quot; as a fallback execution on AFTER_ROLLBACK phase&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    processEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No transactional event execution at all</span></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;No transaction is active - skipping &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码有两个if判断：</p>
<ol>
<li>当前执行语句在一个事务中；</li>
<li>如果不在事务中，那么需要在注解上配置了回退策略<code>fallbackExecution</code>；</li>
</ol>
<p>debug的时候发现直接走到了else分支，也就是意味着两个条件都没有成立。因为<code>@TransactionalEventListener</code>注解上确实没有配置<code>fallbackExecution</code>，所以问题的原因应该在于条件1：为什么执行的语句没有在事务中？明明入口方法上是加了<code>@Transactional</code>注解。</p>
<p>回过头来看调用堆栈：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftv-cUQk6nvXvYhrvB0pNnzKAndU.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftv-cUQk6nvXvYhrvB0pNnzKAndU.png"  lazyload></a></p>
<p>Spring会为事务注解<code>@Transactional</code>生成一个切面，对应<code>TransactionInterceptor</code>，在调用堆栈里面并没有看到，却有一个<code>LockInterceptor</code>，而之前看的入口方法<code>saveUserList</code>实际是被<code>saveUserListWithLock</code>这个方法调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Lock(key = &quot;&#x27;saveUserListWithLock_&#x27;+#p0+&#x27;_&#x27;+(#p1.get(0).getDingId())&quot;,</span><br><span class="line">    timeUnit = TimeUnit.MILLISECONDS, timeout = DEFAULT_LOCK_TIMEOUT,</span><br><span class="line">    failHandlerFactory = BlockingFailHandlerFactory.class)</span><br><span class="line">public void saveUserListWithLock(String corpId, List&lt;DingTalkUserDTO&gt; dingTalkUserDTOList) &#123;</span><br><span class="line">    saveUserList(corpId, dingTalkUserDTOList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此真相大白，其他同学在原有方法外面套了个<code>saveUserListWithLock</code>方法，上面加了一个<code>@Lock</code>用于实现注解式分布式锁，使得<code>saveUserList</code>调用变成了动态代理对象的内部函数调用，原有的切面就失效了。</p>
<p>修改后，正常的调用堆栈是这样的：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fqg4DBtzSwjMN2l0i-CpMqs32sG2.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fqg4DBtzSwjMN2l0i-CpMqs32sG2.png"  lazyload></a></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="EventListener机制"><a href="#EventListener机制" class="headerlink" title="@EventListener机制"></a><code>@EventListener</code>机制</h2><p>在Spring中，有两种方式声明一个<code>ApplicationEvent</code>事件的监听器：</p>
<ol>
<li>实现<code>ApplicationListener</code>接口，这种方式的缺陷是一个类只能处理一种事件。 <blockquote>
<p>一个例子：</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSpringEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;CustomSpringEvent&gt; &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(CustomSpringEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received spring custom event - &quot;</span> + event.getMessage());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Spring 4.2后增加了<code>@EventListener</code>注解，在一个bean的public方法上加上这个注解会自动生成和注册一个<code>ApplicationListener</code>实例。</li>
</ol>
<p>Spring对<code>@EventListener</code>注解的处理跟很多其他内置注解的处理是一致的，流程大致是：</p>
<ol>
<li><p>使用一个<code>MethodProcessor</code>实现<code>SmartInitializingSingleton</code>。 </p>
<blockquote>
<p><code>SmartInitializingSingleton</code>的作用：当所有单例的Spring Bean创建完成后，Spring会回调<code>SmartInitializingSingleton#afterSingletonsInstantiated</code>方法，可以在其中实现一些特定逻辑，例如对bean进行增强等。</p>
</blockquote>
</li>
<li><p>在<code>MethodProcessor</code>中，取出当前Spring容器中的bean，通过反射遍历其方法列表，查找方法上的特定注解。 </p>
<blockquote>
<p>这里有一个小点，Spring会把当前bean class的父类（包括接口，不包含Object类）的方法也加到方法列表上，所以在接口上声明注解和在实现类上声明效果是一样的（如果冲突，就近原则）。</p>
</blockquote>
</li>
<li><p>针对注解的方法做自定义处理，例如生成切面等，以<code>@EventListener</code>为例，处理逻辑是使用<code>EventListernFactory</code>生成一个对应的<code>ApplicationListener</code>。</p>
</li>
</ol>
<p>源码如下，省掉了非关键路径的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListenerMethodProcessor</span> <span class="keyword">implements</span> <span class="title class_">SmartInitializingSingleton</span>, ApplicationContextAware &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">EventExpressionEvaluator</span> <span class="variable">evaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventExpressionEvaluator</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; nonAnnotatedClasses =</span><br><span class="line">			Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Class&lt;?&gt;, Boolean&gt;(<span class="number">64</span>));</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;EventListenerFactory&gt; factories = getEventListenerFactories();</span><br><span class="line">		String[] beanNames = <span class="built_in">this</span>.applicationContext.getBeanNamesForType(Object.class);</span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ScopedProxyUtils.isScopedTarget(beanName)) &#123;</span><br><span class="line">				Class&lt;?&gt; type = AutoProxyUtils.determineTargetClass(<span class="built_in">this</span>.applicationContext.getBeanFactory(), beanName);</span><br><span class="line">				<span class="keyword">if</span> (type != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 找到容器中的bean并做处理</span></span><br><span class="line">						processBean(factories, beanName, type);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBean</span><span class="params">(<span class="keyword">final</span> List&lt;EventListenerFactory&gt; factories, <span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.nonAnnotatedClasses.contains(targetType)) &#123;</span><br><span class="line">			Map&lt;Method, EventListener&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 找到加了@EventListener注解的方法</span></span><br><span class="line">				annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">						<span class="keyword">new</span> <span class="title class_">MethodIntrospector</span>.MetadataLookup&lt;EventListener&gt;() &#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="keyword">public</span> EventListener <span class="title function_">inspect</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">// 省略...</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line">				<span class="built_in">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Non-empty set of methods</span></span><br><span class="line">				<span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">          <span class="comment">// 使用EventListenerFactory，为符合条件的方法生成并注册applicationListener实例</span></span><br><span class="line">					<span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">						<span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line">							<span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(</span><br><span class="line">									method, <span class="built_in">this</span>.applicationContext.getType(beanName));</span><br><span class="line">							ApplicationListener&lt;?&gt; applicationListener =</span><br><span class="line">									factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">							<span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">								((ApplicationListenerMethodAdapter) applicationListener)</span><br><span class="line">										.init(<span class="built_in">this</span>.applicationContext, <span class="built_in">this</span>.evaluator);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="built_in">this</span>.applicationContext.addApplicationListener(applicationListener);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TransactionalEventListener"><a href="#TransactionalEventListener" class="headerlink" title="TransactionalEventListener"></a><code>TransactionalEventListener</code></h2><p>为了支持事务消息，Spring在<code>@EventListener</code>注解的基础上提供了一个<code>@TransactionalEventListener</code>注解，可以将事件的发送与事务的生命周期绑定，通过注解属性<code>TransactionPhase</code>来控制事件发送的时机。目前支持的几种<code>TransactionPhase</code>：</p>
<ol>
<li><code>AFTER_COMMIT</code>：默认，事务成功提交后发送事件；</li>
<li><code>BEFORE_COMMIT</code>：在事务提交前发送事件；</li>
<li><code>AFTER_ROLLBACK</code>：如果事务回滚，则发送事件；</li>
<li><code>AFTER_COMPLETION</code>：事务完成后发送事件，等同于<code>AFTER_COMMIT</code> | <code>AFTER_ROLLBACK</code>；</li>
</ol>
<blockquote>
<p>默认情况下，如果不在事务中时，一个<code>TransactionalEventListener</code>不会触发事件发送和处理，可以通过配置<code>@TransactionalEventListener</code>注解的<code>fallbackExecution</code>属性为true来启用。</p>
</blockquote>
<p>这里引申出几个问题，首先是当前执行的代码上下文如何能知道是否处于事务中？一种做法是将事务状态作为函数参数传递，但这样对不同模块的代码侵入性较大，因此Spring采用了<code>ThreadLocal</code>机制来保存事务的上下文数据，在开启事务时会进行赋值。参考<code>TransactionSynchronizationManager</code>类的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;Map&lt;Object, Object&gt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;Set&lt;TransactionSynchronization&gt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;String&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;Boolean&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;Integer&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NamedThreadLocal</span>&lt;Boolean&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>第二个问题是如何将事件的发送hook到事务生命周期的不同阶段中？Spring提供了一种事务同步回调机制，允许监听方将事务生命周期回调函数封装到<code>TransactionSynchronization</code>类中，并注册给事务管理器。事务管理器在事务执行到对应阶段时，回调每个<code>TransactionSynchronization</code>的对应方法。</p>
<p>以<code>TransactionalEventListener</code>注册的<code>TransactionSynchronization</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TransactionSynchronizationEventAdapter</span> <span class="keyword">extends</span> <span class="title class_">TransactionSynchronizationAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ApplicationListenerMethodAdapter listener;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ApplicationEvent event;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TransactionPhase phase;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TransactionSynchronizationEventAdapter</span><span class="params">(ApplicationListenerMethodAdapter listener,</span></span><br><span class="line"><span class="params">			ApplicationEvent event, TransactionPhase phase)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.listener = listener;</span><br><span class="line">		<span class="built_in">this</span>.event = event;</span><br><span class="line">		<span class="built_in">this</span>.phase = phase;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.listener.getOrder();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeCommit</span><span class="params">(<span class="type">boolean</span> readOnly)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.BEFORE_COMMIT) &#123;</span><br><span class="line">			processEvent();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_COMMIT &amp;&amp; status == STATUS_COMMITTED) &#123;</span><br><span class="line">			processEvent();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_ROLLBACK &amp;&amp; status == STATUS_ROLLED_BACK) &#123;</span><br><span class="line">			processEvent();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.phase == TransactionPhase.AFTER_COMPLETION) &#123;</span><br><span class="line">			processEvent();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.listener.processEvent(<span class="built_in">this</span>.event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AOP内部调用问题"><a href="#AOP内部调用问题" class="headerlink" title="AOP内部调用问题"></a>AOP内部调用问题</h2><p>AOP内部调用问题是一个老生常谈的问题了，一个动态代理对象的方法在调用自身的方法时，由于调用时this关键字引用的是被代理对象本身，而不是动态代理对象，导致切面的逻辑不会生效。</p>
<p>总结下通用的解法和原理：</p>
<ol>
<li><p>不要使用内部自调用（这也是Spring推荐的做法）； </p>
</li>
<li><p>手动从Spring容器中获取bean并调用。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((A)applicationContext.getBean(<span class="string">&quot;a&quot;</span>)).invokeInner();</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用<code>AopContext</code>机制，将内部调用的写法改为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">a.invokeInner();</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">((A) AopContext.currentProxy()).invokeInner()；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>开启<code>AopContext</code>的方式： </p>
<ul>
<li><p>xml配置方式 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>注解方式 </p>
<blockquote>
<p>启动类上加<code>@EnableAspectJAutoProxy</code>注解，将属性<code>exposeProxy</code>设为true。</p>
</blockquote>
</li>
</ul>
<p>开启后，Spring生成的proxy对象在调用真实对象方法前，会将当前proxy对象设置到<code>AopContext</code>的<code>ThreadLocal</code>中，这样通过<code>AopContext.currentProxy()</code>就能取出proxy对象然后调用增强后的方法了。<br>以CGLib为例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor#intercept</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  Class&lt;?&gt; targetClass = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果开启了exposeProxy，则将当前代理对象保存到AopContext中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">      <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">      oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">      setProxyContext = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// May be null. Get as late as possible to minimize the time we</span></span><br><span class="line">    <span class="comment">// &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">    target = getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">      targetClass = target.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    Object retVal;</span><br><span class="line">    <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">    <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">    <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">      <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">      <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">      <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">      Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">      retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">      retVal = <span class="keyword">new</span> <span class="title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">      releaseTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">      <span class="comment">// 回复AopContext</span></span><br><span class="line">      AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题本身比较简单，定位问题只花了10分钟不到时间，但从定位过程回顾了一遍Spring几个模块的源码，通过这种问题定位的方式温故知新，还是挺有收获的。</p>
<p>回顾一下几个知识点：</p>
<ol>
<li>Spring的事件发送和监听机制；</li>
<li>Spring的事务管理机制；</li>
<li>Spring AOP的实现机制；</li>
</ol>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1"><span class="top-box-text">问题现象</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B"><span class="top-box-text">定位过程</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="top-box-text">源码分析</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#EventListener%E6%9C%BA%E5%88%B6"><span class="top-box-text">@EventListener机制</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#TransactionalEventListener"><span class="top-box-text">TransactionalEventListener</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#AOP%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="top-box-text">AOP内部调用问题</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2019/06/24/Netty%E6%8C%87%E5%8C%97%E7%B3%BB%E5%88%976-ByteBuf/">
          <h3 class="post-title">
            下一篇：Netty指北系列6-ByteBuf
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Netty指北系列5-EventLoop</title>
<meta name="keywords" content="Netty指北系列5-EventLoop, jffu&#39;s blog">
<meta name="description" content="EventLoop是Netty事件驱动处理机制的核心组件。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Netty指北系列5-EventLoop">
<meta property="og:description" content="EventLoop是Netty事件驱动处理机制的核心组件。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Netty指北系列5-EventLoop</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2019-05-21</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Netty-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
              Netty, 网络协议
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p><code>EventLoop</code>是Netty事件驱动处理机制的核心组件，每个<code>EventLoop</code>都拥有一个用于事件调度和<code>Channel</code>上I&#x2F;O操作的线程。常用的<code>EventLoop</code>是<code>NioEventLoop</code>，对应使用NIO的<code>Selector</code>进行I&#x2F;O多路复用的<code>EventLoop</code>。</p>
<p>一个<code>EventLoopGroup</code>包含一到多个<code>EventLoop</code>，管理其生命周期。</p>
<p>理解<code>EventLoop</code>和<code>EventLoopGroup</code>的关键在于理解线程模型。</p>
<p>先看传统BIO线程模型：</p>
<ol>
<li>有一个独立的Acceptor线程监听客户端的连接；</li>
<li>为每个客户端连接创建一个线程处理；</li>
</ol>
<p>特点：</p>
<ol>
<li>基于阻塞型的BIO；</li>
<li>常用一个线程池处理请求，生成响应给客户端；</li>
<li>在高并发时吃掉大量的线程资源，性能差；</li>
</ol>
<p>而与之对应的就是常说的Reactor线程模型：</p>
<ol>
<li>通常有一个专门的NIO线程或者线程组担当<code>Acceptor</code>用于监听客户端连接（Boss）；</li>
<li>有一个I&#x2F;O线程组用于处理I&#x2F;O操作，例如读写数据，编解码等（Worker），；</li>
<li>链路建立后，<code>Acceptor</code>将创建的<code>SocketChannel</code>注册到I&#x2F;O线程组，由I&#x2F;O线程组负责后续的I&#x2F;O操作；</li>
</ol>
<p>特点：</p>
<ol>
<li>基于异步NIO；</li>
<li>通常有两个线程组，Boss和Worker，分别用于接收客户端连接、处理I&#x2F;O操作；</li>
<li>相比BIO模型，一个NIO线程可以处理多条客户端连接链路，一条链路对应一个NIO线程；</li>
</ol>
<p>Reactor的线程配置可以根据实际情况调整，根据线程池配置，Reactor线程可以分为：</p>
<ul>
<li>单线程模型：所有I&#x2F;O操作使用同一个NIO线程，处理客户端连接也使用同一个线程，相当于Boss线程和Worker线程合一；</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FtV7h3H_RTqxtk6SBHUR0EthMVka.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FtV7h3H_RTqxtk6SBHUR0EthMVka.png"  lazyload></a></p>
<ul>
<li>多线程模型：与单线程模型相比，单个NIO线程换成一个NIO线程组，相当于Boss线程组和Worker线程组合一；</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/Fh1NXTQJOr5iCcHUfyC3xCps3PjY.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/Fh1NXTQJOr5iCcHUfyC3xCps3PjY.png"  lazyload></a></p>
<ul>
<li>主从多线程模型：使用独立的Boss线程组和Worker线程组；</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FjvTZL-FoHJNOkDilHcI9pM64Y2A.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FjvTZL-FoHJNOkDilHcI9pM64Y2A.png"  lazyload></a></p>
<h1 id="2-EventLoop"><a href="#2-EventLoop" class="headerlink" title="2 EventLoop"></a>2 <code>EventLoop</code></h1><p><code>EventLoop</code>本质上事件循环，对应的处理逻辑可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!terminated) &#123;</span><br><span class="line">    List&lt;Runnable&gt; readyEvents = blockUntilEventsReady(); <span class="comment">// 阻塞，等待事件</span></span><br><span class="line">    <span class="keyword">for</span> (Runnable ev: readyEvents) &#123; <span class="comment">// 循环处理所有可用事件</span></span><br><span class="line">        ev.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>一个<code>EventLoop</code>在一个线程内处理；</li>
<li>事件的执行顺序按照FIFO，保证数据字节的正确顺序；</li>
<li>根据需要和可用CPU核数，可以使用多个<code>EventLoop</code>来提高性能和资源使用率；</li>
</ol>
<p>Netty的<code>EventLoop</code>，可以简单地理解为在一个线程内进行阻塞等待事件和事件的循环处理，而事件可以是客户端连接事件、I&#x2F;O操作事件等；<br>特点：</p>
<ol>
<li><code>EventLoop</code>在创建后绑定到一个线程，且在其生命周期内不会改变；</li>
<li>一个<code>EventLoop</code>处理的所有I&#x2F;O事件都在<code>EventLoop</code>绑定的线程中处理；</li>
<li>一条链路对应一个<code>Channel</code>，注册到一个<code>EventLoop</code>上，在其生命周期内由一个<code>EventLoop</code>处理；</li>
<li>一个<code>EventLoop</code>可以被绑定给一到多个<code>Channel</code>使用；</li>
</ol>
<p>从<code>EventLoop</code>的接口方法中可以看到，其最重要的方法就是<code>register</code>的几个重载方法，用于将Channel注册到<code>EventLoop</code>上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span>;</span><br><span class="line">ChannelFuture <span class="title function_">register</span><span class="params">(ChannelPromise promise)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-EventLoopGroup"><a href="#3-EventLoopGroup" class="headerlink" title="3 EventLoopGroup"></a>3 <code>EventLoopGroup</code></h1><p>顾名思义，<code>EventLoopGroup</code>包含一到多个<code>EventLoop</code>。从源码中可以看到<code>EventLoop</code>接口实际上是<code>EventLoopGroup</code>接口的子接口，可以视为一种特殊的只有一个<code>EventLoop</code>的<code>EventLoopGroup</code>。</p>
<p><code>EventLoopGroup</code>在初始化时，可以指定线程数。</p>
<p>Netty提供了多种<code>EventLoopGroup</code>的实现，根据线程模型，可以选用的主要有：</p>
<ul>
<li><code>OioEventLoopGroup</code>：继承自<code>ThreadPerChannelEventLoopGroup</code>，BIO模型，一个Channel对应一个线程；</li>
<li><code>NioEventLoopGroup</code>：继承自<code>MultithreadEventLoopGroup</code>，NIO模型，一个线程可以处理多个Channel；</li>
<li><code>DefaultEventLoop</code>：继承自<code>SingleThreadEventLoop</code>，只有一个线程；</li>
<li><code>EpollEventLoopGroup</code>&#x2F;<code>EpollEventLoopGroup</code>等：分别对应Linux Epoll和BSD KQueue的事件驱动底层实现。</li>
</ul>
<p>通过配置<code>EventLoopGroup</code>，可以让Netty实现3种Reactor线程模型：</p>
<ul>
<li>单线程模型：<code>EventLoopGroup</code>只包含一个<code>EventLoop</code>，Boss和Worker使用同一个<code>EventLoopGroup</code>；</li>
<li>多线程模型：<code>EventLoopGroup</code>包含多个<code>EventLoop</code>，Boss和Worker使用同一个<code>EventLoopGroup</code>；</li>
<li>主从多线程模型：<code>EventLoopGroup</code>包含多个<code>EventLoop</code>，Boss和Worker使用不同的<code>EventLoopGroup</code>；</li>
</ul>
<h2 id="Channel注册流程"><a href="#Channel注册流程" class="headerlink" title="Channel注册流程"></a><code>Channel</code>注册流程</h2><p>在客户端连接时，基本流程：</p>
<ol>
<li>创建一个<code>Channel</code>；</li>
<li>从<code>EventLoopGroup</code>中取一个<code>EventLoop</code>（顺序取），将<code>Channel</code>注册到<code>EventLoop</code>；</li>
<li>在<code>Channel</code>的生命周期内，由同一个<code>EventLoop</code>处理所有I&#x2F;O事件；</li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FjCoNHumfNMGnYe49ncIZbwWBoHJ.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FjCoNHumfNMGnYe49ncIZbwWBoHJ.png"  lazyload></a></p>
<h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>以服务端为例，通常使用如下代码初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">b.group(bossGroup, workerGroup);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>服务端配置通常会创建两个<code>NioEventLoopGroup</code>（当然，也可以只创建和使用一个）。它们的职责如下：</p>
<ul>
<li>BossGroup，相当于accepter，接收客户端连接；</li>
<li>WorkerGroup，处理I&#x2F;O操作，或者执行系统Task，定时任务Task等；</li>
</ul>
<h2 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h2><p>由于Netty使用一个<code>EventLoop</code>处理一组<code>Channel</code>上所有的I&#x2F;O操作，如果自定义的某个<code>ChannelHandler</code>需要执行复杂耗时的业务操作，那么有可能会阻塞当前<code>EventLoop</code>使用的线程，在这种情况下，考虑使用一个业务线程组处理，在处理完后切换回I&#x2F;O线程组。</p>
<p>《Netty权威指南》中给出了一些使用的最佳实践：</p>
<blockquote>
<ol>
<li>创建两个<code>NioEventLoopGroup</code>，用于逻辑隔离NIO <code>Accepter</code>和NIO I&#x2F;O线程。</li>
<li>尽量不要在<code>ChannelHandler</code>中启动用户线程（解码后用于将POJO消息派发到后端业务线程的除外）。</li>
<li>解码要放在NIO线程调用的解码Handler中进行，不要切换到用户线程中完成消息的解码。</li>
<li>如果业务逻辑操作非常简单，没有复杂的业务逻辑计算，没有可能会导致线程被阻塞的磁盘操作、数据库操作、网络操作等，可以直接在NIO线程上完成业务逻辑编排，不需要切换到用户线程。</li>
<li>如果业务逻辑处理复杂，不要在NIO线程上完成，建议将解码后的POJO消息封装成Task，派发到业务线程池中由业务线程执行，以保证NIO线程尽快被释放，处理其他的I&#x2F;O操作。<br>推荐的线程数量计算公式：<br>公式一： 线程数量 &#x3D; （线程总时间&#x2F;瓶颈资源时间） * 瓶颈资源的线程并行数；<br>公式二： QPS &#x3D; 1000&#x2F;线程总时间*线程数</li>
</ol>
</blockquote>
<h1 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5 源码分析"></a>5 源码分析</h1><h2 id="核心类结构"><a href="#核心类结构" class="headerlink" title="核心类结构"></a>核心类结构</h2><p>Netty的<code>EventLoop</code>类族谱比较庞大，这里只看最常用的<code>NioEventLoop</code>和<code>NioEventLoopGroup</code>：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FvC_n3F9DoVCYcy8ElhHtQmDR323.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FvC_n3F9DoVCYcy8ElhHtQmDR323.png"  lazyload></a></p>
<ul>
<li><p>顶层的<code>**Executor**</code><strong>、</strong><code>**ExecutorService**</code><strong>、</strong><code>**SheduledExecutorService**</code>接口，说明<code>EventLoop</code>和<code>EventLoopGroup</code>可以看作是能够执行定时任务的线程池； </p>
</li>
<li><p>最左侧的<code>**NioEventLoop**</code><strong>继承链</strong>，代表<code>NioEventLoop</code>是一个单线程的事件处理器（<code>SingleThread</code>、<code>EventExecutor</code>），链上的类定义了一系列执行任务相关的方法； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop --&gt; SingleThreadEventLoop --&gt; SingleThreadEventExecutor --&gt;</span><br><span class="line">AbstractScheduledEventExecutor --&gt; AbstractScheduledEventExecutor --&gt; </span><br><span class="line">AbstractEventExecutor --&gt; AbstractExecutorService</span><br></pre></td></tr></table></figure>

</li>
<li><p>对应的，右侧的<code>**NioEventLoopGroup**</code><strong>继承链</strong>，首先<code>NioEventLoopGroup</code>是容器（Group），其次它支持多线程事件处理器（<code>Multithread</code>、<code>EventExecutor</code>）的管理； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup --&gt; MultithreadEventLoopGroup --&gt; </span><br><span class="line">MultithreadEventExecutorGroup --&gt; AbstractEventExecutorGroup --&gt;</span><br><span class="line">EventExecutorGroup</span><br></pre></td></tr></table></figure>

</li>
<li><p>中间的部分，一部分是<code>EventLoop</code>和<code>EventLoopGroup</code>继承链的公共接口，主要定义了注册<code>Channel</code>的方法，一部分是独立接口； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共接口</span></span><br><span class="line">EventLoopGroup --&gt; EventExecutorGroup</span><br><span class="line"><span class="comment">// 独立接口</span></span><br><span class="line">EventLoop --&gt; OrderedEventExecutor --&gt; EventExecutor</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="中间的线：EventLoopGroup、EventLoop"><a href="#中间的线：EventLoopGroup、EventLoop" class="headerlink" title="中间的线：EventLoopGroup、EventLoop"></a>中间的线：<code>EventLoopGroup</code>、<code>EventLoop</code></h2><ul>
<li><code>EventLoop</code>：循环处理事件，相对于父接口<code>EventExecutor</code>，提供<code>Channel</code>注册能力，注册后，这个<code>Channel</code>的所有I&#x2F;O在对应的<code>EventLoop</code>内处理；</li>
<li><code>EventLoopGroup</code>：管理一组<code>EventLoop</code>；</li>
</ul>
<h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a><code>EventLoopGroup</code></h4><p><code>EventLoopGroup</code>接口继承<code>EventExecutorGroup</code>，新增了<code>Channel</code>注册功能，对应<code>register</code>的几个重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Channel注册到EventLoopGroup里的某个EventLoop上</span></span><br><span class="line">ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span>;</span><br><span class="line">ChannelFuture <span class="title function_">register</span><span class="params">(ChannelPromise promise)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a><code>EventLoop</code></h3><p><code>EventLoop</code>和<code>EventLoopGroup</code>的关系类似于<code>EventExecutor</code>和<code>EventExecutorGroup</code>的关系。</p>
<ul>
<li><code>EventLoop</code>继承自<code>EventLoopGroup</code>，是一种特殊的只包含一个线程的<code>EventLoopGroup</code>；</li>
<li><code>next</code>方法调用行为： <ul>
<li><code>EventLoopGroup</code>上调用返回其管理的一个<code>EventLoop</code>对象；</li>
<li><code>EventLoop</code>上调用会返回自身；</li>
</ul>
</li>
<li><code>EventLoop</code>的<code>parent</code>方法（继承自<code>EventExecutor</code>接口）会返回<code>EventLoopGroup</code>对象；</li>
</ul>
<h2 id="右边的线：EventExecutorGroup和子类"><a href="#右边的线：EventExecutorGroup和子类" class="headerlink" title="右边的线：EventExecutorGroup和子类"></a>右边的线：<code>EventExecutorGroup</code>和子类</h2><p>从这开始由上往下分析关键类的源码。</p>
<h3 id="EventExecutorGroup接口"><a href="#EventExecutorGroup接口" class="headerlink" title="EventExecutorGroup接口"></a><code>EventExecutorGroup</code>接口</h3><p>从类图中可以看到，<code>EventExecutorGroup</code>处于中间关键的位置，代表了一组事件处理器<code>EventExecutor</code>。</p>
<ul>
<li><p>父接口<code>Executor</code>、<code>ExecutorService</code>、<code>SheduledExecutorService</code>来自Java Executor框架。 </p>
<blockquote>
<p>回顾一下，<code>Executor</code>、<code>ExecutorService</code>提供提交和执行异步任务的能力；而<code>SheduledExecutorService</code>额外定义了定时任务执行的方法，支持按固定频率（FixedRate）、固定延时（FixedDelay）等形式执行定时任务。</p>
</blockquote>
</li>
<li><p><code>EventExecutorGroup</code>包含一到多个<code>EventExecutor</code>，可以调用<code>next</code>方法从中获取一个<code>EventExecutor</code>。常用的优雅退出方法<code>shutdownGracefully</code>也在此定义。</p>
</li>
</ul>
<p>一些主要方法定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isShuttingDown</span><span class="params">()</span>;</span><br><span class="line">Future&lt;?&gt; shutdownGracefully();</span><br><span class="line">Future&lt;?&gt; shutdownGracefully(<span class="type">long</span> quietPeriod, <span class="type">long</span> timeout, TimeUnit unit);</span><br><span class="line">Future&lt;?&gt; terminationFuture();</span><br><span class="line">EventExecutor <span class="title function_">next</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>另外，<code>EventExecutorGroup</code>接口覆盖了父接口的一些方法，更改了其返回值为Netty的<code>io.netty.util.concurrent</code>包下定义的<code>Future</code>和<code>ScheduledFuture</code>。因为JDK原生的<code>Future</code>用途比较局限，<code>io.netty.util.concurrent.Future</code>做了扩展，例如增加了完成后回调能力。</p>
<h3 id="AbstractEventExecutorGroup"><a href="#AbstractEventExecutorGroup" class="headerlink" title="AbstractEventExecutorGroup"></a><code>AbstractEventExecutorGroup</code></h3><p><code>EventExecutorGroup</code>的基础抽象类，实现提交任务相关的方法，<code>submit</code>&#x2F;<code>schedule</code>&#x2F;<code>invokeAll</code>等。</p>
<p><code>EventExecutorGroup</code>只负责任务的分发，具体任务交给其管理的一个<code>EventExecutor</code>去执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> next().submit(task);	<span class="comment">// 调用next()获得一个EventExecutor，交由EventExecutor执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MultithreadEventExecutorGroup"><a href="#MultithreadEventExecutorGroup" class="headerlink" title="MultithreadEventExecutorGroup"></a><code>MultithreadEventExecutorGroup</code></h3><p>相比父类<code>AbstractEventExecutorGroup</code>，<code>MultithreadEventExecutorGroup</code>提供了使用多个线程进行事件任务处理的具体实现。重点来看下。</p>
<p><strong>关键变量</strong></p>
<p>变量都是final类型，因此在构造函数内初始化完成后不可更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个group的全部EventExecutor数组，固定长度，初始化后不可更改。一个EventExecutor对应一个线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line"><span class="comment">// children数组的一个只读的EventExecutor集合，通过迭代器iterator对外暴露，不允许修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;EventExecutor&gt; readonlyChildren;</span><br><span class="line"><span class="comment">// 已经成功终止的executor个数，使用线程安全类AtomicInteger</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">terminatedChildren</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 终止EventExecutorGroup时的异步结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line"><span class="comment">// 选择器，用于确定如何从group中获得一个EventExecutor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br></pre></td></tr></table></figure>

<p><strong>关键方法1：构造函数</strong></p>
<p>大体流程：</p>
<ol>
<li>使用<code>newChild()</code>生成指定线程数的<code>EventExecutor</code>对象，如果创建失败，关闭所有已创建的对象；</li>
<li>从选择器工厂<code>chooserFactory</code>生成选择器对象<code>chooser</code>；</li>
<li>给每个创建出来的<code>EventExecutor</code>，注册关闭的回调通知： <ul>
<li>每个<code>EventExecutor</code>关闭完成时，终止数目terminatedChildren +1；</li>
<li>所有<code>EventExecutor</code>关闭完成时，terminatedChildren等于<code>EventExecutor</code>数目，设置异步结果terminationFuture；</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultithreadEventExecutorGroup构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads          用到的线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor          Executor对象，如为null，使用默认的ThreadPerTaskExecutor（每个任务新建一个线程，不推荐）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chooserFactory    EventExecutorChooserFactory对象，用于生成EventExecutorChooser选择器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args              可变参数，传递给newChild(Executor, Object...)调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line">	<span class="comment">// ...省略，参数检查和默认值设置</span></span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;	<span class="comment">// EventExecutor是否创建成功的标记位</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.1 使用newChild()生成EventExecutor对象，newChild()由子类实现</span></span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 如果没有创建成功，需要关闭所有已创建的EventExecutor</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="comment">// 调用EventExecutor的调用shutdownGracefully()方法优雅退出</span></span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">			   <span class="comment">// 调用关闭方法后，还要等待所有已创建的EventExecutor退出（shutdownGracefully不会阻塞）</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    <span class="type">EventExecutor</span> <span class="variable">e</span> <span class="operator">=</span> children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成选择器，用于next()方法</span></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 给每个executor注册终止时的回调监听器，全部关闭完成后设置异步结果</span></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键方法2：next()</strong></p>
<p>从<code>EventLoopGroup</code>中选择一个<code>EventLoop</code>是Netty中非常常用的操作。<code>MultithreadEventExecutorGroup#next</code>方法使用一个<code>EventExecutorChooser</code>对象来确定怎么从Group中取出一个<code>EventExecutor</code>。因此可以通过实现<code>EventExecutorChooser</code>来灵活使用不同的选取策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventExecutorChooser</code>由<code>EventExecutorChooserFactory</code>工厂类提供。Netty提供默认的工厂类<code>DefaultEventExecutorChooserFactory</code>，默认的选取策略是从<code>EventExecutor</code>数组中顺序选择当前已选的下一个。根据数组长度是否为2的幂，提供两种<code>EventExecutorChooser</code>。<strong>因为</strong><code>**next()**</code><strong>方法被调用的频率很高，因此数组长度一般指定为2的幂，可以提升性能。</strong></p>
<ul>
<li><p><code>PowerOfTwoEventExecutorChooser</code>：线程数等于2的幂次时时使用，使用位操作优化性能 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>GenericEventExecutorChooser</code>：线程数不为2的幂次时使用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MultithreadEventLoopGroup"><a href="#MultithreadEventLoopGroup" class="headerlink" title="MultithreadEventLoopGroup"></a><code>MultithreadEventLoopGroup</code></h3><p><code>MultithreadEventLoopGroup</code>两个功能：</p>
<ul>
<li>继承<code>MultithreadEventExecutorGroup</code>，提供一些默认参数的构造方法，例如默认线程数、默认线程工厂； <ul>
<li>可以使用系统参数<code>io.netty.eventLoopThreads</code> 指定线程数，默认为CPU核数的2倍（核数为2的幂次时启用<code>PowerOfTwoEventExecutorChoose</code>r选择器）；</li>
<li>默认线程工厂类<code>DefaultThreadFactory</code>，给线程设置有意义的名称；</li>
</ul>
</li>
<li>实现<code>EventLoopGroup</code>，提供<code>register()</code>方法的实现 - 从group中选取一个<code>EventLoop</code>执行register操作；</li>
</ul>
<h3 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a><code>NioEventLoopGroup</code></h3><p><code>NioEventLoopGroup</code>位于继承链最底层，提供基于NIO Selector的<code>MultithreadEventLoopGroup</code>实现。关键的方法实现是<code>newChild</code>，在构造<code>EventLoopGroup</code>时，会调用<code>newChild</code>创建每一个<code>NioEventLoop</code>。可以参考<code>MultithreadEventExecutorGroup</code>的构造函数。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置NioEventLoop执行IO任务的比例，参考NioEventLoop实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIoRatio</span><span class="params">(<span class="type">int</span> ioRatio)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: <span class="built_in">this</span>) &#123;</span><br><span class="line">        ((NioEventLoop) e).setIoRatio(ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重建Selector，用于解决epoll 100% CPU的bug，参考NioEventLoop实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebuildSelectors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: <span class="built_in">this</span>) &#123;</span><br><span class="line">        ((NioEventLoop) e).rebuildSelector();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建NioEventLoop，在初始化时会被调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">                            ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左边的线：EventExecutor"><a href="#左边的线：EventExecutor" class="headerlink" title="左边的线：EventExecutor"></a>左边的线：<code>EventExecutor</code></h2><h3 id="EventExecutor接口"><a href="#EventExecutor接口" class="headerlink" title="EventExecutor接口"></a><code>EventExecutor</code>接口</h3><p><code>EventExecutor</code>接口是特殊的<code>EventExecutorGroup</code>（group中只有一个<code>EventExecutor</code>），定义了主要的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回自身的引用</span></span><br><span class="line">EventExecutor <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 返回EventExecutorGroup的引用</span></span><br><span class="line">EventExecutorGroup <span class="title function_">parent</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断当前或者指定线程是否在EventLoop里面内执行</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inEventLoop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inEventLoop</span><span class="params">(Thread thread)</span>;</span><br></pre></td></tr></table></figure>

<p><code>inEventLoop</code>方法在Netty源码中非常常见，Netty使用<code>inEventLoop</code>判断一个线程是否在<code>EventLoop</code>内，保证对一个<code>Channel</code>的操作都在<code>Channel</code>绑定的<code>EventLoop</code>内执行，从而做到线程安全。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor(); <span class="comment">// 从Channel或者其组件中获取EventLoop对象</span></span><br><span class="line"><span class="comment">// 如果当前线程在EventLoop内，那么使用当前线程执行I/O操作</span></span><br><span class="line"><span class="comment">// 否则，创建一个异步任务，交由EventLoop的线程去执行</span></span><br><span class="line"><span class="keyword">if</span> (executor.inEventLoop()) &#123; </span><br><span class="line">    next.invokeChannelActive();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            next.invokeChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractEventExecutor"><a href="#AbstractEventExecutor" class="headerlink" title="AbstractEventExecutor"></a><code>AbstractEventExecutor</code></h3><p><code>AbstractEventExecutor</code>实现了<code>EventExecutor</code>的几个重要方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventExecutor的parent是EventExecutorGroup，在构造时传入</span></span><br><span class="line"><span class="keyword">public</span> EventExecutorGroup <span class="title function_">parent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parent;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventExecutor是只包含一个EventExecutor的EventExecutorGroup，所以next()返回自身引用</span></span><br><span class="line"><span class="keyword">public</span> EventExecutor <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体判断逻辑在子类SingleThreadEventExecutor里实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inEventLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> inEventLoop(Thread.currentThread());	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractScheduledEventExecutor"><a href="#AbstractScheduledEventExecutor" class="headerlink" title="AbstractScheduledEventExecutor"></a><code>AbstractScheduledEventExecutor</code></h3><p><code>AbstractScheduledEventExecutor</code>顾名思义，进一步实现了以shedule开头的定时任务相关的功能方法。基本流程如下：</p>
<ol>
<li><p>使用一个优先队列<code>scheduledTaskQueue</code>保存定时任务，优先队列的实现类为<code>DefaultPriorityQueue</code>，优先级排序规则是自然排序； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PriorityQueue使用自然排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;ScheduledFutureTask&lt;?&gt;&gt; SCHEDULED_FUTURE_TASK_COMPARATOR =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ScheduledFutureTask&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ScheduledFutureTask&lt;?&gt; o1, ScheduledFutureTask&lt;?&gt; o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存定时任务的优先队列</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从scheduledTaskQueue()获取PriorityQueue会进行延迟初始化</span></span><br><span class="line"><span class="comment">// 这里并不是线程安全的单例初始化，但Netty会保证在同一个EventLoop线程里调用这个方法</span></span><br><span class="line">PriorityQueue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduledTaskQueue == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduledTaskQueue = <span class="keyword">new</span> <span class="title class_">DefaultPriorityQueue</span>&lt;ScheduledFutureTask&lt;?&gt;&gt;(</span><br><span class="line">            SCHEDULED_FUTURE_TASK_COMPARATOR,</span><br><span class="line">            <span class="comment">// Use same initial capacity as java.util.PriorityQueue</span></span><br><span class="line">            <span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scheduledTaskQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>调用<code>schedule()</code>、<code>scheduleAtFixedRate()</code>、<code>scheduleWithFixedDelay()</code>等方法添加定时任务时，会将任务封装成一个<code>ScheduledFutureTask</code>对象； </p>
</li>
<li><p>将<code>ScheduledFutureTask</code>添加到队列当中： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里保证只在EventLoop绑定的线程上调用scheduledTaskQueue()方法，避免初始化两个Queue</span></span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) &#123;</span><br><span class="line">        scheduledTaskQueue().add(task);	<span class="comment">// 将task添加到scheduledTaskQueue中就完成了任务添加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a><code>ScheduledFutureTask</code></h3><p><code>ScheduledFutureTask</code>是Netty定时调度任务的关键实现类。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FogH61cNp4iifUHU_4h03T9_nD2m.png"><img   src="/images/loading.svg" data-src="https://raw.githubusercontent.com/jffu/jffu-blog-images/main/img/FogH61cNp4iifUHU_4h03T9_nD2m.png"  lazyload></a><br>从类图上看<code>ScheduledFutureTask</code>：</p>
<ul>
<li>实现了<code>io.netty.util.concurrent.ScheduledFuture</code>，可以表示一个定时任务的异步结果； <ul>
<li>Netty使用自定义的<code>ScheduledFuture</code>接口替代JDK原生的<code>ScheduledFuture</code>接口，增强能力；</li>
<li><code>ScheduledFuture</code>接口继承了<code>Comparable</code>，<code>ScheduledFutureTask</code>实现了<code>compareTo()</code>方法来根据时间排序；</li>
</ul>
</li>
<li>继承<code>PromiseTask</code>，可以表示一个能执行并返回异步结果的任务（Task）；</li>
<li>实现<code>PriorityQueueNode</code>接口，可以被添加到<code>DefaultPriorityQueue</code>中；</li>
</ul>
<p><code>ScheduledFutureTask</code>实现了<code>compareTo()</code>方法，因此被放到<code>AbstractScheduledEventExecutor</code>的<code>scheduledTaskQueue</code>中时，能够按照指定的规则排序。</p>
<p><strong>排序规则：</strong></p>
<ol>
<li><p>使用一个变量<code>deadlineNanos</code>表示任务执行的截止时间（注意是相对时间，从<code>ScheduledFutureTask</code>类加载时刻算起）； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">START_TIME</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nanoTime</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截止时间计算方法：当前时刻相对于类记载起的相对时间nanoTime() + 延时delay</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">deadlineNanos</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">deadlineNanos</span> <span class="operator">=</span> nanoTime() + delay;</span><br><span class="line">    <span class="keyword">return</span> deadlineNanos &lt; <span class="number">0</span> ? Long.MAX_VALUE : deadlineNanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>给每个新建的任务分配一个任务id，使用原子类<code>AtomicLong</code>生成； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextTaskId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> nextTaskId.getAndIncrement();</span><br></pre></td></tr></table></figure>

</li>
<li><p>如果截止时间不一样，截止时间更近的排在签名； </p>
</li>
<li><p>如果截止时间一样，根据任务id排序，任务id更小的排在前面；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScheduledFutureTask&lt;?&gt; that = (ScheduledFutureTask&lt;?&gt;) o;</span><br><span class="line">    <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> deadlineNanos() - that.deadlineNanos();</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id &lt; that.id) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == that.id) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过结合截止时间和任务id，Netty保证了定时任务执行的正确顺序。</p>
<p><strong>任务执行逻辑：</strong></p>
<ol>
<li>使用一个long类型变量<code>periodNanos</code>表示3种定时任务类型，在<code>AbstractScheduledEventExecutor</code>的不同调度方法内初始化这个值 <ul>
<li>0 - 执行一次</li>
<li>大于0 - 固定频率执行：<code>periodNanos</code>的值表示频率rate，执行完成后，下次执行时间为上一个截止时间加上rate值</li>
<li>小于0 - 固定延时执行：<code>periodNanos</code>的值表示延时delay，执行完成后，下次执行时间为执行完成后的当前时间加上delay值</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0 - no repeat, &gt;0 - repeat at fixed rate, &lt;0 - repeat with fixed delay */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> periodNanos;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">executor</span><span class="params">()</span>.inEventLoop();	<span class="comment">// 保证在EventLoop线程里执行任务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (periodNanos == <span class="number">0</span>) &#123;		<span class="comment">// 任务类型为不重复执行，执行一次就退出</span></span><br><span class="line">            <span class="keyword">if</span> (setUncancellableInternal()) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">result</span> <span class="operator">=</span> task.call();</span><br><span class="line">                setSuccessInternal(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 处理需要重复执行的任务</span></span><br><span class="line">            <span class="keyword">if</span> (!isCancelled()) &#123;	<span class="comment">// 任务在重复执行过程中可能被取消，所以需要进行检查</span></span><br><span class="line">                task.call();</span><br><span class="line">                <span class="keyword">if</span> (!executor().isShutdown()) &#123;	<span class="comment">// 如果executor已经关闭，不需要再执行</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">p</span> <span class="operator">=</span> periodNanos;</span><br><span class="line">                    <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;	<span class="comment">// 固定频率，下次执行的截止时间为当前截止时间加频率值</span></span><br><span class="line">                        deadlineNanos += p;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;		<span class="comment">// 固定延时，下次执行的时间为当前时间加延时值</span></span><br><span class="line">                        deadlineNanos = nanoTime() - p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">                        Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue =</span><br><span class="line">                            ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;</span><br><span class="line">                        <span class="keyword">assert</span> scheduledTaskQueue != <span class="literal">null</span>;</span><br><span class="line">                        scheduledTaskQueue.add(<span class="built_in">this</span>);	<span class="comment">// 再次添加到queue中，供下次取出来执行</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">        setFailureInternal(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SingleThreadEventExecutor"><a href="#SingleThreadEventExecutor" class="headerlink" title="SingleThreadEventExecutor"></a><code>SingleThreadEventExecutor</code></h3><p><code>SingleThreadEventExecutor</code>是一个单线程的<code>Executor</code>实现。从这一级开始，<code>EventLoop</code>开始跟线程开始紧密关联。</p>
<p><code>**Thread**</code><strong>对象和属性</strong></p>
<p><code>SingleThreadEventExecutor</code>表示一个使用单线程来执行全部任务的<code>AbstractScheduledEventExecutor</code>。因此<code>SingleThreadEventExecutor</code>关联了一个<code>Thread</code>对象和其他一些属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;	<span class="comment">// 任务队列，默认为LinkedBlockingQueue，子类可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread thread;		<span class="comment">// 线程对象，每个SingleThreadEventExecutor关联一条线程</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadProperties threadProperties;	<span class="comment">// 线程属性，目前没有用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;	<span class="comment">// executor对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> interrupted;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">threadLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);  <span class="comment">// 信号量，初始为0，在awaitTermination()方法调用时会获取信号量，实现阻塞目的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; shutdownHooks = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Runnable&gt;();  <span class="comment">// 关闭时的钩子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> addTaskWakesUp;	<span class="comment">// 添加任务时是否唤醒线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxPendingTasks;	<span class="comment">// 最大任务数，限制taskQueue的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler rejectedExecutionHandler;  <span class="comment">// 任务队列满时的拒绝策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> lastExecutionTime;  <span class="comment">// 上一次执行时间</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;FieldMayBeFinal&quot;, &quot;unused&quot; &#125;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> ST_NOT_STARTED;  <span class="comment">// 线程状态</span></span><br></pre></td></tr></table></figure>

<p>关联<code>thread</code>对象后，<code>inEventLoop()</code>的实现只需要判断给定线程是否等于<code>Thread</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inEventLoop</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> thread == <span class="built_in">this</span>.thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SingleThreadEventExecutor</code>使用变量<code>state</code>表示关联线程的状态，并定义了一组线程的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_NOT_STARTED</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 未启动，初始状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_STARTED</span> <span class="operator">=</span> <span class="number">2</span>;		<span class="comment">// 启动</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_SHUTTING_DOWN</span> <span class="operator">=</span> <span class="number">3</span>;	<span class="comment">// 关闭中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_SHUTDOWN</span> <span class="operator">=</span> <span class="number">4</span>;		<span class="comment">// 关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ST_TERMINATED</span> <span class="operator">=</span> <span class="number">5</span>;		<span class="comment">// 终止</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicIntegerFieldUpdater</code>来原子更新线程状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;SingleThreadEventExecutor&gt; STATE_UPDATER =</span><br><span class="line">    AtomicIntegerFieldUpdater.newUpdater(SingleThreadEventExecutor.class, <span class="string">&quot;state&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>线程状态迁移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化状态，或者提交任务时启动线程失败       --&gt;     ST_NOT_STARTED</span><br><span class="line">有任务提交                                   --&gt;     ST_STARTED</span><br><span class="line">调用shutdownGracefully()                     --&gt;     ST_SHUTTING_DOWN</span><br><span class="line">调用shutdown()                               --&gt;     ST_SHUTDOWN</span><br><span class="line">线程终止，或者启动出现异常                   --&gt;     ST_TERMINATED</span><br></pre></td></tr></table></figure>

<p>使用int类型表示线程状态的原因是可以通过类似代码判断状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isShuttingDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state &gt;= ST_SHUTTING_DOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程启动</strong></p>
<p>线程在调用<code>execute()</code>提交第一个任务时被启动，属于延迟启动，避免在无任务执行时启动线程的高开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    addTask(task);	<span class="comment">// 将任务添加到taskQueue中</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;	<span class="comment">// 其他线程提交任务</span></span><br><span class="line">        startThread();	<span class="comment">// 确保线程已经启动</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();  <span class="comment">// 如果添加时线程已经关闭、在关闭中或者终止，阻止提交任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);	<span class="comment">// 如果判断需要唤醒线程，则往taskQueue里面offer一个WAKEUP_TASK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;	<span class="comment">// 只在未启动状态下触发启动动作，避免重复启动</span></span><br><span class="line">        <span class="comment">// 1. // CAS更新状态，避免多个外部线程同时触发启动动作</span></span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                <span class="comment">// 2. 启动异常时，设置线程状态为未启动，使得下次可以重新尝试启动</span></span><br><span class="line">                STATE_UPDATER.set(<span class="built_in">this</span>, ST_NOT_STARTED);</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正线程启动的代码在<code>doStartThread()</code>中。</p>
<ol>
<li>调用抽象方法<code>run()</code>启动，具体逻辑在子类（<code>NioEventLoop</code>）中实现。如果启动成功，则会一直执行任务；</li>
<li>如果启动失败，或者<code>run()</code>方法退出 <ul>
<li>设置状态<code>ST_SHUTTING_DOWN</code></li>
<li>执行剩余任务和调用关闭钩子 —&gt; <code>confirmShutdown()</code></li>
<li>资源清理，例如<code>NioEventLoop</code>退出时需要关闭<code>Selector</code> —&gt; cleanup()</li>
<li>最终状态设置<code>ST_TERMINATED</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用子类的run()方法启动线程</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 设置状态，确保状态不为启动状态</span></span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">oldState</span> <span class="operator">=</span> state;</span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                        SingleThreadEventExecutor.<span class="built_in">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">			   <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2. 死循环，一直等到确认可以shutdown后退出循环</span></span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) &#123;  <span class="comment">// 执行剩余任务和关闭钩子，参考线程的关闭里的源码</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 3. 资源清理动作</span></span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 4. 最终状态设置</span></span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="built_in">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        <span class="keyword">if</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                                logger.warn(<span class="string">&quot;An event executor terminated with &quot;</span> +</span><br><span class="line">                                            <span class="string">&quot;non-empty task queue (&quot;</span> + taskQueue.size() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程终止</strong></p>
<p>线程终止调用<code>shutdownGracefully()</code>方法优雅退出，<code>shutdown()</code>方法已经废弃，不建议调用。</p>
<p>调用后，<code>executor</code>开始终止，其后调用<code>isShuttingDown()</code>返回true。</p>
<p>实际<code>shutdownGracefully()</code>只是设置状态和发通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quietPeriod：关闭时，允许在quietPeriod时间间隔内还能提交任务</span></span><br><span class="line"><span class="comment">// timeout/unit：关闭等待时长</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; shutdownGracefully(<span class="type">long</span> quietPeriod, <span class="type">long</span> timeout, TimeUnit unit) &#123;</span><br><span class="line">	<span class="comment">// ...省略，一些参数检查和状态判断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    <span class="type">boolean</span> wakeup;</span><br><span class="line">    <span class="type">int</span> oldState;</span><br><span class="line">    <span class="comment">// 循环判断和设置关闭时的状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShuttingDown()) &#123;	<span class="comment">// 已经在关闭流程中了，直接返回关闭的异步结果对象</span></span><br><span class="line">            <span class="keyword">return</span> terminationFuture();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> newState;</span><br><span class="line">        wakeup = <span class="literal">true</span>;</span><br><span class="line">        oldState = state;</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            newState = ST_SHUTTING_DOWN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (oldState) &#123;</span><br><span class="line">                <span class="comment">// 如果当前状态是未启动或者已启动，需要将状态设为关闭中</span></span><br><span class="line">                <span class="keyword">case</span> ST_NOT_STARTED:</span><br><span class="line">                <span class="keyword">case</span> ST_STARTED:</span><br><span class="line">                    newState = ST_SHUTTING_DOWN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 其他状态的话，不用改变状态，不需要唤醒</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    newState = oldState;</span><br><span class="line">                    wakeup = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, oldState, newState)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置参数，在confirmShutdown()中会用到</span></span><br><span class="line">    gracefulShutdownQuietPeriod = unit.toNanos(quietPeriod);</span><br><span class="line">    gracefulShutdownTimeout = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未启动，就调用了关闭方法，启动线程给剩余任务一个执行机会</span></span><br><span class="line">    <span class="keyword">if</span> (oldState == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doStartThread();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            STATE_UPDATER.set(<span class="built_in">this</span>, ST_TERMINATED);</span><br><span class="line">            terminationFuture.tryFailure(cause);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(cause <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">                PlatformDependent.throwException(cause);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> terminationFuture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒，使得线程继续执行，执行时可以判断线程状态来终止线程</span></span><br><span class="line">    <span class="keyword">if</span> (wakeup) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> terminationFuture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线程启动里，会调用子类实现的<code>run()</code>方法一直循环执行任务，执行时需要检查线程状态，如果<code>isShuttingDown()</code>返回true，需要退出执行。退出前会调用<code>confirmShutdown()</code>方法确认。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop的run()方法，for循环尾部会判断executor是否被终止</span></span><br><span class="line"><span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">    closeAll();</span><br><span class="line">    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>confirmShutdown()</code>真正处理关闭时的退出动作，包括执行剩余任务、执行关闭钩子等。调用<code>shutdownGracefully()</code>后确认关闭的几种情况：</p>
<ul>
<li>执行完任务或者执行完关闭钩子后，<code>quietPeriod</code>为0，不会接收新任务；</li>
<li>关闭<code>timeout</code>时间到了；</li>
<li>在等待提交任务时间<code>quietPeriod</code>内，没有提交任务；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">confirmShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isShuttingDown()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;must be invoked from an event loop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消定时任务，定时任务的管理由父类AbstractScheduledEventExecutor实现</span></span><br><span class="line">    cancelScheduledTasks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录关闭开始时间，也可以通过这个值判断是否已经调用过confirmShutdown()</span></span><br><span class="line">    <span class="keyword">if</span> (gracefulShutdownStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">        gracefulShutdownStartTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务，没有任务的话执行钩子</span></span><br><span class="line">    <span class="keyword">if</span> (runAllTasks() || runShutdownHooks()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;  <span class="comment">// shutdown()后直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gracefulShutdownQuietPeriod == <span class="number">0</span>) &#123; <span class="comment">// 等于0说明不允许接受新任务，直接退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wakeup(<span class="literal">true</span>);  <span class="comment">// 唤醒阻塞线程执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 未全部执行完成，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nanoTime</span> <span class="operator">=</span> ScheduledFutureTask.nanoTime();</span><br><span class="line">	<span class="comment">// 如果是shutdown()方法调用的关闭，isShutdown()返回true，此时直接确认退出，不进一步等待</span></span><br><span class="line">    <span class="comment">// 或者当前时间nanoTime减关闭开始时间已经大过需要关闭timeout时间</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown() || nanoTime - gracefulShutdownStartTime &gt; gracefulShutdownTimeout) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在等待时间到之前，每隔100ms唤醒，检查是否有新添加的任务</span></span><br><span class="line">    <span class="keyword">if</span> (nanoTime - lastExecutionTime &lt;= gracefulShutdownQuietPeriod) &#123;</span><br><span class="line">        wakeup(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待时间内没有新任务提交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任务执行</strong></p>
<p>任务执行主要交由<code>runAllTasks()</code>的两个重载方法，<code>NioEventLoop</code>执行<code>run()</code>时会调用这两个方法：</p>
<ul>
<li><code>runAllTasks()</code>：从<code>taskQueue</code>中取出任务执行；</li>
<li><code>runAllTasks(long timeoutNanos)</code>：从<code>taskQueue</code>中取出任务，如果执行时间超过<code>timeoutNanos</code>，停止取出任务然后返回；</li>
</ul>
<p>流程类似：</p>
<ol>
<li>从父类的<code>scheduledTaskQueue</code>中取出到点的定时任务，添加到<code>taskQueue</code>中 —&gt; <code>fetchFromScheduledTaskQueue()</code>；</li>
<li>从<code>taskQueue</code>中取出任务 —&gt; <code>pollTask()</code>；</li>
<li>如果没有任务可执行，调用回调方法 —&gt; <code>afterRunningAllTasks()</code>；</li>
<li>执行任务 – <code>safeExecute(task)</code>（内部调用<code>task.run()</code>，参考<code>ScheduledFutureTask</code>的<code>run()</code>方法；</li>
<li>如果是限时执行方法<code>runAllTasks(long timeoutNanos)</code>，每执行64个任务检查是否已经超时，超时则结束执行；</li>
<li>最终调用回调方法 – <code>afterRunningAllTasks()</code>；</li>
</ol>
<p><code>runAllTasks(long timeoutNanos)</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">runAllTasks</span><span class="params">(<span class="type">long</span> timeoutNanos)</span> &#123;</span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="type">long</span> <span class="variable">runTasks</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 内部调用task.run()执行任务</span></span><br><span class="line">        safeExecute(task);</span><br><span class="line"></span><br><span class="line">        runTasks ++; <span class="comment">// runTasks记录执行任务个数，执行一个后加1</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 每执行64个任务检查一次是否超时</span></span><br><span class="line">        <span class="comment">// 因为调用nanoTime()有一定开销，所以每隔64个任务调用一次</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;  <span class="comment">// 超时的话break退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterRunningAllTasks();  <span class="comment">// 执行任务完成后的回调，子类可以实现具体逻辑</span></span><br><span class="line">    <span class="built_in">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SingleThreadEventLoop"><a href="#SingleThreadEventLoop" class="headerlink" title="SingleThreadEventLoop"></a><code>SingleThreadEventLoop</code></h3><p><code>SingleThreadEventLoop</code>开始实现<code>EventLoop</code>接口方法，主要是将<code>Channel</code>注册到<code>EventLoop</code>的<code>register()</code>方法，底层调用了<code>Channel</code>绑定的<code>Unsafe</code>类的<code>register()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, <span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);  <span class="comment">// 调用unsafe类的register()方法注册channel</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a><code>NioEventLoop</code></h3><p><code>NioEventLoop</code>实现具体执行任务的逻辑。<code>NioEventLoop</code>是Netty事件驱动的核心组件。主要特性：</p>
<ul>
<li>支持执行I&#x2F;O任务和普通任务 <ul>
<li>I&#x2F;O任务：由NIO Select机制触发，<code>accept</code>、<code>connect</code>、<code>read</code>、<code>write</code>等 ；</li>
<li>普通任务：调用<code>execute()</code>添加到任务队列中执行，如<code>register</code>、<code>bind</code>等；</li>
</ul>
</li>
<li>使用一个参数<code>ioRatio</code>控制执行两种类型任务的时间比例；</li>
</ul>
<h4 id="主体流程"><a href="#主体流程" class="headerlink" title="主体流程"></a>主体流程</h4><p><code>NioEventLoop</code>代码的核心在于用于执行任务的<code>run</code>方法。回顾下NioEventLoop的继承体系中任务执行的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JDK - Executor --&gt; execute 定义用于提交任务</span><br><span class="line">  JDK - ExecutorService --&gt; submit/shutdown等 定义其他操作</span><br><span class="line">  	Netty - AbstractEventExecutor --&gt; 覆盖newTaskFor()，返回PromiseTask</span><br><span class="line">  		Netty - AbstractScheduledEventExecutor --&gt; Schedule类方法，任务封装ScheduledFutureTask，返回ScheduledFuture</span><br><span class="line">  			Netty - SingleThreadEventExecutor --&gt; 实现execute()，往taskQueue提交任务并调用子类的run()执行任务</span><br></pre></td></tr></table></figure>

<p><code>**run**</code><strong>方法实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 轮询Selector</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="literal">false</span>));</span><br><span class="line">									<span class="comment">// 省略大段注释</span></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span></span><br><span class="line">                <span class="comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span></span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="comment">// 2. 根据ioRatio，处理I/O事件和其他任务</span></span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>run</code>方法实际上是个for死循环，主体流程：</p>
<ol>
<li>轮询<code>Channel</code>，选择就绪的I&#x2F;O事件。</li>
<li>处理就绪的I&#x2F;O事件 - <code>**processSelectedKeys**</code>。</li>
<li>处理任务队列中的普通任务（包含调度任务） - <code>**runAllTasks**</code>。</li>
</ol>
<p><code>NioEventLoop</code>使用了一个<code>ioRatio</code>的实例变量来控制I&#x2F;O事件任务占比(默认50)，通过分配给<code>runAllTasks</code>的时间片实现，<code>runAllTasks</code>的实现解析参考<code>SingleThreadEventExecutor</code>部分。主要看I&#x2F;O轮询（Select）和处理I&#x2F;O事件的部分。</p>
<h4 id="I-x2F-O轮询"><a href="#I-x2F-O轮询" class="headerlink" title="I&#x2F;O轮询"></a>I&#x2F;O轮询</h4><p>首先通过<code>selectStrategy#calculateStrategy</code>计算轮询策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</span><br></pre></td></tr></table></figure>

<p>有三种策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indicates the IO loop should be retried, no blocking select to follow directly.</span></span><br><span class="line">SelectStrategy.CONTINUE</span><br><span class="line"><span class="comment">// Indicates the IO loop to poll for new events without blocking.</span></span><br><span class="line"><span class="comment">// 注：NioEventLoop不支持，参考EpollEventLoop的epollBusyWait</span></span><br><span class="line">SelectStrategy.BUSY_WAIT</span><br><span class="line"><span class="comment">// Indicates a blocking select should follow.</span></span><br><span class="line">SelectStrategy.SELECT</span><br></pre></td></tr></table></figure>

<p>默认的策略计算实现是<code>DefaultSelectStrategy</code>，可以简单地理解成：<strong>如果</strong><code>**taskQueue**</code><strong>中有普通任务，则使用</strong><code>**selectNow**</code><strong>方法，否则使用</strong><code>**select(boolean oldWakenUp)**</code><strong>方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSelectStrategy</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="type">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  	<span class="comment">// 如果有普通任务，使用指定的Supplier计算，否则默认为SelectStrategy.SELECT</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop的默认IntSupplier</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IntSupplier</span> <span class="variable">selectNowSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntSupplier</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点看下 <code>**selectNow()**</code> 和 <code>**select(oldWakenUp)**</code> 两者的区别：</p>
<ul>
<li><code>**selectNow()**</code> 直接调用NIO的<code>Selector#selectNow</code>方法，表示进行<strong>非阻塞</strong>的I&#x2F;O就绪检查， 如果有I&#x2F;O就绪, 则返回就绪 I&#x2F;O 事件的个数；否则返回0。因为非阻塞，所以使用<code>selectNow()</code>在没有I&#x2F;O就绪事件时马上返回，不会阻塞普通事件的执行，这是在<code>hasTasks</code>时使用<code>selectNow()</code>的原因；</li>
<li>而 <code>**select(oldWakenUp)**</code>则会调用NIO的<code>Selector#select(long timeout)</code>方法进行阻塞Select；</li>
</ul>
<p><code>select(oldWakenUp)</code>的实现因为要处理著名的JDK空轮询Bug显得有些复杂。主体代码如下(省略了英文注释和部分非关键逻辑)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(<span class="type">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 计算select方法的阻塞事件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 到期时间设置成当前时间加上delayNanos()返回的最近一次调度任务的时间(没有的话返回1s)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">selectDeadLineNanos</span> <span class="operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 因为select(timeout)方法参数是毫秒，这里做四舍五入将纳秒转成毫秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 不到1ms的话，没必要进行阻塞select</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有做过select，直接执行一次非阻塞的selectNow，避免漏掉I/O事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 有任务进入队列并且wakeUp标志是false，直接进行selectNow</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 2. 真正执行阻塞的select操作并自增selectCnt</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有I/O就绪 || wakeUp by user || taskQueue有任务 || 调度任务待执行</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 这里是Netty解决JDK Bug的关键判断，注意只在select返回0的时候才走到这里</span></span><br><span class="line">            <span class="comment">// 如果select阻塞时间正常，则重置selectCnt = 1</span></span><br><span class="line">            <span class="comment">// 否则判断是否超出阈值(默认512)，如果超出则任务触发了空轮询bug，重建Selector</span></span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>select(oldWakenUp)</code>的主体流程就是进行NIO的select操作，为了解决JDK Bug，引入了一个<code>selectCnt</code>变量记录select次数，正常情况下<code>selectCnt</code>都会被重置，只有在<strong>select阻塞时间内（而不是阻塞超时）返回0</strong>时会保留，在selectCnt达到默认的512时，就认为触发了JDK的空轮询bug。</p>
<blockquote>
<p>回忆一下，JDK的空轮询bug会触发select操作在没有I&#x2F;O就绪时就被唤醒，并且返回空的selectKeys。</p>
</blockquote>
<p>Netty在这时候的解决方法是通过<code>rebuildSelector()</code>重新打开一个<code>Selector</code>；然后遍历原有的<code>oldSelector</code>，将所有的key重新注册到新的<code>Selector</code>；最后切换到<code>selector</code>，并重置<code>selectCnt = 1</code>。</p>
<h4 id="I-x2F-O处理"><a href="#I-x2F-O处理" class="headerlink" title="I&#x2F;O处理"></a>I&#x2F;O处理</h4><p>I&#x2F;O处理的入口是<code>processSelectedKeys</code>，它里面会判断是否进行优化处理，判断的依据在于<code>selectedKeys != null</code>。如果非空，会走优化处理流程，否则走普通处理流程。两者的区别主要在于迭代获取就绪的SelectionKey的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processSelectedKeysOptimized实现里直接从selectedKeys变量中迭代获取SelectionKey</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; selectedKeys.size; ++i) </span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> selectedKeys.keys[i];</span><br><span class="line"><span class="comment">// processSelectedKeysPlain从selector.selectedKeys()中迭代获取SelectionKey</span></span><br><span class="line">Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">k</span> <span class="operator">=</span> i.next();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>selectedKeys</code>是Netty做的性能优化，主要用来加速获取就绪I&#x2F;O时的迭代性能。它在<code>NioEventLoop</code>构造函数中初始化，将原生<code>Selector</code>的<code>selectedKeys</code>域通过反射重设为<code>selectedKeys</code>。原生类型在默认实现<code>sun.nio.ch.SelectorImpl</code>中是<code>HashSet</code>；而<code>selectedKeys</code>是<code>SelectedSelectionKeySet</code>类型。</p>
</blockquote>
<p>实际处理的逻辑在<code>processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code>中实现，简单来说，就是对NIO中的<code>OP_READ</code>&#x2F;<code>OP_WRITE</code>&#x2F;<code>OP_CONNECT</code>三类事件，委托给<code>NioUnsafe</code>对象处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">				<span class="comment">// 省略部分，在SelectionKey无效时关闭Channel</span></span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="comment">// 客户端连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops); <span class="comment">// 设置连接后感兴趣的事件</span></span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 读事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="top-box-text">1 概述</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#2-EventLoop"><span class="top-box-text">2 EventLoop</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#3-EventLoopGroup"><span class="top-box-text">3 EventLoopGroup</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Channel%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B"><span class="top-box-text">Channel注册流程</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#4-%E4%BD%BF%E7%94%A8"><span class="top-box-text">4 使用</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="top-box-text">基本使用</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="top-box-text">实践建议</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#5-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="top-box-text">5 源码分析</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="top-box-text">核心类结构</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%AD%E9%97%B4%E7%9A%84%E7%BA%BF%EF%BC%9AEventLoopGroup%E3%80%81EventLoop"><span class="top-box-text">中间的线：EventLoopGroup、EventLoop</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#EventLoop"><span class="top-box-text">EventLoop</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%8F%B3%E8%BE%B9%E7%9A%84%E7%BA%BF%EF%BC%9AEventExecutorGroup%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="top-box-text">右边的线：EventExecutorGroup和子类</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#EventExecutorGroup%E6%8E%A5%E5%8F%A3"><span class="top-box-text">EventExecutorGroup接口</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#AbstractEventExecutorGroup"><span class="top-box-text">AbstractEventExecutorGroup</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#MultithreadEventExecutorGroup"><span class="top-box-text">MultithreadEventExecutorGroup</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#MultithreadEventLoopGroup"><span class="top-box-text">MultithreadEventLoopGroup</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#NioEventLoopGroup"><span class="top-box-text">NioEventLoopGroup</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B7%A6%E8%BE%B9%E7%9A%84%E7%BA%BF%EF%BC%9AEventExecutor"><span class="top-box-text">左边的线：EventExecutor</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#EventExecutor%E6%8E%A5%E5%8F%A3"><span class="top-box-text">EventExecutor接口</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#AbstractEventExecutor"><span class="top-box-text">AbstractEventExecutor</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#AbstractScheduledEventExecutor"><span class="top-box-text">AbstractScheduledEventExecutor</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ScheduledFutureTask"><span class="top-box-text">ScheduledFutureTask</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#SingleThreadEventExecutor"><span class="top-box-text">SingleThreadEventExecutor</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#SingleThreadEventLoop"><span class="top-box-text">SingleThreadEventLoop</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#NioEventLoop"><span class="top-box-text">NioEventLoop</span></a></li></ol></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2019/04/28/Netty%E6%8C%87%E5%8C%97%E7%B3%BB%E5%88%974-ChannelHandler%E5%92%8CChannelPipeline/">
          <h3 class="post-title">
            下一篇：Netty指北系列4-ChannelHandler和ChannelPipeline
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


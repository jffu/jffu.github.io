<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Netty指北系列3-Channel</title>
<meta name="keywords" content="Netty指北系列3-Channel, jffu&#39;s blog">
<meta name="description" content="Netty的网络抽象核心概念之一, Channel。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Netty指北系列3-Channel">
<meta property="og:description" content="Netty的网络抽象核心概念之一, Channel。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Netty指北系列3-Channel</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2019-03-07</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Netty/">
              Netty
                
                  ，
                
              </a>
            
              <a href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">
              网络协议
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>Netty的网络抽象核心概念之一是<code>Channel</code>。Netty中的<code>Channel</code>不同于Java NIO类库中的<code>Channel</code>。它屏蔽了直接使用Java Socket编程的复杂性，提供了基本的I&#x2F;O操作,例如<code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code>等等。</p>
<p>Netty中<code>Channel</code>的关键特性：</p>
<ul>
<li>提供诸多API实现网络I&#x2F;O，比如<code>read()</code>、<code>write()</code>、<code>connect()</code>、<code>bind()</code>、<code>close()</code>等。</li>
<li>提供<code>metadata()</code>等方法用于设置TCP参数，比如TCP缓冲区大小、超时时间、是否重用地址等。</li>
<li>屏蔽了<code>SocketChannel</code>和<code>ServerSocketChannel</code>的使用差异，提供了统一的操作视图。</li>
<li>Netty预置了一系列<code>Channel</code>类型用于不同场合，例如常用的基于NIO的<code>NioServerSocketChannel</code>&#x2F;<code>NioSocketChannel</code>、基于Linux Epoll的<code>EpollServerSocketChannel</code>&#x2F;<code>EpollSocketChannel</code>，还有OIO版本的<code>OioServerSocketChannel</code>&#x2F;<code>OioSocketChannel</code>等。</li>
<li>绑定了一个<code>ChannelPipeline</code>用于事件处理。</li>
</ul>
<h1 id="二-原理"><a href="#二-原理" class="headerlink" title="二 原理"></a>二 原理</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>以服务端为例：</p>
<ol>
<li>客户端连接成功时，新建一个<code>Channel</code>与之绑定，对应一条跟客户端间的链路；</li>
<li>注册到<code>EventLoop</code>的多路复用器上，处理I&#x2F;O事件；</li>
<li><code>Channel</code>进行I&#x2F;O操作时产生对应的I&#x2F;O事件，驱动事件在<code>ChannelPipeline</code>中传播，由<code>ChannelHandler</code>链处理；</li>
</ol>
<h2 id="Channel生命周期"><a href="#Channel生命周期" class="headerlink" title="Channel生命周期"></a>Channel生命周期</h2><p><code>Channel</code>的生命周期状态如下：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelUnregistered</td>
<td>Channel被创建，但还未注册到EventLoop上</td>
</tr>
<tr>
<td>ChannelRegistered</td>
<td>Channel注册到EventLoop上</td>
</tr>
<tr>
<td>ChannelActive</td>
<td>Channel处于活动状态，连接到了对端，可以接收和发送数据</td>
</tr>
<tr>
<td>ChannelInactive</td>
<td>Channel与远端的连接断开</td>
</tr>
</tbody></table>
<p>状态迁移流程如下，在状态迁移时，对应的<code>ChannelHandler</code>中的回调方法会被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelRegistered --&gt; ChannelActive --&gt; ChannelInactive --&gt; ChannelUnregistered</span><br></pre></td></tr></table></figure>

<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>从<code>Channel</code>的类继承关系中可以看到，<code>Channel</code>主要提供了两大类方法：</p>
<ol>
<li><code>Channel</code>接口继承了<code>ChannelOutboundInvoker</code>，其中中定义了一系列I&#x2F;O操作相关的方法；</li>
<li><code>Channel</code>自身定义的方法，主要的是获取跟当前<code>Channel</code>绑定的一些对象，例如<code>EventLoop</code>、<code>ChannelPipeline</code>、<code>SocketAddress</code>等；</li>
</ol>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkzTeQd-mArQdYIYRJj7E1V-kAQK.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkzTeQd-mArQdYIYRJj7E1V-kAQK.png"  lazyload></a></p>
<p>在<code>ChannelOutboundInvoker</code>中定义的所有I&#x2F;O方法都是异步的，方法返回<code>ChannelFuture</code>。<code>ChannelFuture</code>是Netty对JDK原生<code>Future</code>的增强，因为原生的<code>Future</code>接口只支持轮询（<code>isDone</code>）或者阻塞式等待结果（<code>get</code>），而<code>ChannelFuture</code>支持设置监听器回调，可以通过<code>ChannelFuture</code>处理异步操作的结果。</p>
<p><code>Channel</code>中又定义了一些方法，主要的有：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eventLoop</td>
<td>返回分配给<code>Channel</code></td>
</tr>
<tr>
<td>的<code>EventLoop</code></td>
<td></td>
</tr>
<tr>
<td>pipeline</td>
<td>返回分配给<code>Channel</code></td>
</tr>
<tr>
<td>的<code>ChannelPipeline</code></td>
<td></td>
</tr>
<tr>
<td>localAddress&#x2F;remoteAddress</td>
<td>本机&#x2F;远程的<code>SocketAddress</code></td>
</tr>
<tr>
<td>config</td>
<td>返回<code>ChannelConfig</code></td>
</tr>
<tr>
<td>，<code>ChannelConfig</code></td>
<td></td>
</tr>
<tr>
<td>中保存了<code>Channel</code></td>
<td></td>
</tr>
<tr>
<td>的各种配置</td>
<td></td>
</tr>
<tr>
<td>unsafe</td>
<td>返回内部使用的<code>Unsafe</code></td>
</tr>
<tr>
<td>对象，I&#x2F;O操作通过<code>Unsafe</code></td>
<td></td>
</tr>
<tr>
<td>对象完成</td>
<td></td>
</tr>
</tbody></table>
<h2 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h2><p>根据底层实现机制的不同，<code>Channel</code>可以分为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>实现类示例</th>
<th>包</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>NIO</td>
<td><code>NioServerSocketChannel</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;<code>NioSocketChannel</code></td>
<td>io.netty.channel.socket.nio</td>
<td>基于JDK NIO类库，使用java.nio.channels</td>
<td></td>
</tr>
<tr>
<td>OIO</td>
<td><code>OioServerSocketChannel</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;<code>OioSocketChannel</code></td>
<td>io.netty.channel.socket.oio</td>
<td>基于JDK OIO类库，使用java.net</td>
<td></td>
</tr>
<tr>
<td>Epoll</td>
<td><code>EpollServerSocketChannel</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;<code>EpollSocketChannel</code></td>
<td>io.netty.channel.epoll</td>
<td>基于Linux的epoll模型，比基于Select的NIO性能更高</td>
<td></td>
</tr>
<tr>
<td>Local</td>
<td><code>LocalServerChannel</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;<code>LocalChannel</code></td>
<td>io.netty.channel.local</td>
<td>基于pipe，本地JVM内通信</td>
<td></td>
</tr>
<tr>
<td>Embedded</td>
<td><code>EmbeddedChannel</code></td>
<td>io.netty.channel.embedded</td>
<td>测试ChannelHandler时可以使用，不需要真实网络环境</td>
</tr>
</tbody></table>
<p>NIO&#x2F;OIO&#x2F;Epoll实现比较常用。</p>
<ol>
<li>在通常情况下，使用NIO是比较好的选择，因为它是非阻塞的，性能一般来说更好，适用于Windows&#x2F;Linux多平台；</li>
<li>如果在Linux下，可以考虑Epoll实现，性能更好；</li>
<li>如果代码基于阻塞模型设计，代码调用依赖于阻塞I&#x2F;O的结果，那么考虑使用OIO；</li>
</ol>
<h1 id="三-源码"><a href="#三-源码" class="headerlink" title="三 源码"></a>三 源码</h1><h2 id="1-Channel接口"><a href="#1-Channel接口" class="headerlink" title="1. Channel接口"></a>1. Channel接口</h2><p><code>Channel</code>接口是网络I&#x2F;O的抽象，定义了一系列方法。主要有3类：</p>
<ul>
<li><code>Channel</code>状态、设置，例如<code>isOpen()</code>、<code>isRegistered()</code>、<code>isActive()</code>等状态，<code>config()</code>设置参数；</li>
<li>I&#x2F;O操作，例如从<code>ChannelOutboundInvoker</code>接口继承来的<code>bind()</code>、<code>connect()</code>、<code>disconnect()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>等等；</li>
<li>获取一些与<code>Channel</code>绑定的组件，例如<code>eventLoop()</code>、<code>pipeline()</code>、<code>metadata()</code>、<code>alloc()</code>等；</li>
</ul>
<p>几个特点：</p>
<ul>
<li>所有I&#x2F;O操作都是异步非阻塞的。I&#x2F;O方法返回一个<code>ChannelFuture</code>用于获取操作结果； </li>
<li>每个<code>Channel</code>都绑定了对应的<code>EventLoop</code>、<code>ChannelPiple</code>等Netty里的重要组件，<code>Channel</code>接口提供了这些组件的获取方法； </li>
<li><code>Channel</code>分层级，可以用<code>parent()</code>方法获取父<code>Channel</code>（如果没有，返回空），例如客户端连接<code>SocketChannel</code>对应的parent是<code>ServerSocketChannel</code>；</li>
</ul>
<h2 id="2-Channel子类"><a href="#2-Channel子类" class="headerlink" title="2. Channel子类"></a>2. Channel子类</h2><p>根据协议类型（TCP&#x2F;UDP），底层I&#x2F;O模型（epoll&#x2F;kqueue&#x2F;NIO&#x2F;OIO）等，Channel接口有很多实现类。</p>
<p>常用的Channel子类（位于<code>io.netty.channel.socket</code>包下）：</p>
<ul>
<li>NIO：<code>NioServerSocketChannel</code>&#x2F;<code>NioSocketChannel</code></li>
<li>OIO：<code>OioServerSocketChannel</code>&#x2F;<code>OioSocketChannel</code></li>
</ul>
<p>从最常用的<code>NioServerSocketChannel</code>往上看，继承树是这样的：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fsf5bW0iBJ9OxNlEjEHfqLv_i5Jr.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fsf5bW0iBJ9OxNlEjEHfqLv_i5Jr.png"  lazyload></a></p>
<h3 id="2-1-AbstractChannel"><a href="#2-1-AbstractChannel" class="headerlink" title="2.1 AbstractChannel"></a>2.1 AbstractChannel</h3><p><code>AbstractChannel</code>是大多数<code>Channel</code>实现类的父类，里面实现了一些通用的<code>Channel</code>接口方法。同时也提供了一些protected方法（不一定是抽象方法，某些方法有默认的实现）交由具体的功能子类去实现。</p>
<p>主要成员变量：</p>
<ul>
<li><code>pipleline</code>：当前<code>Channel</code>绑定的<code>ChannelPipeline</code>对象，一般是一个<code>DefaultChannelPipeline</code>；</li>
<li><code>eventLoop</code>：当前<code>Channel</code>绑定的<code>EventLoop</code>对象；</li>
<li><code>unsafe</code>：<code>Unsafe</code>实例；</li>
<li><code>parent</code>：父类<code>Channel</code>实例；</li>
</ul>
<p><code>AbstractChannel</code>聚合这些成员变量，提供了统一的封装。例如，将大部分I&#x2F;O操作交给<code>ChannelPipeline</code>实现。</p>
<p><code>AbstractChannel</code>的I&#x2F;O操作方法实际上调用<code>pipeline</code>对象的对应方法，因此同一个I&#x2F;O操作使用<code>Channel</code>或者其绑定的<code>ChannelPipeline</code>调用，效果是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例：AbstractChannel通过聚合的ChannelPipeline实现I/O操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">write</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.write(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractChannel</code>里面也定义了一些<code>doXXX()</code>命名的抽象方法，例如<code>doBind()</code>、<code>doDisconnect()</code>、<code>doClose()</code>、<code>doWrite()</code>等。</p>
<ul>
<li>在<code>XXX()</code>方法里调用<code>doXXX()</code>方法，<code>XXX()</code>里一般会做一些状态判断，<code>doXXX()</code>去做真正的操作，例如<code>bind()</code>里会调用<code>doBind()</code>。方法名并不一定完全对应，例如<code>doWrite()</code>是在<code>flush()</code>中被实际调用； </li>
<li>这类方法与具体的<code>Channel</code>类型相关，需要不同的功能子类去实现；</li>
</ul>
<h3 id="2-2-AbstractNioChannel"><a href="#2-2-AbstractNioChannel" class="headerlink" title="2.2 AbstractNioChannel"></a>2.2 AbstractNioChannel</h3><p><code>AbstractNioChannel</code>比较关键，它代表使用<code>java.nio</code>作为底层实现的<code>Channel</code>父类。</p>
<p>3个主要的成员变量，与NIO的<code>Selector</code>关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自java.nio.channels，使用Selector进行多路复用，使用时需要注册到一个Selector</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectableChannel ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示NIO中SelectionKey的事件类型（OP_READ/OP_WRITE/OP_CONNECT/OP_ACCEPT），根据需要注册的实际类型配置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> readInterestOp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Channel注册到Selector后返回的SelectionKey</span></span><br><span class="line"><span class="keyword">volatile</span> SelectionKey selectionKey;</span><br></pre></td></tr></table></figure>

<p>构造方法，主要设置了Channel的非阻塞模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent            the parent &#123;<span class="doctag">@link</span> Channel&#125; by which this instance was created. May be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ch                the underlying &#123;<span class="doctag">@link</span> SelectableChannel&#125; on which it operates</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readInterestOp    the ops to set to receive data from the &#123;<span class="doctag">@link</span> SelectableChannel&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将Channel设为非阻塞模式</span></span><br><span class="line">        ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了<code>AbstractNioChannel</code>这一级，做的事情更加具体，主要是跟<code>Selector</code>打交道，包括注册&#x2F;去注册，实际真正的注册分为两步：</p>
<ol>
<li>使用<code>doRegister()</code>将<code>Channel</code>注册到一个<code>Selector</code>，操作集（<code>ops</code>）值为0，表示仅注册但不对任何I&#x2F;O事件感兴趣；</li>
<li>使用<code>doBeginRead()</code>注册真正的I&#x2F;O事件类型，即将成员变量<code>readInterestOp</code>配置的类型注册到<code>Selector</code>；</li>
</ol>
<p><code>doRegister()</code>在对外方法<code>register()</code>中被调用，而<code>doBeginRead()</code>在<code>beginRead()</code>中被调用。<code>AbstractChannel</code>提供了<code>register()</code>&#x2F;<code>beginRead()</code>的公共实现部分，具体功能交由像<code>AbstractNioChannel</code>这样的功能子类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 使用死循环进行注册，主要是预防出现CancelledKeyException无法成功注册的场景（猜测可能调用了去注册方法会导致）</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用NIO类库的标准方法，将NIO channel注册给Selector</span></span><br><span class="line">            <span class="comment">// Selector来自于Netty Channel绑定的EventLoop上的Selector，一个EventLoop使用一个Selector处理多个Channel上的I/O事件</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123; <span class="comment">// Channel注册的SelectionKey被取消后会抛出此异常</span></span><br><span class="line">            <span class="comment">// 第一次处理时selected为false，调用Selector的selectNow()方法会删除cache的被取消的SelectionKey</span></span><br><span class="line">            <span class="comment">// 第二次处理时selected为true，未知错误，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDeregister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 调用EventLoop对象的cancel(SelectionKey key)方法去注册，底层实际上调用了SelectionKey的cancel()方法</span></span><br><span class="line">    eventLoop().cancel(selectionKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把真正感兴趣的I/O事件注册给Selector，如果已经注册，不会重复注册</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-AbstractNioByteChannel-x2F-AbstractNioMessageChannel"><a href="#2-3-AbstractNioByteChannel-x2F-AbstractNioMessageChannel" class="headerlink" title="2.3 AbstractNioByteChannel&#x2F;AbstractNioMessageChannel"></a>2.3 AbstractNioByteChannel&#x2F;AbstractNioMessageChannel</h3><p><code>AbstractNioByteChannel</code>和<code>AbstractNioMessageChannel</code>进一步细化了<code>AbstractNioChannel</code>，分别基于字节（<code>Byte</code>）和消息对象（<code>Message</code>）进行操作。<br>两个类的主要方法是<code>doWrite()</code>(ChannelOutboundBuffer in)，两者流程类似：从指定的Buffer中取出数据（字节or消息对应的Object对象）写给远程的对端。注意这里的写实际上对应<code>Channel</code>的flush操作，在<code>AbstractChannel</code>实现的<code>flush()</code>方法中会调用到这里的<code>doWrite()</code>。</p>
<p>在一般开发中一般是写字节为主，<code>NioServerSocketChannel</code>虽然继承自<code>AbstractNioMessageChannel</code>，但实际上是用来接收客户端连接，并不会向对端直接写数据，因此对应的<code>doWrite()</code>方法没有真正的实现，调用时会直接抛出<code>UnsupportedOperationException</code>。</p>
<p>以<code>AbstractNioByteChannel</code>为例，从<code>doWrite()</code>的流程中可以看出Netty对网络可靠性的处理优化：</p>
<ol>
<li>不断从<code>ChannelOutboundBuffer</code>中取数据，直到取到的数据msg为null为止，为了限制往同一个<code>Socket</code>不停写的开销，写的次数限制为<code>ChannelConfig</code>中配置的<code>writeSpinCount</code>； <ul>
<li><code>writeSpinCount</code>为写半包最大循环次数，默认值是16，即最多尝试16次；</li>
<li>设置尝试发送次数限制的原因：从代码上看，如果不设置限制，当底层<code>Channel</code>不可写（例：写缓冲区满）时，<code>doWrite()</code>方法的死循环会一直尝试写操作，阻塞I&#x2F;O线程。一方面会拉高CPU占有率，另一方面会阻塞其他使用同一I&#x2F;O线程的I&#x2F;O操作；</li>
</ul>
</li>
<li>如果取到的msg为null，说明buffer中的待发送消息都已经发送完毕。清除写操作位（如果此时注册了<code>OP_WRITE</code>，需要从<code>Selector</code>上清除写操作位（否则只要<code>Channel</code>可写，底层<code>select()</code>会一直返回写就绪），退出循环；</li>
<li>根据数据msg类型是<code>ByteBuf</code>或者<code>FileRegion</code>，采取不同的写逻辑，基本原理类似；</li>
<li>在<code>Channel</code>配置的循环发送次数<code>writeSpinCount</code>内，尝试写数据<code>doWriteBytes()</code>； <ul>
<li><code>doWriteBytes()</code>是一个抽象方法，具体实现交给子类，例如<code>NioSocketChannel</code>类实现了该方法，来做真正的字节写操作；</li>
<li>如果<code>doWriteBytes()</code>返回0，说明没有成功写入数据，可能写缓冲区已满，这时候退出外层的循环，减少重试开销；</li>
</ul>
</li>
<li>更新发送进度，根据发送是否完成： <ul>
<li>如果发送完成，从buffer中删除已经发送的消息；</li>
<li>如果发送未完成（在循环发送次数限制内没有发完），调用<code>incompleteWrite()</code>设置未完成状态；</li>
</ul>
</li>
</ol>
<p><strong>UPDATE：</strong>4.1.27.Final版本里，为了限制往同一Socket写的开销，代码流程有改动。之前<code>writeSpinCount</code>限制每条<code>ChannelOutboundBuffer</code>中取出的消息的写最大次数，现在<code>writeSpinCount</code>限制总的写次数。</p>
<p>&#x2F;&#x2F; TODO：后续有空补下流程图</p>
<p>代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">writeSpinCount</span> <span class="operator">=</span> config().getWriteSpinCount();  <span class="comment">// 从Channel配置中获取写次数限制</span></span><br><span class="line">    <span class="comment">// NOTE：4.1.27更新，为了限制往同一个Socket写的花销，使用writeSpinCount限制，参考commit b215794de31f28355e4469fcc04782f55076c80c</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从ChannelOutboundBuffer中取出消息，直到所有消息都处理完毕（发送完成or超出循环次数后发送未完成）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> in.current();   <span class="comment">// 取消息</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;	<span class="comment">// 如果取出消息为空，说明buffer中没有待发送消息，清除写操作位并退出循环</span></span><br><span class="line">            <span class="comment">// Wrote all messages.</span></span><br><span class="line">            clearOpWrite();	<span class="comment">// 清除写操作位，防止一直有写就绪事件</span></span><br><span class="line">            <span class="comment">// Directly return here so incompleteWrite(...) is not called.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        writeSpinCount -= doWriteInternal(in, msg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写未完成时调用</span></span><br><span class="line">    <span class="comment">// writeSpinCount &lt; 0：说明在写过程中出现了无法写入数据的情况，可能底层写缓冲区已满，为了避免在这种情况下一直尝试写，设置写半包表示位setOpWrite，退出循环，释放I/O线程</span></span><br><span class="line">    <span class="comment">// writeSpinCount &gt;= 0：说明在次数限制内没有写完全部数据，启动任务继续</span></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doWriteInternal</span><span class="params">(ChannelOutboundBuffer in, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 根据msg类型（ByteBuf or FileRegion）进行不同的处理</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">if</span> (!buf.isReadable()) &#123;	<span class="comment">// 如果消息的ByteBuf不可读，直接从buffer中删除，继续取下一条</span></span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写操作调用doWriteBytes()，返回值localFlushedAmount表示写成功的字节数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">localFlushedAmount</span> <span class="operator">=</span> doWriteBytes(buf);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;	<span class="comment">// localFlushedAmount &gt; 0说明写入了数据（不一定写完），这次写是成功的，返回1减少一次写次数</span></span><br><span class="line">            in.progress(localFlushedAmount);	<span class="comment">// 更新进度</span></span><br><span class="line">            <span class="keyword">if</span> (!buf.isReadable()) &#123;	<span class="comment">// 如果buf不可读，说明已经写完，可以将buf从ChannelOutboundBuffer中移除</span></span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FileRegion) &#123;	<span class="comment">// 写FileRegion流程，与ByteBuf类似</span></span><br><span class="line">        <span class="type">FileRegion</span> <span class="variable">region</span> <span class="operator">=</span> (FileRegion) msg;</span><br><span class="line">        <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">            in.remove();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用doWriteFileRegion()发送数据，底层使用FileChannel的transferTo()方法，可以使用零拷贝提升性能</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">localFlushedAmount</span> <span class="operator">=</span> doWriteFileRegion(region);</span><br><span class="line">        <span class="keyword">if</span> (localFlushedAmount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            <span class="keyword">if</span> (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Should not reach here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写失败时，返回一个极大值（Integer.MAX_VALUE），退出外层doWrite()里的循环，减少重试开销</span></span><br><span class="line">    <span class="keyword">return</span> WRITE_STATUS_SNDBUF_FULL;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果消息没有成功写完（可能没有写了一部分或0字节），需要调用incompleteWrite(setOpWrite)来进行重试。setOpWrite是写半包标识，根据setOpWrite值，重试策略不同。</p>
<ul>
<li>如果setOpWrite为true，向Selector注册OP_WRITE，通过Selector的select，在写就绪时处理没有发送成功的半包数据；</li>
<li>如果setOpWrite为false，则启动独立的任务，在EventLoop中执行。在Runnable中，接着调用flush()方法发送数据。</li>
</ul>
<p>从代码上看，使用doWrite()写消息时，setOpWrite默认为false。</p>
<ul>
<li>如果写过程中发现doWriteBytes()无法写入（写缓冲区已满，TCP发送窗口为0），会将setOpWrite设为true，此时注册写操作位，等待写就绪后再写。</li>
<li>如果写过程中，doWriteBytes()一直可以写入，但是在writeSpinCount次数限制内没有写完所有ByteBuf中的可读数据（可能发送窗口太小，或者发送的数据量太大），那么setOpWrite为false。此时Channel可写，所以不能注册写操作位，需要在EventLoop线程中尝试再发剩余的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一条消息没有写完时被调用</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">incompleteWrite</span><span class="params">(<span class="type">boolean</span> setOpWrite)</span> &#123;</span><br><span class="line">    <span class="comment">// Did not write completely.</span></span><br><span class="line">    <span class="keyword">if</span> (setOpWrite) &#123;</span><br><span class="line">        <span class="comment">// setOpWrite为true，说明写过程中出现了不能写入的情况，注册写操作位，等待写就绪</span></span><br><span class="line">        setOpWrite();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// setOpWrite为false，为了不阻塞其他I/O操作，这里启动一个写任务，交给EventLoop执行</span></span><br><span class="line">        clearOpWrite();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Schedule flush again later so other tasks can be picked up in the meantime</span></span><br><span class="line">        eventLoop().execute(flushTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于向Selector注册OP_WRITE</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setOpWrite</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> selectionKey();</span><br><span class="line">    <span class="keyword">if</span> (!key.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> key.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="number">0</span>) &#123;</span><br><span class="line">        key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractNioMessageChannel</code>的<code>doWrite()</code>方法跟上面的流程很像，具体的写操作<code>doWriteMessage()</code>也是交由子类实现，可以参考<code>NioDatagramChannel</code>&#x2F;<code>NioSctpChannel</code>&#x2F;<code>NioUdtMessageConnectorChannel</code>等子类。</p>
<h3 id="2-4-NioSocketChannel"><a href="#2-4-NioSocketChannel" class="headerlink" title="2.4 NioSocketChannel"></a>2.4 NioSocketChannel</h3><p><code>NioSocketChannel</code>即常用的处理客户端连接的具体<code>Channel</code>实现类。到这一级，一些数据结构的具体类型都已经确定，例如<code>Channel</code>的具体类型<code>SocketChannel</code>，<code>ChannelConfig</code>的具体类型<code>SocketChannelConfig</code>。</p>
<p><code>NioSocketChannel</code>实现或者重写了需要确定类型后才能确定的方法，例如确定了<code>SokcetChannel</code>类型后，用于<code>Channel</code>是否Active的<code>isActive()</code>方法，用于断开连接的<code>doDisconnect()</code>等等方法，实际调用<code>SocketChannel</code>的对应方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> javaChannel();</span><br><span class="line">    <span class="keyword">return</span> ch.isOpen() &amp;&amp; ch.isConnected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个主要方法：连接对端的<code>doConnect()</code>方法，实际写数据的<code>doWrite()</code>方法。</p>
<h4 id="2-4-1-连接"><a href="#2-4-1-连接" class="headerlink" title="2.4.1 连接"></a>2.4.1 连接</h4><p>连接的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel connect() -&gt; DefaultChannelPipeline connect()-&gt; AbstractNioUnsafe connect() -&gt; NioSocketChannel doConnect()</span><br></pre></td></tr></table></figure>

<p><code>doConnect()</code>方法流程：</p>
<ol>
<li>判断本地地址是否为空，如果不为空，先调用<code>doBind0()</code>方法绑定本地地址，底层调用<code>SocketChannel</code>的bind()方法；</li>
<li>连接对端，调用<code>SocketUtils.connect(javaChannel(), remoteAddress)</code>，底层调用<code>SocketChannel</code>的<code>connect()</code>方法。由于<code>Channel</code>是Non-Blocking模式，<code>connect()</code>不会阻塞，返回值可能有3种返回情况： <ul>
<li>返回true，说明连接立刻完成（本地连接） –&gt; 返回成功退出</li>
<li>返回false，发出连接请求，是否连接成功不确定  –&gt; 向<code>Selector</code>注册<code>OP_CONNECT</code>，监听连接事件，然后返回false退出</li>
<li>抛出<code>IOException</code>，说明连接失败  –&gt; 调用<code>doClose()</code>关闭连接</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="literal">null</span>) &#123;     <span class="comment">// 如果未绑定本地地址，需要先绑定</span></span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行真正的connect操作，根据返回值做不同的处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;   <span class="comment">// 连接没有马上成功，需要监听连接网络操作位</span></span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;     <span class="comment">// 连接失败，关闭连接，如果存在异常会抛出异常给上层调用者处理</span></span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-写数据"><a href="#2-4-2-写数据" class="headerlink" title="2.4.2 写数据"></a>2.4.2 写数据</h4><p>写数据的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel flush() -&gt; DefaultChannelPipeline flush() -&gt; ChannelHandler chain -&gt; HeadContext flush() -&gt;  AbstractNioUnsafe flush() -&gt; NioSocketChannel doWrite()</span><br></pre></td></tr></table></figure>

<p><code>doWrite()</code>方法重写了父类<code>AbstractNioByteChannel</code>的方法，流程：</p>
<ol>
<li>从<code>Channel</code>配置中获取写次数限制<code>writeSpinCount</code>，尝试在<code>writeSpinCount</code>次数限制内写完数据；</li>
<li>判断<code>ChannelOutboundBuffer</code>的size，如果为空说明没有数据要写，清除<code>OP_WRITE</code>写操作位，退出；</li>
<li>从<code>ChannelOutboundBuffer</code>中获得NIO <code>ByteBuffer</code>的数组<code>nioBuffers</code>，数目<code>nioBufferCnt</code>和可写字节数<code>expectedWrittenBytes</code>，根据数目<code>nioBufferCnt</code>： <ol>
<li>0：没有可用的<code>ByteBuffer</code>，回退到父类的doWrite0()方法；</li>
<li>1: 只有一个<code>ByteBuffer</code>，可以直接写这一个，用<code>non-gathering</code>模式写，调用<code>SocketChannel</code>的<code>write(ByteBuffer src)</code>方法；</li>
<li>其他：有多于一个<code>ByteBuffer</code>，可以使用<code>SocketChannel</code>的<code>write(ByteBuffer[] srcs, int offset, int length)</code>方法写，提升性能；</li>
</ol>
</li>
<li>从<code>ChannelOutboundBuffer</code>中释放已写的字节数<code>writtenBytes</code>；</li>
<li>如果未写完(done为false)，调用<code>incompleteWrite()</code>方法；</li>
</ol>
<p>写流程与<code>AbstractNioByteChannel</code>的doWrite()方法中的写流程类似，都是在最大循环写次数限制（<code>config().getWriteSpinCount()</code>）内尝试写完所有字节数。如果没有写完或者写过程中发现无法写入，处理流程也与<code>AbstractNioByteChannel</code>类似，都会调用<code>incompleteWrite()</code>方法。</p>
<blockquote>
<p>猜测重写<code>doWrite()</code>方法的目的是为了提升多<code>ByteBuffer</code>写的性能，因为可以使用NIO gathering write。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(ChannelOutboundBuffer in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> javaChannel();</span><br><span class="line">    <span class="type">int</span> <span class="variable">writeSpinCount</span> <span class="operator">=</span> config().getWriteSpinCount();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in.isEmpty()) &#123;	<span class="comment">// 没有可写的ByteBuffer，清除写操作位，直接退出</span></span><br><span class="line">            <span class="comment">// All written so clear OP_WRITE</span></span><br><span class="line">            clearOpWrite();</span><br><span class="line">            <span class="comment">// Directly return here so incompleteWrite(...) is not called.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ByteBuffer的数组、数目，这里有个最大GatheringWrite字节大小的限制，默认Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">// Ensure the pending writes are made of ByteBufs only.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxBytesPerGatheringWrite</span> <span class="operator">=</span> ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();</span><br><span class="line">        ByteBuffer[] nioBuffers = in.nioBuffers(<span class="number">1024</span>, maxBytesPerGatheringWrite);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nioBufferCnt</span> <span class="operator">=</span> in.nioBufferCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (nioBufferCnt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			   <span class="comment">// 使用父类的doWrite0()处理ByteBuffer数目为0的场景</span></span><br><span class="line">                <span class="comment">// We have something else beside ByteBuffers to write so fallback to normal writes.</span></span><br><span class="line">                writeSpinCount -= doWrite0(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="comment">// 只有一个ByteBuffer，所以可以直接写这一个</span></span><br><span class="line">                <span class="comment">// Only one ByteBuf so use non-gathering write</span></span><br><span class="line">                <span class="comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span></span><br><span class="line">                <span class="comment">// to check if the total size of all the buffers is non-zero.</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> nioBuffers[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">attemptedBytes</span> <span class="operator">=</span> buffer.remaining();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">localWrittenBytes</span> <span class="operator">=</span> ch.write(buffer);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;	<span class="comment">// 没有写成功，设置写半包标识，调用incompleteWrite()注册写操作位，等待写就绪</span></span><br><span class="line">                    incompleteWrite(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;              </span><br><span class="line">                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);	<span class="comment">// 动态调整ChannelConfig的maxBytesPerGatheringWrite值，适配OS的SO_SNDBUF改动</span></span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="comment">// 有多个ByteBuffer，那么使用gathering模式写（从多个buffer把数据写入到一个channel中）</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">attemptedBytes</span> <span class="operator">=</span> in.nioBufferSize();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">localWrittenBytes</span> <span class="operator">=</span> ch.write(nioBuffers, <span class="number">0</span>, nioBufferCnt);</span><br><span class="line">                <span class="keyword">if</span> (localWrittenBytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    incompleteWrite(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                adjustMaxBytesPerGatheringWrite((<span class="type">int</span>) attemptedBytes, (<span class="type">int</span>) localWrittenBytes,</span><br><span class="line">                                                maxBytesPerGatheringWrite);</span><br><span class="line">                in.removeBytes(localWrittenBytes);</span><br><span class="line">                --writeSpinCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (writeSpinCount &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    incompleteWrite(writeSpinCount &lt; <span class="number">0</span>);	<span class="comment">// 没有写完时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在NioSocketChannel中也定义了通用的读写数据方法：</p>
<ul>
<li>将数据从Channel读到ByteBuf的doReadBytes()方法，会在父类AbstractNioByteChannel实现的read()方法里被调用；</li>
<li>将数据从ByteBuf写到Channel的doWriteBytes()方法，会在父类AbstractNioByteChannel实现的doWrite()方法里被调用；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doWriteBytes</span><span class="params">(ByteBuf buf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedWrittenBytes</span> <span class="operator">=</span> buf.readableBytes();</span><br><span class="line">    <span class="keyword">return</span> buf.readBytes(javaChannel(), expectedWrittenBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-NioServerSocketChannel"><a href="#2-5-NioServerSocketChannel" class="headerlink" title="2.5 NioServerSocketChannel"></a>2.5 NioServerSocketChannel</h3><p><code>NioServerSocketChannel</code>相对比较简单。主要的API即实现具体服务端接收客户端相关功能的API：</p>
<ol>
<li><code>isActive()</code>、<code>doBind()</code>、<code>doClose()</code>等，直接调用JDK <code>Channel</code>的API实现； </li>
<li>作为服务端不支持的操作，直接抛出<code>UnsupportedOperationException</code>，例如<code>doConnect()</code>、<code>doDisconnect()</code>等； </li>
<li>接收客户端连接API <code>doReadMessages()</code>； <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 调用底层ServerSocketChannel的accept()方法监听客户端连接</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有可用的客户端连接，那么创建一个NioSocketChannel对象封装</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> <span class="title class_">NioSocketChannel</span>(<span class="built_in">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failed to close a socket.&quot;</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-Unsafe接口和子类"><a href="#3-Unsafe接口和子类" class="headerlink" title="3 Unsafe接口和子类"></a>3 Unsafe接口和子类</h2><p><code>Unsafe</code>接口是<code>Channel</code>接口的辅助接口，在<code>Channel</code>的子类实现里，也带了<code>Unsafe</code>接口的子类实现，例如<code>AbstractUnsafe</code>。</p>
<p>与<code>Channel</code>的类继承图一样，NIO部分的<code>Unsafe</code>的继承树主干是这样的：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnHfRA0obWkymAyt1Fhif5MDHp9f.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FnHfRA0obWkymAyt1Fhif5MDHp9f.png"  lazyload></a></p>
<p><code>Unsafe</code>接口命名与JUC里的<code>Unsafe</code>有点像，都不是给用户直接调用的。<code>Channel</code>接口的I&#x2F;O方法调用<code>ChannelPipeline</code>的I&#x2F;O方法，进一步调用<code>Unsafe</code>的方法触发I&#x2F;O操作，做一些状态检查、设置状态之类的通用操作，里面进一步调用具体<code>Channel</code>类的<code>doXXX()</code>方法。流程大体上相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Channel I/O func --&gt; ChannelPipeline I/O func --&gt; Unsafe I/O func --&gt; Channel(Detailed) I/O func</span><br></pre></td></tr></table></figure>

<p><code>Unsafe</code>中的I&#x2F;O方法的大体流程：</p>
<ol>
<li>检查状态，确定要执行的I&#x2F;O操作可以进行，例如<code>deregister()</code>时确定已经register过；</li>
<li>调用<code>doXXX()</code>方法进行真正的I&#x2F;O操作，<code>doXXX()</code>方法的具体实现跟具体的功能子类相关；</li>
<li>设置状态，例如register后设置registered &#x3D; true；</li>
<li>如果有必要，调用<code>ChannelPipeline</code>的<code>fireXXX()</code>方法，通知<code>Channel</code>上的<code>ChannelHandler</code>；</li>
</ol>
<p>以register()为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 做一些状态检查，例如要注册的eventLoop是否为空，是否已经注册过，是否适配等等</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在eventLoop中则直接注册，否则丢给eventLoop去execute，保证在对应线程内处理</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                AbstractChannel.<span class="built_in">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查channel状态</span></span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// 真正的注册操作，交给具体的子类实现</span></span><br><span class="line">        doRegister();</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        <span class="comment">// 调用ChannelPipleline的fireChannelRegistered()方法，通知</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;	<span class="comment">// 如果初次register并且已经active，调用pipeline的fireChannelActive()方法通知</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h2><p>Channel接口及其子类的源码可以与I&#x2F;O操作的流程结合起来看，会理解的比较深刻一些。</p>
<h1 id="四-参考资料"><a href="#四-参考资料" class="headerlink" title="四 参考资料"></a>四 参考资料</h1><ol>
<li>Netty权威指南 第二版 by 李林峰</li>
<li>Netty in Action</li>
<li>Netty源码 4.1.27.Final</li>
</ol>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%B8%80-%E6%A6%82%E8%BF%B0"><span class="top-box-text">一 概述</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%BA%8C-%E5%8E%9F%E7%90%86"><span class="top-box-text">二 原理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="top-box-text">工作流程</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#Channel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="top-box-text">Channel生命周期</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="top-box-text">主要方法</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="top-box-text">主要实现类</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%B8%89-%E6%BA%90%E7%A0%81"><span class="top-box-text">三 源码</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-Channel%E6%8E%A5%E5%8F%A3"><span class="top-box-text">1. Channel接口</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-Channel%E5%AD%90%E7%B1%BB"><span class="top-box-text">2. Channel子类</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-1-AbstractChannel"><span class="top-box-text">2.1 AbstractChannel</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-2-AbstractNioChannel"><span class="top-box-text">2.2 AbstractNioChannel</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-3-AbstractNioByteChannel-x2F-AbstractNioMessageChannel"><span class="top-box-text">2.3 AbstractNioByteChannel&#x2F;AbstractNioMessageChannel</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-4-NioSocketChannel"><span class="top-box-text">2.4 NioSocketChannel</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-5-NioServerSocketChannel"><span class="top-box-text">2.5 NioServerSocketChannel</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-Unsafe%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="top-box-text">3 Unsafe接口和子类</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#4-%E5%85%B6%E4%BB%96"><span class="top-box-text">4 其他</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%9B%9B-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="top-box-text">四 参考资料</span></a></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2019/02/13/xin-ye-wu-de-tong-yi-yi-chang-chu-li-shi-jian/">
          <h3 class="post-title">
            下一篇：新业务的统一异常处理实践
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


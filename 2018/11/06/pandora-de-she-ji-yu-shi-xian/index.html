<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Pandora的设计与实现</title>
<meta name="keywords" content="Pandora的设计与实现, jffu&#39;s blog">
<meta name="description" content="Pandora容器的设计与实现">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Pandora的设计与实现">
<meta property="og:description" content="Pandora容器的设计与实现">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Pandora的设计与实现</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2018-11-06</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
                  ，
                
              </a>
            
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">
              中间件
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>Pandora作为轻量级隔离容器，解决两种类冲突：</p>
<ul>
<li>中间件与中间件之间</li>
<li>中间件与应用之间</li>
</ul>
<p>参考<a target="_blank" rel="noopener" href="http://gitlab.alibaba-inc.com/middleware-container/pandora/wikis/home">Pandora的Wiki</a>。</p>
<blockquote>
<p><strong>依赖隔离：</strong> 能够隔离<code>中间件与应用</code>、<code>中间件与中间件</code>之间的隔离，让其相互之间互不影响</p>
<p><strong>部署隔离：</strong> 部署和应用分离，中间件升级相对于应用透明</p>
</blockquote>
<p>在Pandora的基础上延伸出 <strong>taobao-hsf.sar</strong>，将Pandora容器和中间件插件结合在一起。</p>
<blockquote>
<p> <strong>Sar包 &#x3D; Pandora容器 + 中间件插件</strong></p>
</blockquote>
<h1 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2 类加载器"></a>2 类加载器</h1><p>解决类冲突的思路第一想法都是使用Java类机制，类加载器+全类名&#x3D;类型实例的方式唯一确定一个类的方式来做。即打破双亲委派，使用不同的<code>ClassLoader</code>来独立加载中间件和应用的类以达到隔离的目的。</p>
<p>在Pandora中为了实现不同组件（应用、Pandora自身、其他中间件）间的隔离，使用了3类<code>ClassLoader</code>：</p>
<ul>
<li><strong>ModuleClassLoader</strong>：每个中间件插件有一个独有的<code>ModuleClassLoader</code>加载中间件自身的类，实现中间件与中间件之间的隔离；<ul>
<li>类加载路径为插件路径下的lib目录</li>
<li>加载逻辑参考<a target="_blank" rel="noopener" href="http://gitlab.alibaba-inc.com/middleware-container/pandora/wikis/v2_1_3/classloaders-in-pandora">Pandora容器中的类加载器</a></li>
</ul>
</li>
<li><strong>PandoraClassLoader</strong>：使用一个专门的<code>PandoraClassLoader</code>加载Pandora自身的类，实现<code>Pandora</code>本身与其他中间件和应用之间的隔离；<ul>
<li>加载包括<code>PandoraContainer</code>在内的sar包lib目录下jar包中的类</li>
<li>实际上就是一个parent为<code>ExtClassLoader</code>的<code>URLClassLoader</code></li>
</ul>
</li>
<li><strong>bizClassLoader</strong>：使用一个<code>bizClassLoader</code>加载应用本身的类；</li>
</ul>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="http://aligitlab.oss-cn-hangzhou-zmf.aliyuncs.com/uploads/middleware-container/pandora/f1134e3e590486e39c38967733831101/classloader_structure.png"><img   src="/images/loading.svg" data-src="http://aligitlab.oss-cn-hangzhou-zmf.aliyuncs.com/uploads/middleware-container/pandora/f1134e3e590486e39c38967733831101/classloader_structure.png"  lazyload></a></p>
<blockquote>
<p>注：在使用IDE启动Pandora Boot启动时，没有看到PandoraClientFactory出现，应该是启动Pandora容器方式不同导致</p>
</blockquote>
<p>跟踪Pandora Boot的启动流程，能发现每个ClassLoader的创建和使用时机：</p>
<ol>
<li><p>首先创建一个<code>ReLaunchURLClassLoader</code>（对应IDE启动，FatJar会启动<code>SarLauncher</code>，对应<code>LaunchedURLClassLoader</code>，原理一致）作为<code>bizClassLoader</code>，它有几个特性来保证类隔离：</p>
<ul>
<li><p><code>ReLaunchURLClassLoader</code>的parent被设置为<code>ext classloader</code>，因此避免了使用<code>SystemClassLoader</code>来加载类；</p>
</li>
<li><p><code>ReLaunchURLClassLoader</code>会被用来重新加载<code>main</code>方法所在的类（一般就是<code>Application</code>类），然后反射调用<code>main</code>方法，因此**在后面程序运行时，加载应用自身的类用的<code>ClassLoader</code>不再是普通的<code>AppClassLoader</code>，而是<code>ReLaunchURLClassLoader</code>**；</p>
</li>
<li><p><code>ReLaunchURLClassLoader</code>重写了<code>loadClass</code>方法，它使用一个<code>classCache</code>的Map缓存了中间件导出的类（被<code>ModuleClassLoader</code>加载）。应用中碰到需要加载中间件的类时，会优先从<code>classCache</code>中查找并返回（而不会再由当前应用的classLoader）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ReLaunchURLClassLoader.LOCK_PROVIDER.getLock(<span class="built_in">this</span>, name)) &#123;</span><br><span class="line">        <span class="comment">// 优先从classCache中加载插件导出的类</span></span><br><span class="line">        <span class="keyword">if</span> (classCache != <span class="literal">null</span> &amp;&amp; classCache.containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> classCache.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            Handler.setUseFastConnectionExceptions(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loadedClass = doLoadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                Handler.setUseFastConnectionExceptions(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(loadedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.recordClass(loadedClass);</span><br><span class="line">        <span class="keyword">return</span> loadedClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建一个<code>URLClassLoader</code>作为<code>PandoraClassLoader</code></p>
<ul>
<li>被用来加载Pandora容器类<code>PandoraContainer</code>，得到class对象后，进行反射构造和调用Pandora容器的初始化方法<code>PandoraContainer#start</code></li>
</ul>
</li>
<li><p>在<code>PandoraContainer</code>的<code>Pipeline</code>执行过程中，通过部署服务<code>DeployService</code>，对每个插件构造<code>ModuleClassLoader</code>，然后通过类导出服务<code>ClassExporter</code>使用<code>ModuleClassLoader</code>加载需要导出的类</p>
</li>
</ol>
<p>原有的类冲突在这种机制下如何得到解决？</p>
<ol>
<li><p>中间件与中间件之间的类冲突</p>
<blockquote>
<p>例子：原先两个中间件都依赖了不同版本的xx.jar中的A.class，中间件1依赖xx-1.0.0.jar，中间件2依赖xx-2.0.0.jar，如果没有类隔离，那么只有一个版本的A.class会被加载。</p>
</blockquote>
<p>引入Pandora后，两个中间件插件的lib目录下都有对应版本的xx.jar，会被各自的<code>ModuleClassLoader</code>加载，实际元空间中会有两种类型的A.class。</p>
</li>
<li><p>中间件与应用之间的类冲突</p>
<p>同理，如果中间件和应用都依赖了不同版本的xx.jar中的B.class，在中间件使用时，会使用<code>ModuleClassLoader</code>从插件lib下加载中间件依赖的xx.jar（例如1.0.0）中的B.class；而应用则会用<code>bizClassLoader</code>加载应用自身依赖的版本。</p>
</li>
</ol>
<h1 id="3-Pandora框架"><a href="#3-Pandora框架" class="headerlink" title="3 Pandora框架"></a>3 Pandora框架</h1><h2 id="3-1-流水线Pipeline"><a href="#3-1-流水线Pipeline" class="headerlink" title="3.1 流水线Pipeline"></a>3.1 流水线Pipeline</h2><p>Pandora容器框架的设计使用了流水线设计模式，这种设计模式类似于责任链模式，在很多框架代码中能够看到，其最大的优点就是可扩展性。</p>
<p>整个框架由<code>Pipeline</code>、<code>Stage</code>、<code>Service</code>构成。</p>
<ul>
<li><code>Pipeline</code>表示流水线，由一组<code>StageNode</code>节点串联构成，每一个<code>StageNode</code>对象持有<code>Stage</code>对象引用和前后<code>StageNode</code>对象的引用；</li>
<li>Pandora的内部组件通过实现<code>Stage</code>接口将自己添加到<code>Pipeline</code>中，通过配置文件<code>pipeline.properties</code>来控制需要加载的<code>Stage</code>和顺序；</li>
<li>Pandora容器启动时，会初始化和执行<code>Pipeline</code>，<code>Pipeline</code>上的每个<code>Stage</code>得以被执行其<code>stepIn()</code>和<code>stepOut</code>方法，通过这种类似过滤器执行的方式，每个<code>Stage</code>完成自身的业务逻辑；</li>
<li>Pandora容器依赖于<code>Service</code>提供的服务能力，<code>Service</code>被注册到轻量级IOC容器<code>ServiceContainer</code>，每个<code>Stage</code>会调用不同的<code>Service</code>实现逻辑；</li>
</ul>
<p>总体结构参考下图：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fg6vWzU-rZ9KAXeSy8CAgTIzVyv6.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fg6vWzU-rZ9KAXeSy8CAgTIzVyv6.png"  lazyload></a></p>
<h2 id="3-2-服务容器"><a href="#3-2-服务容器" class="headerlink" title="3.2 服务容器"></a>3.2 服务容器</h2><p>Pandora使用了一个轻量级的IOC容器<code>ServiceContainer</code>，底层基于<code>PicoContainer</code>提供的能力，为<code>Service</code>提供生命周期管理服务。</p>
<p>Pandora提供的<code>Service</code>都是单例的，参考：</p>
<blockquote>
<p>（1） Pipeline服务：框架管道服务定义。<br>（2） DeployService服务：插件部署服务。<br>（3） PluginModuleFactory服务：插件加载服务，为插件文件生成PluginModule实例。<br>（4） ClassLoaderService服务：类加载器服务，提供创建模块类加载器、利用实例获取模块、获取SharedClassService等功能。<br>（5） SharedClassService服务：缓存所有插件export的类。<br>（6） HostInfoService服务：系统信息。<br>（7） Context服务：上下文，提供获取框架服务、模块功能。<br>（8） InitializerChecker服务：模块初始化服务。<br>（9） ClassExporter服务：实现将插件export的类注册到SharedClassService。<br>（10）LifecycleService服务：管理生命周期监听器等。<br>（11）PandoraServiceManager服务：管理所有插件的激活器。<br>（12）RegistryService服务：插件服务注册表，插件间服务通讯。</p>
</blockquote>
<h1 id="4-Pandora插件"><a href="#4-Pandora插件" class="headerlink" title="4 Pandora插件"></a>4 Pandora插件</h1><p>中间件以插件的形式被加载到Pandora容器中。<code>taobao-hsf.sar </code>中整合Pandora容器和一堆插件。目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── lib			# 1. Pandora容器自身的依赖，被PandoraClassLoader加载</span><br><span class="line">│   ├── commons-lang-2.6.jar等</span><br><span class="line">├── log.properties</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── jboss-service.xml</span><br><span class="line">├── plugins		# 2. 各个中间件的插件，每个都会被独立的ModuleClassLoader加载，达到隔离目的</span><br><span class="line">│   ├── 插件，hsf等</span><br><span class="line">│   │   ├── com</span><br><span class="line">│   │   │   └── taobao</span><br><span class="line">│   │   │       └── pandora</span><br><span class="line">│   │   │           └── plugin.guide.properties	# Pandora通过判断这个文件来获知插件URL</span><br><span class="line">│   │   ├── conf # 插件的配置</span><br><span class="line">│   │   │   ├── export.index		# 导出类的索引，用于快速导出类</span><br><span class="line">│   │   │   ├── export.properties	# 导出类的配置</span><br><span class="line">│   │   │   ├── import.properties	# 导入类的配置</span><br><span class="line">│   │   │   ├── priority.properties # 启动优先级定义，定义插件启动顺序，数字越大优先级越低 </span><br><span class="line">│   │   │   └── listener.properties # 声明生命周期监听器，监听Pandora容器和应用发出的生命周期事件 </span><br><span class="line">│   │   │   └── service.properties  # 声明插件服务，会被容器加载并执行init/start</span><br><span class="line">│   │   │   └── initializer.properties # 插件初始化类定义，判断插件是否可以被启动</span><br><span class="line">│   │   ├── lib	# 中间件插件的依赖，会被独立的ModuleClassLoader加载</span><br><span class="line">│   │   │   ├── hsf-all-2.2.5.7.jar</span><br><span class="line">│   │   │   ├── ...</span><br><span class="line">│   │   └── version.properties # 插件的版本信息</span><br><span class="line">├── sharedlib	# 3. 一些基础依赖，例如spring等</span><br><span class="line">│   ├── aopalliance-1.0.jar/spring-beans...等</span><br><span class="line">└── version.properties	# 4. 记录每个中间件的版本信息</span><br></pre></td></tr></table></figure>

<p>几个关键的lib目录：</p>
<ul>
<li><code>lib</code>：Pandora容器自身的依赖，使用<code>PandoraClassLoader</code>加载，实现与中间件和应用的隔离</li>
<li><code>plugins/**/lib</code>：每个插件的依赖，使用独立的<code>ModuleClassLoader</code>加载，实现与其他中间件&#x2F;Pandora容器以及应用间的隔离</li>
<li><code>sharedlib</code>：共享依赖</li>
</ul>
<p>几个关键的配置文件：</p>
<ul>
<li><code>export.index</code>：导出类的索引，由pandora maven plugin生成，如果有这个文件，<code>ClassExporter</code>会优先读取这里面的类，能够加载到时不会再去读取<code>export.properties</code></li>
<li><code>export.properties</code>：导出类的配置，可以定义package&#x2F;jar&#x2F;class，在没有<code>export.index</code>时被扫描用来加载导出类</li>
<li><code>import.properties</code>：导入类的配置，这里的导入类指的插件是否引用<code>bizClassLoader</code>的类型。在<code>ModuleClassLoader</code>加载类时，有一步就是根据<code>import.properties</code>的配置判断是否从<code>bizClassLoader</code>中加载</li>
</ul>
<h1 id="5-思考"><a href="#5-思考" class="headerlink" title="5 思考"></a>5 思考</h1><p>Pandora在实现类隔离的同时会增大程序的内存空间占用，主要的原因在于：</p>
<ol>
<li><p>同一个类可能会由多个ClassLoader进行加载，例如多个中间件同时依赖的某个类，由于中间件之间的隔离，会被每个插件的<code>ModuleClassLoader</code>同时加载；</p>
</li>
<li><p>Pandora容器启动时就会预加载每个插件需要导出的类，需要调大<code>-XX:MetaspaceSize</code>值，以避免启动时Pandora加载类超出设置值触发Full GC；</p>
<p>Pandora提供了懒加载机制来加快程序启动速度和减小启动时加载的内存占用。</p>
</li>
</ol>
<p>基于以上原因，Pandora建议应用程序设置较大的MetaSpace大小（对于Java8以下的版本，则是PermGen）。</p>
<blockquote>
<ul>
<li><strong>JDK7, JDK6: -XX:PermSize&#x3D;512m -XX:MaxPermSize&#x3D;512m</strong></li>
<li><strong>JDK8: -XX:MetaspaceSize&#x3D;512m -XX:MaxMetaspaceSize&#x3D;512m</strong></li>
</ul>
</blockquote>
<h1 id="6-代码实现-概述"><a href="#6-代码实现-概述" class="headerlink" title="6 代码实现 - 概述"></a>6 代码实现 - 概述</h1><p>Pandora在代码实现上，可以分为两部分：</p>
<ul>
<li>Pandora Boot的启动，为Pandora容器启动做准备</li>
<li>Pandora容器的启动，加载插件，导出类等一系列任务</li>
</ul>
<h1 id="7-Pandora-Boot-启动"><a href="#7-Pandora-Boot-启动" class="headerlink" title="7 Pandora Boot 启动"></a>7 Pandora Boot 启动</h1><p>在Pandora Boot生成的启动类<code>Application</code>中，<code>main()</code>方法的第一句就用于启动Pandora Boot。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 启动Pandora Boot</span></span><br><span class="line">        PandoraBootstrap.run(args);</span><br><span class="line">        <span class="comment">// 2. 启动Spring Boot</span></span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">        <span class="comment">// 3. 标记Pandora Boot启动完成并等待</span></span><br><span class="line">        PandoraBootstrap.markStartupAndWait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-1-基本流程"><a href="#7-1-基本流程" class="headerlink" title="7.1 基本流程"></a>7.1 基本流程</h2><ol>
<li>一些准备工作，例如设置属性，进行autoconfig等；</li>
<li><strong>关键步骤</strong>：<code>ReLaunchMainLauncher#launch</code>用于加载Pandora容器和插件；</li>
</ol>
<p><code>ReLaunchMainLauncher#launch</code>是<strong>Pandora Boot启动的关键</strong>。</p>
<ol>
<li><code>ReLaunchMainLauncher#createClassLoader</code>构造一个<code>ReLaunchURLClassLoader</code>，即Pandora类加载器结构中的<code>bizClassLoader</code>，用于加载应用类；<ul>
<li>在后续第5步时会使用<code>ReLaunchURLClassLoader</code>重新加载和启动<code>main()</code>方法，使得应用类会使用<code>ReLaunchURLClassLoader</code>进行加载，后续在应用中如果使用到中间件的类，因为<code>bizClassLoader</code>的特性，会优先从插件的导出类缓存，即<code>classCache</code>中查找</li>
</ul>
</li>
<li>构造一个<code>URLClassLoader</code>，即Pandora类加载器结构中的<code>PandoraClassLoader</code>，用于加载Pandora容器自身的类；</li>
<li>使用<code>PandoraClassLoader</code>加载类<code>com.taobao.pandora.PandoraContainer</code>并反射调用其<code>start()</code>方法来启动Pandora容器；</li>
<li>通过<code>PandoraContainer#getExportedClasses</code>获得插件需要导出的类，作为<code>reLaunchClassLoader</code>的<code>classCache</code></li>
<li>启动新线程，使用<code>reLaunchClassLoader</code>加载和启动<code>Application#main</code>，并等待新的main函数线程退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动Pandora。通常在应用的main函数的第一行调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> *            应用main函数的args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个判断会保证再次启动main时，return出去，避免死循环</span></span><br><span class="line">    <span class="keyword">if</span> (SarLoaderUtils.unneedLoadSar()) &#123;</span><br><span class="line">        LogConfigUtil.initLoggingSystem();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得当前类加载器的所有URL，一般就是AppClassLoader</span></span><br><span class="line">    URL[] urls = ClassLoaderUtils.getUrls(PandoraBootstrap.class.getClassLoader());</span><br><span class="line">    <span class="keyword">if</span> (urls == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can not find urls from the ClassLoader of PandoraBootstrap. ClassLoader: &quot;</span></span><br><span class="line">                + PandoraBootstrap.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造了一个AutoConfigWrapperClassLoader，URL只包含autoconf.jar和pandora-boot-autoconf.jar</span></span><br><span class="line">    <span class="comment">// 通过反射调用Autoconfigure#config进行autoconfig</span></span><br><span class="line">    urls = AutoConfigWrapper.autoConfig(urls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键步骤：ReLaunchMainLauncher#launch</span></span><br><span class="line">    ReLaunchMainLauncher.launch(args, deduceMainApplicationClass().getName(), urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>流程示意图：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpRe76F69KK2LaKQ-XRzINZ9xU_q.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpRe76F69KK2LaKQ-XRzINZ9xU_q.png"  lazyload></a></p>
<h2 id="7-2-ReLaunchMainLauncher-launch"><a href="#7-2-ReLaunchMainLauncher-launch" class="headerlink" title="7.2 ReLaunchMainLauncher#launch"></a>7.2 <code>ReLaunchMainLauncher#launch</code></h2><p><code>ReLaunchMainLauncher#launch</code>是Pandora Boot启动的关键方法，主要完成：</p>
<ol>
<li><code>createClassLoader()</code>：创建<code>ReLaunchURLClassLoader</code>和<code>PandoraClassLoader</code>，后者用于加载和启动Pandora容器。</li>
<li><code>reLaunch()</code>：新线程使用<code>ReLaunchURLClassLoader</code>启动main函数，并等待新的main函数线程退出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args, String mainClass, URL[] urls)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reLaunch 里以一个新线程，新classloader启动main函数，并等待新的main函数线程退出</span></span><br><span class="line">    reLaunch(args, mainClass, createClassLoader(urls));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里，新启动的main线程已经退出了，可以直接退出进程</span></span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-ReLaunchMainLauncher-createClassLoader"><a href="#7-3-ReLaunchMainLauncher-createClassLoader" class="headerlink" title="7.3 ReLaunchMainLauncher#createClassLoader"></a>7.3 <code>ReLaunchMainLauncher#createClassLoader</code></h2><p><code>ReLaunchMainLauncher#createClassLoader</code>中构造了Pandora三大类加载器的两种：</p>
<ul>
<li><code>bizClassLoader</code>：<code>ReLaunchURLClassLoader</code>，返回给上层用于加载main函数</li>
<li><code>pandoraClassLoader</code>：加载Pandora容器<code>PandoraContainer</code></li>
</ul>
<p>其中<code>pandoraClassLoader</code>的构造在<code>SarLoaderUtils#getClassCache</code>中完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ClassLoader <span class="title function_">createClassLoader</span><span class="params">(URL[] urls)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    Health.registMBean();</span><br><span class="line">    SystemPrintUtil.switchSystemPrint();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent设置为ext classloader，避免某些情况下应用向上查找parent，利用parent来加载资源，从而利用到SystemClassLoader 来加载类</span></span><br><span class="line">    <span class="type">ReLaunchURLClassLoader</span> <span class="variable">reLaunchClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReLaunchURLClassLoader</span>(cleanJavaAgentUrls(urls),</span><br><span class="line">            ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Archive</span> <span class="variable">sar</span> <span class="operator">=</span> SarLoaderUtils.findExternalSar();</span><br><span class="line">        <span class="keyword">if</span> (sar == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 内部新建了一个classloader，通过getResource找到com/taobao/pandora/guide.properties资源所在的jar包，从而定位到sar，如果存在多个资源路径会报错</span></span><br><span class="line">            sar = SarLoaderUtils.findFromClassPath(urls);</span><br><span class="line">            <span class="keyword">if</span> (sar == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getProperty(Constants.FAILFAST_PROPERTY_KEY))) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can not load taobao-hsf.sar, please check your config!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                AnsiLog.error(<span class="string">&quot;Can not load taobao-hsf.sar! If you do not use taobao-hsf.sar, ignore this. &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Otherwise please check &#x27;-Dpandora.location=&#x27; or maven dependencies if there contains taobao-hsf.sar!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sar != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键步骤</span></span><br><span class="line">            Map&lt;String, Class&lt;?&gt;&gt; classCache = SarLoaderUtils.getClassCache(sar, reLaunchClassLoader);</span><br><span class="line">            reLaunchClassLoader.setClassCache(classCache);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记pandora已经启动</span></span><br><span class="line">        SarLoaderUtils.markSarLoaderUtils(reLaunchClassLoader, <span class="string">&quot;sarLoaded&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        SarLoaderUtils.markSarLoaderUtils(reLaunchClassLoader, <span class="string">&quot;t1&quot;</span>, t1);</span><br><span class="line">        <span class="comment">// collect class info</span></span><br><span class="line">        reLaunchClassLoader.collectStaticClassInfo();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;load pandora error!&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reLaunchClassLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-4-SarLoaderUtils-getClassCache"><a href="#7-4-SarLoaderUtils-getClassCache" class="headerlink" title="7.4 SarLoaderUtils#getClassCache"></a>7.4 <code>SarLoaderUtils#getClassCache</code></h2><p><code>SarLoaderUtils#getClassCache</code>是Pandora Boot启动的核心，它完成了几步：</p>
<ol>
<li><p>sar包插件jar和sar包lib下jar的查找；</p>
<ul>
<li><p>通过从bizClassLoader加载的URL中获取资源<code>com/taobao/pandora/plugin.guide.properties</code>来定位到插件，<code>plugin.guide.properties</code>文件中包含了插件的version和artifactId。一个示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Mon Aug 27 11:34:33 CST 2018</span></span><br><span class="line"><span class="attr">version</span>=<span class="string">3.8.11</span></span><br><span class="line"><span class="attr">artifactId</span>=<span class="string">diamond-client</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过查找sar包中以<code>lib/</code>目录开头的jar包定位lib下的jar包，这些是Pandora容器自身依赖的jar</p>
</li>
</ul>
</li>
<li><p>构造一个<code>URLClassLoader</code>作为<code>PandoraClassLoader</code>，加载类<code>PandoraContainer</code>；</p>
</li>
<li><p>构造<code>PandoraContainer</code>并调用<code>PandoraContainer#start</code>，完成Pandora容器的启动；</p>
</li>
<li><p>调用<code>PandoraContainer#getExportedClasses</code>获得每个插件需要导出的类，后面会设置到<code>ReLaunchURLClassLoader</code>的<code>classCache</code>中；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从bizClassLoader 里查找到所有的pandora plugin jar。 从sar包里查找lib目录下的jar，并构造 PandoraContainer，</span></span><br><span class="line"><span class="comment"> * 再返回 exportedClasses 缓存。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 在构建PandoraContainer，获取导出类cache时，会调用这个构造函数：</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> public PandoraContainer(URL containerUrl, URL[] pluginUrls, ClassLoader bizClassLoader)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * pluginUrls 的组装过程：</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;首先从指定的 SAR 包中查找插件。SAR 包可能是内置在 fat jar 中，也有可能是外置，由 &#123;<span class="doctag">@code</span> -Dpandora.location&#125; 指定&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;然后在应用的 fat jar 中查找打包的插件，并与 SAR 包中查找到的插件做合并。合并的规则是如果 SAR 包中有，则忽略，否则就增加&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;如果要忽略合并，也就是只使用外置 SAR 中搭载的插件，可以通过指定 &#123;<span class="doctag">@code</span> -Dpandora.ignore.packaged.plugins=true&#125; 来改变默认的合并规则，当然在这种情况下，是需要同时指定 &#123;<span class="doctag">@code</span> -Dpandora.location=外置 SAR 包位置&#125; 的。&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.taobao.pandora.PandoraContainer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Constants#IGNORE_PACKAGED_PLUGINS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Constants#PANDORA_LOCATION</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; getClassCache(Archive sar, ClassLoader bizClassLoader) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 保证monitor插件可以处理 jar in jar的url</span></span><br><span class="line">    com.taobao.pandora.loader.jar.JarFile.registerUrlProtocolHandler();</span><br><span class="line">    printBanner(bizClassLoader);</span><br><span class="line">    configHostType();</span><br><span class="line">    configTddlVersionCheck();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1 查找sar包中的插件</span></span><br><span class="line">    Map&lt;String, Archive&gt; pluginsFromSar = loadPlugins(sar);</span><br><span class="line">    List&lt;URL&gt; pluginJarUrls = Collections.emptyList();</span><br><span class="line">    <span class="keyword">if</span> (!ignorePackagedPlugins()) &#123;</span><br><span class="line">        <span class="comment">// 从bizClassLoader里查找所有的plugin jar，并获取它们的url</span></span><br><span class="line">        pluginJarUrls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;URL&gt;();</span><br><span class="line">        <span class="comment">// 通过寻找有资源文件com/taobao/pandora/plugin.guide.properties的jar包来定位到sar包的插件</span></span><br><span class="line">        Enumeration&lt;URL&gt; pluginPropertiesResources = bizClassLoader.getResources(PLUGIN_GUIDE_PROPERTIES);</span><br><span class="line">        <span class="keyword">while</span> (pluginPropertiesResources.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">guidePropertiesUrl</span> <span class="operator">=</span> pluginPropertiesResources.nextElement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">pluginArtifactId</span> <span class="operator">=</span> readPluginArtifactId(guidePropertiesUrl);</span><br><span class="line">            <span class="comment">// 在sar包里不存在的plugin加到pluginJarUrls里</span></span><br><span class="line">            <span class="keyword">if</span> (pluginArtifactId != <span class="literal">null</span> &amp;&amp; !pluginsFromSar.containsKey(pluginArtifactId)) &#123;</span><br><span class="line">                pluginJarUrls.add(ArchiveUtils.createArchiveFromUrl(guidePropertiesUrl).getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 查找sar包中的lib下的jar包</span></span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> sar.getUrl();</span><br><span class="line">    List&lt;Archive&gt; jars = sar.getNestedArchives(<span class="keyword">new</span> <span class="title class_">Archive</span>.EntryFilter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Archive.Entry entry)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">entryName</span> <span class="operator">=</span> entry.getName();</span><br><span class="line">            <span class="comment">// 排除掉隐藏目录</span></span><br><span class="line">            <span class="keyword">if</span> (entryName.length() &gt; LIB.length() &amp;&amp; entryName.charAt(LIB.length()) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;entryName is a hidden directory in sar, ignore: &quot;</span> + entryName);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !entry.isDirectory() &amp;&amp; entryName.startsWith(LIB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    URL[] urls = <span class="keyword">new</span> <span class="title class_">URL</span>[jars.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; jars.size(); i++) &#123;</span><br><span class="line">        urls[i] = jars.get(i).getUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 构造一个ClassLoader用于加载Pandora自身的类，与其他隔离</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(urls, ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultInitOverride</span> <span class="operator">=</span> System.getProperty(LOG4J_DEFAULTINITOVERRIDE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultInitOverride == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Set log4j.defaultInitOverride to true.&quot;</span>);</span><br><span class="line">        System.setProperty(LOG4J_DEFAULTINITOVERRIDE, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL[] pluginUrls = pluginJarUrls.toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[pluginJarUrls.size()]);</span><br><span class="line">        <span class="comment">// 2.2 加载并构造PandoraContainer类</span></span><br><span class="line">        Class&lt;?&gt; pandora = classLoader.loadClass(<span class="string">&quot;com.taobao.pandora.PandoraContainer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(pandora.getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; constructor = pandora.getConstructor(URL.class, URL[].class, ClassLoader.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance(url, pluginUrls, bizClassLoader);</span><br><span class="line">        <span class="comment">// 3 通过反射创建实例并执行start方法</span></span><br><span class="line">        invokeStart(instance);</span><br><span class="line"></span><br><span class="line">        checkFileDescriptorCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 执行PandoraContainer#getExportedClasses方法获得导出类</span></span><br><span class="line">        <span class="keyword">return</span> invokeGetExportedClasses(instance);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(contextClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-Pandora容器启动"><a href="#8-Pandora容器启动" class="headerlink" title="8 Pandora容器启动"></a>8 Pandora容器启动</h1><p>Pandora容器的启动过程主要可以分为几个阶段：</p>
<ol>
<li><code>PandoraContainer</code>的构造：完成基本的构造</li>
<li><code>Pipeline</code>初始化：完成<code>Pipeline</code>节点<code>Stage</code>的初始化和串联</li>
<li><code>Pipeline</code>执行：执行每个<code>Stage</code>的<code>Stage#in</code>和<code>Stage#out</code>，完成插件部署、类导出、服务初始化和启动等工作</li>
</ol>
<h2 id="8-1-主要类"><a href="#8-1-主要类" class="headerlink" title="8.1 主要类"></a>8.1 主要类</h2><ol>
<li><code>ServiceContainer</code></li>
</ol>
<p>  使用<code>PicoContainer</code>作为轻量级的IOC容器，提供Pandora内部服务的生命周期管理。</p>
<ol start="2">
<li><code>Pipeline</code></li>
</ol>
<p>  流水线，控制Pandora容器以及插件的生命周期。</p>
<p>  <code>Pipeline</code>中的节点是<code>StageNode</code>对象，封装了<code>Stage</code>对象和前后<code>StageNode</code>的引用。</p>
<ol start="3">
<li><p><code>Stage</code></p>
<p>流水线上执行任务用的节点。Pandora内置了一系列实现了<code>Stage</code>接口的类用于完成Pandora容器的插件部署、相应的类导出及服务的启动等工作。</p>
<p>包含<code>Stage#in</code>和<code>Stage#out</code>两个主要方法，会在<code>Pipeline</code>执行时被调用。</p>
</li>
</ol>
<h2 id="8-2-容器构造"><a href="#8-2-容器构造" class="headerlink" title="8.2 容器构造"></a>8.2 容器构造</h2><p>在启动Pandora容器前，首先会进行构造初始化。在其中主要完成了几步：</p>
<ol>
<li>流水线<code>Pipeline</code>上下文<code>PipelineContext</code>的构造，并且使用<code>containerArchive</code>（通过构造函数传入的<code>containerUrl</code>构造）、<code>pluginUrls</code>等初始上下文内容</li>
<li>保存调用方传入的业务类加载器<code>bizClassLoader</code>，后续会用到</li>
<li>创建内部使用的服务容器<code>ServiceContainer</code>，并设置版本信息。</li>
</ol>
<p>代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PandoraContainer</span><span class="params">(URL containerUrl, URL[] pluginUrls, ClassLoader bizClassLoader)</span> &#123;</span><br><span class="line">    AssertUtils.assertNotNull(bizClassLoader, <span class="string">&quot;bizClassLoader is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化日志，构建Pipeline上下文和服务容器</span></span><br><span class="line">    <span class="type">Archive</span> <span class="variable">containerArchive</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        containerArchive = ArchiveUtils.createArchiveFromUrl(containerUrl);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;fail to create pandora container archive from url: &quot;</span> + containerUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">logLevel</span> <span class="operator">=</span> CommonParser.parseLoggingLevel(containerArchive.getResource(CommonParser.LOG_PROPERTIES));</span><br><span class="line">    LoggerInit.initLogger(logLevel != <span class="literal">null</span> ? logLevel : <span class="string">&quot;INFO&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 构造流水线上下文PipelineContext，将pandora容器jar和插件url配置到PipelineContext中</span></span><br><span class="line">    pipelineContext = <span class="keyword">new</span> <span class="title class_">PipelineContext</span>();</span><br><span class="line">    pipelineContext.put(PipelineContextKey.PANDORA_CONTAINER_ARCHIVE, containerArchive);</span><br><span class="line">    pipelineContext.put(PipelineContextKey.PLUGIN_URLS, pluginUrls);</span><br><span class="line">    <span class="comment">// 2. 保存bizClassLoader，后续会用到</span></span><br><span class="line">    ClassLoaderHolder.setBizLoader(bizClassLoader);</span><br><span class="line">    <span class="comment">// 3. 初始化ServiceContainer，作为IOC容器</span></span><br><span class="line">    serviceContainer = <span class="keyword">new</span> <span class="title class_">ServiceContainer</span>();</span><br><span class="line">    serviceContainer.addConfig(ServiceConfigKey.VERSION_FILE_URL, containerArchive.getResource(<span class="string">&quot;version.properties&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第3步的<code>ServiceContainer</code>构造中，会同时将Pandora的各类服务和组件通过IOC容器提供的<code>addComponent()</code>方法注入，后续使用时可以从IOC容器中获取得到服务的单例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServiceContainer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IocContainerHolder.setContainer(container);</span><br><span class="line">        <span class="comment">// 服务在这里添加，接口和实现</span></span><br><span class="line">        container.addComponent(DeployService.class, DeployServiceImpl.class);</span><br><span class="line">		<span class="comment">// 省略其他服务的注册...</span></span><br><span class="line">        container.addConfig(<span class="string">&quot;config&quot;</span>, config);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-容器启动"><a href="#8-3-容器启动" class="headerlink" title="8.3 容器启动"></a>8.3 容器启动</h2><h3 id="8-3-1-基本流程"><a href="#8-3-1-基本流程" class="headerlink" title="8.3.1 基本流程"></a>8.3.1 基本流程</h3><ol>
<li>调用<code>ServiceContainer#start</code>方法，启动内部的服务容器。启动时触发执行容器中注册的组件的生命周期方法，主要的就是<code>Pipeline#init</code>，完成<code>Pipeline</code>的初始化</li>
<li>使用<code>ServiceContainer</code>获取<code>Pipeline</code>，使用获取到的<code>Pipeline</code>实例，调用<code>execute</code>方法执行流水线，执行时会按顺序调用<code>Pipeline</code>中每个<code>Stage</code>节点的<code>Stage#stepIn</code>（然后再反向依次调用<code>Stage#stepOut</code>方法）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    AssertUtils.assertNotNull(serviceContainer, <span class="string">&quot;service container is null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1. 启动ServiceContainer</span></span><br><span class="line">        serviceContainer.start();</span><br><span class="line">        <span class="comment">// 2. 获取并开始执行Pipeline</span></span><br><span class="line">        <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> serviceContainer.getService(Pipeline.class);</span><br><span class="line">        pipeline.execute(pipelineContext);</span><br><span class="line">        System.out.println(<span class="string">&quot;\nPandora container started in &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-2-Pipeline初始化"><a href="#8-3-2-Pipeline初始化" class="headerlink" title="8.3.2 Pipeline初始化"></a>8.3.2 <code>Pipeline</code>初始化</h3><p>在启动<code>serviceContainer</code>时，会执行<code>Pipeline#init</code>，使用<code>PandoraClassLoader</code>从<code>pipeline.properties</code>配置文件中读取出需要添加到<code>Pipeline</code>中的节点的实现类名称，这些节点都实现了<code>com.taobao.pandora.service.pipeline.Stage</code>接口。这种动态加载的机制保证了<code>Pipeline</code>是灵活可配置的。</p>
<p><code>Pipeline#init</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 读取pipeline.properties属性文件，获得需要添加到Pipeline中的Stage</span></span><br><span class="line">    <span class="type">LinkedProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedProperties</span>();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">pandoraClassLoader</span> <span class="operator">=</span> Pipeline.class.getClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        props.load(pandoraClassLoader.getResourceAsStream(<span class="string">&quot;pipeline.properties&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">savedClassLoader</span> <span class="operator">=</span> ContextLoaderUtils.pushContextClassLoader(pandoraClassLoader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建pipeline.properties中指定的stages，并构造成StageNode</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> props.size();</span><br><span class="line">        Enumeration&lt;Object&gt; enumeration = props.keys();</span><br><span class="line">        <span class="type">StageNode</span> <span class="variable">tailNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ((String) enumeration.nextElement()).trim();</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> props.getProperty(name).trim();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IocContainerHolder.getContainer().addComponent(name, pandoraClassLoader.loadClass(className));</span><br><span class="line">                <span class="type">Stage</span> <span class="variable">stage</span> <span class="operator">=</span> (Stage) IocContainerHolder.getContainer().getComponent(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建stage的StageNode，并创建StageNode之间的关联关系</span></span><br><span class="line">                <span class="type">StageNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StageNode</span>(stage, <span class="string">&quot;[&quot;</span> + i++ + <span class="string">&quot;/&quot;</span> + size + <span class="string">&quot;]&quot;</span>, name);</span><br><span class="line">                <span class="keyword">if</span> (tailNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                    headNode = currentNode; <span class="comment">// 设置初始节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tailNode.addNextNode(currentNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置当前节点为新的tail</span></span><br><span class="line">                tailNode = currentNode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;init stage got error, stage name: &quot;</span> + name, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ContextLoaderUtils.popContextClassLoader(savedClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-3-Pipeline执行"><a href="#8-3-3-Pipeline执行" class="headerlink" title="8.3.3 Pipeline执行"></a>8.3.3 <code>Pipeline</code>执行</h3><p>在<code>PandoraContainer#start</code>主流程可以看到启动<code>PandoraContainer</code>的启动主要就是执行<code>Pipeline</code>，对应的是<code>Pipeline#execute</code>方法。</p>
<p>执行的逻辑：从流水线头节点<code>headNode</code>开始依次执行每个<code>Stage</code>的<code>Stage#in</code>方法，然后再反序执行<code>Stage#out</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stage1#in --&gt; Stage2#in --&gt; ... --&gt; StageN#in</span><br><span class="line">										||</span><br><span class="line">Stage1#out --&gt; Stage2#out --&gt; ... &lt;-- StageN#out</span><br></pre></td></tr></table></figure>

<p>代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pipeline#execute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(PipelineContext context)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">pandoraClassLoader</span> <span class="operator">=</span> Pipeline.class.getClassLoader();</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">savedClassLoader</span> <span class="operator">=</span> ContextLoaderUtils.pushContextClassLoader(pandoraClassLoader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Pipeline&quot;</span>, <span class="string">&quot;process begin.&quot;</span>);</span><br><span class="line">        <span class="comment">// 从头节点开始依次执行</span></span><br><span class="line">        <span class="keyword">if</span> (headNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            headNode.stepIn(context);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;Pipeline&quot;</span>, <span class="string">&quot;process end.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PandoraException ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Pipeline&quot;</span>, ErrorCode.EXECUTE_PIPELINE_STAGE_ERROR.getCode(), <span class="string">&quot;process got exception.&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ContextLoaderUtils.popContextClassLoader(savedClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StageNode#stepIn</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stepIn</span><span class="params">(PipelineContext context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 执行当前节点的stepIn</span></span><br><span class="line">    target.stepIn(context);</span><br><span class="line">    logger.info(<span class="string">&quot;Stage&quot;</span>, <span class="string">&quot;&#123;&#125; takes &#123;&#125; ms.&quot;</span>, target.getClass().getSimpleName(), (System.currentTimeMillis() - now));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得下一个节点，执行stepIn</span></span><br><span class="line">    <span class="comment">// 如果没有下个节点(到达末尾)，则开始反向执行stepOut</span></span><br><span class="line">    <span class="keyword">if</span> (nextNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        nextNode.stepIn(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stepOut(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-Stage执行"><a href="#8-4-Stage执行" class="headerlink" title="8.4 Stage执行"></a>8.4 <code>Stage</code>执行</h2><p> <code>Pipeline</code>初始化时从<code>pipeline.properties</code>属性文件中加载得到了<code>Stage</code>节点，通过串联调用每个<code>Stage</code>节点的<code>Stage#in</code>和<code>Stage#out</code>，完成了Pandora真正的部署启动流程。</p>
<p><code>pipeline.properties</code>文件内容：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## From top to bottom out</span></span><br><span class="line"><span class="comment">## ======================== DEPLOYING ======================== ##</span></span><br><span class="line"><span class="attr">Log4jDefaultInitOverride</span>=<span class="string">com.taobao.pandora.stage.Log4jDefaultInitOverride</span></span><br><span class="line"><span class="attr">MergeFolderPlugin</span>=<span class="string">com.taobao.pandora.stage.MergeFolderPlugin</span></span><br><span class="line"><span class="attr">DeployPluginModule</span>=<span class="string">com.taobao.pandora.stage.DeployPluginModule</span></span><br><span class="line"><span class="attr">InitializerCheck</span>=<span class="string">com.taobao.pandora.stage.InitializerCheck</span></span><br><span class="line"><span class="attr">ExportClass2Cache</span>=<span class="string">com.taobao.pandora.stage.ExportClass2Cache</span></span><br><span class="line"><span class="attr">RegisterPandoraService</span>=<span class="string">com.taobao.pandora.stage.RegisterPandoraService</span></span><br><span class="line"><span class="attr">RegisterLifecycleListener</span>=<span class="string">com.taobao.pandora.stage.RegisterLifecycleListener</span></span><br><span class="line"><span class="comment">## ======================== DEPLOYED ======================== ##</span></span><br><span class="line"><span class="attr">ChangeStateDeployed</span>=<span class="string">com.taobao.pandora.stage.ChangeStateDeployed</span></span><br><span class="line"><span class="attr">StartPandoraService</span>=<span class="string">com.taobao.pandora.stage.StartPandoraService</span></span><br></pre></td></tr></table></figure>

<p>参考Pandora Wiki的介绍：</p>
<blockquote>
<ol>
<li><code>Log4jDefaultInitOverride</code>是为了解决Log的兼容性问题：”jbooss下隔离容器的classloader会跟web容器的classloader加载的appender不一致”</li>
<li><code>MergeFolderPlugin</code>用于合并不同来源的plugin</li>
<li><code>DeployPluginModule</code>用于部署插件，为每个插件创建相应的<code>PluginModule</code>实例</li>
<li><code>InitializerCheck</code>会根据当前的环境检查每个插件，看插件是否允许在当前环境启用</li>
<li><code>ExportClass2Cache</code>会依次扫描每个插件，需要导出的类都导出到<code>SharedClassService</code></li>
<li><code>RegisterPandoraService</code>会遍历每个插件，如果该插件是一个<code>Service</code>，就会调用相应的<code>init</code>方法</li>
<li><code>RegisterLifecycleListener</code>会为插件注册相应的生命周期监听器</li>
<li><code>ChangeStateDeployed</code>把每个在<code>DEPLOYING</code>的plugin状态修改成<code>DEPLOYED</code></li>
<li><code>StartPandoraService</code> 会启动每个注册了的service的<code>start</code>方法</li>
</ol>
</blockquote>
<h3 id="3-4-1-MergeFolderPlugin"><a href="#3-4-1-MergeFolderPlugin" class="headerlink" title="3.4.1 MergeFolderPlugin"></a>3.4.1 <code>MergeFolderPlugin</code></h3><p>Pandora支持从不同路径加载插件，按照优先级排有：</p>
<blockquote>
<ol>
<li>sar包下面的plugins目录</li>
<li>外部指定：<code>com.taobao.pandora.PandoraContainer</code>构造时传入的<code>pluginUrls</code>（<code>PipelineContextKey#PLUGIN_URLS</code>）</li>
<li>外部指定：-D参数<code>com.taobao.pandora.plugins.ext_path</code>所指定的目录</li>
</ol>
</blockquote>
<p><code>MergeFolderPlugin</code>就用于完成从这些路径合并生成插件<code>Archive</code>的过程，完成后生成一个类型为<code>Map&lt;String, Archive&gt; </code>(key为插件的名称，value为为每一个插件生成的<code>Archive</code>)的<code>pluginArchiveMap</code>存到<code>PipelineContext</code>里。后面的<code>Stage</code>节点会从<code>PipelineContext</code>中读取插件<code>Archive</code>。</p>
<p>主要的插件来源是第二项，即<code>com.taobao.pandora.PandoraContainer</code>构造时传入的<code>pluginUrls</code>。这一步由Pandora Boot启动Pandora容器时完成。参考Pandora Boot启动流程。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FprxpXC4WCF2figkin2Z-xHOO3q_.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FprxpXC4WCF2figkin2Z-xHOO3q_.png"  lazyload></a></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stepIn</span><span class="params">(PipelineContext context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">	<span class="comment">// 1. 从containerArchive里加载所有的plugins下面的插件，支持开放目录的插件，或者以 jar.plugin 结尾的jar插件</span></span><br><span class="line">    <span class="type">Archive</span> <span class="variable">containerArchive</span> <span class="operator">=</span> (Archive) context.get(PipelineContextKey.PANDORA_CONTAINER_ARCHIVE);</span><br><span class="line">    Map&lt;String, Archive&gt; pluginArchiveMap = loadPlugins(containerArchive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 合并 PipelineContextKey.PLUGIN_URLS 指定的插件</span></span><br><span class="line">    URL[] pluginUrls = (URL[]) context.get(PipelineContextKey.PLUGIN_URLS);</span><br><span class="line">    <span class="keyword">if</span> (pluginUrls != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (URL url : pluginUrls) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Archive</span> <span class="variable">pluginArchive</span> <span class="operator">=</span> ArchiveUtils.createArchiveFromUrl(url);</span><br><span class="line">                <span class="comment">// 从插件的com/taobao/pandora/plugin.guide.properties属性文件中读取artifactId作为插件名称</span></span><br><span class="line">                <span class="type">Properties</span> <span class="variable">guideProperties</span> <span class="operator">=</span> IOUtils.readProperties(pluginArchive.getResource(PLUGIN_GUIDE_PROPERTIES));</span><br><span class="line">                AssertUtils.assertNotNull(guideProperties,</span><br><span class="line">                                          <span class="string">&quot;can not load guide properties from archive:&quot;</span> + pluginArchive.getUrl());</span><br><span class="line">                <span class="comment">// 从plugin jar里的plugin.guide.properties 里读取到 plugin name</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pluginName</span> <span class="operator">=</span> guideProperties.getProperty(<span class="string">&quot;artifactId&quot;</span>);</span><br><span class="line">                AssertUtils.assertNotNull(pluginName, <span class="string">&quot;plugin name can not be null&quot;</span>);</span><br><span class="line">                pluginArchiveMap.put(pluginName, pluginArchive);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PandoraException</span>(<span class="string">&quot;load plugin archive error!, url: &quot;</span> + url, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取-D参数指定的外部插件文件夹路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ext</span> <span class="operator">=</span> System.getProperty(EXTERNAL_PLUGIN_PATH);</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Stage-MergeFolderPlugin&quot;</span>, <span class="string">&quot;-D&quot;</span> + EXTERNAL_PLUGIN_PATH + <span class="string">&quot;: &quot;</span> + ext);</span><br><span class="line">    &#125;</span><br><span class="line">    File[] externalPlugins = getExternalPlugins(ext);</span><br><span class="line">    <span class="keyword">if</span> (externalPlugins != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 外部路径的插件覆盖内部的</span></span><br><span class="line">        <span class="keyword">for</span> (File extPlugin : externalPlugins) &#123;</span><br><span class="line">            <span class="comment">// 不部署隐藏目录</span></span><br><span class="line">            <span class="keyword">if</span> (extPlugin.isHidden()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Stage-MergeFolderPlugin&quot;</span>, <span class="string">&quot;[&#123;&#125;] is a hidden directory in sar, ignore.&quot;</span>,</span><br><span class="line">                         extPlugin.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pluginArchiveMap.put(extPlugin.getName(), <span class="keyword">new</span> <span class="title class_">ExplodedArchive</span>(extPlugin));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 放入PipelineContext</span></span><br><span class="line">    context.put(PipelineContextKey.PLUGIN_ARCHIVES_MAP, pluginArchiveMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-2-DeployPluginModule"><a href="#8-4-2-DeployPluginModule" class="headerlink" title="8.4.2 DeployPluginModule"></a>8.4.2 <code>DeployPluginModule</code></h3><p><code>DeployPluginModule</code>用于部署插件，为每个插件创建相应的<code>PluginModule</code>实例。</p>
<p>老的Pandora代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stepIn</span><span class="params">(PipelineContext context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    Map&lt;String, Archive&gt; pluginArchives = (Map&lt;String, Archive&gt;) context.get(PipelineContextKey.PLUGIN_ARCHIVES_MAP);</span><br><span class="line">    <span class="comment">// 依次部署每个插件</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;String, Archive&gt; entry : pluginArchives.entrySet())&#123;</span><br><span class="line">        <span class="type">Module</span> <span class="variable">module</span> <span class="operator">=</span> deployService.deployModule(entry.getValue(), entry.getKey());</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;Stage-DeployPluginModule&quot;</span>, <span class="string">&quot;deploy module:&quot;</span> + <span class="keyword">module</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本的Pandora为了加快部署插件的速度，为每个插件新建了一条线程，并发执行部署任务。通过一个<code>CountDownLatch</code>来控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stepIn</span><span class="params">(PipelineContext context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    Map&lt;String, Archive&gt; pluginArchives = (Map&lt;String, Archive&gt;) context.get(PipelineContextKey.PLUGIN_ARCHIVES_MAP);</span><br><span class="line">    <span class="comment">// 通过CountDownLatch做并发控制</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(pluginArchives.size());</span><br><span class="line">    <span class="comment">// 为每个插件创建一条线程执行部署动作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">final</span> Entry&lt;String, Archive&gt; entry : pluginArchives.entrySet())&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 部署插件</span></span><br><span class="line">                    <span class="type">Module</span> <span class="variable">module</span> <span class="operator">=</span> deployService.deployModule(entry.getValue(), entry.getKey());</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;Stage-DeployPluginModule&quot;</span>, <span class="string">&quot;deploy module:&quot;</span> + <span class="keyword">module</span>.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;DeployPluginModule-&quot;</span> + entry.getKey()).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PandoraException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署插件通过<code>DeployService#deployModule</code>完成，这是Pandora插件机制的第一个关键步骤。</p>
<ol>
<li><p>通过<code>PluginModuleFactory#createModule</code>创建插件模块对象<code>PluginModule</code></p>
<ul>
<li><p>设置name，archive，deployTime等</p>
</li>
<li><p>解析各种配置文件，将其设置到<code>PluginModule</code>中</p>
</li>
<li><p><strong>关键：生成插件对应的<code>ModuleClassLoader</code></strong></p>
</li>
</ul>
</li>
<li><p>设置插件状态为<code>ModuleState.DEPLOYING</code></p>
</li>
<li><p>被创建的<code>PluginModule</code>会被保存在一个<code>Map&lt;String, PluginModule&gt;</code>中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeployServiceImpl#deployModule</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Module <span class="title function_">deployModule</span><span class="params">(Archive archive, String name)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    <span class="type">PluginModule</span> <span class="variable">pluginModule</span> <span class="operator">=</span> moduleFactory.createModule(archive, name);</span><br><span class="line">    pluginModule.setModuleState(ModuleState.DEPLOYING);</span><br><span class="line">    modules.putIfAbsent(name, pluginModule);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">return</span> pluginModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PluginModuleFactory#createModule</span></span><br><span class="line"><span class="keyword">public</span> PluginModule <span class="title function_">createModule</span><span class="params">(Archive archive, String name)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="type">PluginModule</span> <span class="variable">module</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PluginModule</span>();</span><br><span class="line">    <span class="comment">// 省略，主要是解析各种配置文件，将其设置到PluginModule中</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 关键步骤：构建ModuleClassLoader</span></span><br><span class="line">    setupClassLoader(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建ModuleClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* package */</span> <span class="keyword">void</span> <span class="title function_">setupClassLoader</span><span class="params">(PluginModule <span class="keyword">module</span>)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">	<span class="comment">// 省略，设置构建ModuleClassLoader的参数对象createLoaderParam的一些属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将ClassLoader的URL设为插件的lib目录读取的lib</span></span><br><span class="line">    URL[] libFiles;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        libFiles = <span class="keyword">module</span>.getLibFileUrls().toArray(<span class="keyword">new</span> <span class="title class_">URL</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PandoraException</span>(<span class="string">&quot;get module lib files error!, module:&quot;</span> + <span class="keyword">module</span>.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (libFiles != <span class="literal">null</span>) &#123;</span><br><span class="line">        createLoaderParam.setRepository(libFiles);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正的构建方法</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> classLoaderService.createModuleClassLoader(createLoaderParam);</span><br><span class="line">    <span class="keyword">module</span>.setClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的创建<code>ModuleClassLoader</code>在<code>createModuleClassLoader</code>方法中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ClassLoader <span class="title function_">createModuleClassLoader</span><span class="params">(CreateLoaderParam param)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">	<span class="comment">// 省略校验部分</span></span><br><span class="line">    <span class="comment">// 构建ModuleClassLoader，传入插件名称，lib URL列表</span></span><br><span class="line">    <span class="type">ModuleClassLoader</span> <span class="variable">moduleClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModuleClassLoader</span>(param.getModuleName().trim(), param.getRepository());</span><br><span class="line">    <span class="comment">// 配置各类ClassLoader，在加载类时会用到</span></span><br><span class="line">    moduleClassLoader.setExtClassLoader(extClassLoader);</span><br><span class="line">    moduleClassLoader.setImportPackages(param.getImportPackageList());</span><br><span class="line">    moduleClassLoader.setImportResources(param.getImportResources());</span><br><span class="line">    moduleClassLoader.setPandoraClassLoader(pandoraClassLoader);</span><br><span class="line">    moduleClassLoader.setSharedClassService(sharedClassService);</span><br><span class="line"></span><br><span class="line">    moduleClassLoader.setBizClassLoader(getBizClassLoader(), param.isUseBizClassLoader());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (param.isUseSystemClassLoader()) &#123;</span><br><span class="line">        moduleClassLoader.setSystemClassLoader(systemClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    modules.put(moduleClassLoader.getModuleName(), moduleClassLoader);</span><br><span class="line">    <span class="keyword">return</span> moduleClassLoader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-4-3-ExportClass2Cache"><a href="#8-4-3-ExportClass2Cache" class="headerlink" title="8.4.3 ExportClass2Cache"></a>8.4.3 <code>ExportClass2Cache</code></h3><p><code>ExportClass2Cache</code>用于插件的类导出，它会依次扫描每个插件，需要导出的类都导出到<code>SharedClassService</code>中。</p>
<p>导出功能的实现交由<code>ClassExporter#exportClasses</code>。</p>
<p><code>ClassExporter</code>的导出流程：</p>
<ol>
<li><p>根据<code>exportIndexEnabled</code>配置（默认为true），首先尝试加载插件<code>conf/export.index</code>中声明需要导出的类，如果可以导出，则直接返回</p>
<ul>
<li><code>export.index</code>文件由pandora maven plugin生成，通过直接从中获取导出类的全类名，可以简化和加快导出过程，不再需要去解析<code>export.properties</code></li>
<li>一个需要注意的点：Pandora支持<strong>懒加载机制</strong>，即不加载需要导出的类，而是直接保存导出类的信息，后续真正用到导出类的时候再加载。这样做的好处是可以加快启动速度，并且减少启动时的内存占用。Pandora默认在IDE下开启了懒加载。</li>
</ul>
</li>
<li><p>根据插件配置的<code>export.properties</code>文件，依次扫描需要导出的jar包、需要导出的package、需要导出的class，并解析、加载出所有的类</p>
</li>
</ol>
<p>被导出的类会被放到<code>com.taobao.pandora.api.service.sharedclass.SharedClassService</code>中，最终会放到<code>bizClassLoader</code>的<code>classCache</code>中，从而使得应用可以用到被插件<code>ModuleClassLoader</code>加载的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.taobao.pandora.stage.ExportClass2Cache#stepIn</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stepIn</span><span class="params">(PipelineContext context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    List&lt;Module&gt; moduleList = deployService.listModules();</span><br><span class="line">    <span class="keyword">if</span> (moduleList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Module <span class="keyword">module</span> : moduleList) &#123;</span><br><span class="line">            <span class="comment">// 通过classExporter导出类</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> classExporter.exportClasses(<span class="keyword">module</span>.getName());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 省略打印</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.taobao.pandora.service.sharedclass.ClassExporter#exportClasses</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出Module的类到缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> moduleName 模块名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 导出类的总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">exportClasses</span><span class="params">(String moduleName)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="type">PluginModule</span> <span class="variable">module</span> <span class="operator">=</span> (PluginModule) deployService.findModule(moduleName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="literal">null</span> || <span class="keyword">module</span>.getModuleState() != ModuleState.DEPLOYING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 默认扫描export.index，进行导出</span></span><br><span class="line">    <span class="keyword">if</span> (exportIndexEnabled) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">scanFromExportIndex</span> <span class="operator">=</span> scanFromExportIndex(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanFromExportIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scanFromExportIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 扫描jar包</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : scanJars(<span class="keyword">module</span>)) &#123;</span><br><span class="line">        Class&lt;?&gt; existing = sharedClassService.putIfAbsent(<span class="keyword">module</span>, clazz);</span><br><span class="line">        <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 3. 扫描package</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : scanPackages(<span class="keyword">module</span>)) &#123;</span><br><span class="line">        Class&lt;?&gt; existing = sharedClassService.putIfAbsent(<span class="keyword">module</span>, clazz);</span><br><span class="line">        <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 扫描class</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : scanClasses(<span class="keyword">module</span>)) &#123;</span><br><span class="line">        Class&lt;?&gt; existing = sharedClassService.putIfAbsent(<span class="keyword">module</span>, clazz);</span><br><span class="line">        <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下从<code>export.index</code>加载的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试从 conf/export.index 加载导出类，如果没有找到，则返回 -1。index文件由pandora maven plugin生成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> module</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">scanFromExportIndex</span><span class="params">(PluginModule <span class="keyword">module</span>)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">moduleName</span> <span class="operator">=</span> <span class="keyword">module</span>.getName();</span><br><span class="line">    <span class="type">URL</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">module</span>.getArchive().getResource(EXPORT_INDEX);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 省略读取index文件的代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用ModuleClassLoader进行导出类加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">module</span>.getClassLoader();</span><br><span class="line">        <span class="type">ExportInfo</span> <span class="variable">exportInfo</span> <span class="operator">=</span> <span class="keyword">module</span>.getExportInfo();</span><br><span class="line">        <span class="type">int</span> <span class="variable">loadedClassCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lazyExportEnabled()) &#123;</span><br><span class="line">            <span class="comment">// 配置了懒加载时，并不会loadClass，而是直接保存</span></span><br><span class="line">            <span class="type">LazySharedClassServiceImpl</span> <span class="variable">lazySharedClassServiceImpl</span> <span class="operator">=</span> (LazySharedClassServiceImpl) sharedClassService;</span><br><span class="line">            <span class="keyword">for</span> (String clzName : classes) &#123;</span><br><span class="line">                <span class="type">PluginModule</span> <span class="variable">putResult</span> <span class="operator">=</span> lazySharedClassServiceImpl.putIfAbsent(clzName, <span class="keyword">module</span>);</span><br><span class="line">                <span class="keyword">if</span> (putResult == <span class="literal">null</span>) &#123;</span><br><span class="line">                    loadedClassCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非懒加载，则使用ModuleClassLoader加载导出类并保存</span></span><br><span class="line">            <span class="keyword">for</span> (String clzName : classes) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Class&lt;?&gt; clz = classLoader.loadClass(clzName);</span><br><span class="line">                    Class&lt;?&gt; existing = sharedClassService.putIfAbsent(<span class="keyword">module</span>, clz);</span><br><span class="line">                    <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">                        loadedClassCount++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;ClassExporter&quot;</span>, <span class="string">&quot;&#123;&#125; export class: &#123;&#125;&quot;</span>, moduleName, clz.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    throwIfNotOptional(exportInfo, clzName, moduleName, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadedClassCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-RegisterPandoraService"><a href="#4-3-RegisterPandoraService" class="headerlink" title="4.3 RegisterPandoraService"></a>4.3 <code>RegisterPandoraService</code></h3><p><code>RegisterPandoraService</code>用于执行插件服务定义需要执行的初始化方法。它的执行流程如下：</p>
<ol>
<li><p>插件可以在<code>conf/service.properties</code>文件中执行需要执行初始化方法的服务全类名，例如</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service</span>=<span class="string">com.alibaba.alimonitor.jmonitor.common.JmonitorBootstrapForPandora</span></span><br></pre></td></tr></table></figure>

<p>注意服务类必须继承<code>PandoraService</code>接口。</p>
</li>
<li><p>如果没有配置<code>conf/service.properties</code>，则什么都不会做</p>
</li>
<li><p>如果有配置，则会使用<code>ModuleClassLoader</code>（会被设置为<code>ContextClassLoader</code>）去加载配置中指定的类，并调用其实现的<code>PandoraService#init</code>方法，进行服务的初始化</p>
</li>
</ol>
<p>通过这种机制，Pandora容器提供给插件一个在部署后执行服务初始化的机会。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.taobao.pandora.service.ps.PandoraServiceWrapper#init</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="comment">// 将ModuleClassLoader设为ContextClassLoader，用于加载插件服务</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">savedClassLoader</span> <span class="operator">=</span> ContextLoaderUtils.pushContextClassLoader(classLoader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        initInternal(context);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 完成后恢复ContextClassLoader</span></span><br><span class="line">        ContextLoaderUtils.popContextClassLoader(savedClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.taobao.pandora.service.ps.PandoraServiceWrapper#initInternal</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">(Context context)</span> <span class="keyword">throws</span> PandoraException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 定义在service.properties中的服务全类名，如果没有就跳过</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceClassName</span> <span class="operator">=</span> <span class="keyword">module</span>.getServiceName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(serviceClassName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 使用上一步设置的ContextClassLoader加载，并执行init()方法</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="type">PandoraService</span> <span class="variable">pandoraService</span> <span class="operator">=</span> (PandoraService) classLoader.loadClass(serviceClassName).newInstance();</span><br><span class="line">        pandoraService.init(context);</span><br><span class="line">        service = pandoraService;</span><br><span class="line">        log.info(<span class="string">&quot;PandoraServiceManager&quot;</span>, <span class="string">&quot;service: &quot;</span> + service.getName() + <span class="string">&quot; inited.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PandoraException</span>(<span class="string">&quot;fail to initialize service for &quot;</span> + <span class="keyword">module</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-4-RegisterLifecycleListener"><a href="#4-4-RegisterLifecycleListener" class="headerlink" title="4.4 RegisterLifecycleListener"></a>4.4 <code>RegisterLifecycleListener</code></h3><blockquote>
<p><code>RegisterLifecycleListener</code>会依次从每个插件中查看是否在目录下配置了<code>conf/listener.properties</code>文件，如果没有配置则什么都不做，有的话就加载，实例化指定的<code>com.taobao.pandora.api.service.lifecycle.LifecycleListener</code>实现类，并注册到<code>pluginListeners</code>中。</p>
</blockquote>
<p>通过这种机制，插件可以监听来自应用或者容器的生命周期事件。</p>
<h3 id="4-5-ChangeStateDeployed"><a href="#4-5-ChangeStateDeployed" class="headerlink" title="4.5 ChangeStateDeployed"></a>4.5 <code>ChangeStateDeployed</code></h3><p>到这一步，插件已经部署完成，<code>ChangeStateDeployed</code>把插件的部署状态由<code>DEPLOYING</code>设置成<code>DEPLOYED</code>。</p>
<h3 id="4-6-StartPandoraService"><a href="#4-6-StartPandoraService" class="headerlink" title="4.6 StartPandoraService"></a>4.6 <code>StartPandoraService</code></h3><p>与<code>RegisterPandoraService</code>作用类似，这一步是执行服务的<code>start()</code>方法。</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#1-%E5%89%8D%E8%A8%80"><span class="top-box-text">1 前言</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="top-box-text">2 类加载器</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#3-Pandora%E6%A1%86%E6%9E%B6"><span class="top-box-text">3 Pandora框架</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-1-%E6%B5%81%E6%B0%B4%E7%BA%BFPipeline"><span class="top-box-text">3.1 流水线Pipeline</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8"><span class="top-box-text">3.2 服务容器</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#4-Pandora%E6%8F%92%E4%BB%B6"><span class="top-box-text">4 Pandora插件</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#5-%E6%80%9D%E8%80%83"><span class="top-box-text">5 思考</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#6-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E6%A6%82%E8%BF%B0"><span class="top-box-text">6 代码实现 - 概述</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#7-Pandora-Boot-%E5%90%AF%E5%8A%A8"><span class="top-box-text">7 Pandora Boot 启动</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#7-1-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="top-box-text">7.1 基本流程</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#7-2-ReLaunchMainLauncher-launch"><span class="top-box-text">7.2 ReLaunchMainLauncher#launch</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#7-3-ReLaunchMainLauncher-createClassLoader"><span class="top-box-text">7.3 ReLaunchMainLauncher#createClassLoader</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#7-4-SarLoaderUtils-getClassCache"><span class="top-box-text">7.4 SarLoaderUtils#getClassCache</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#8-Pandora%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="top-box-text">8 Pandora容器启动</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#8-1-%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="top-box-text">8.1 主要类</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#8-2-%E5%AE%B9%E5%99%A8%E6%9E%84%E9%80%A0"><span class="top-box-text">8.2 容器构造</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#8-3-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="top-box-text">8.3 容器启动</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#8-3-1-%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="top-box-text">8.3.1 基本流程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#8-3-2-Pipeline%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="top-box-text">8.3.2 Pipeline初始化</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#8-3-3-Pipeline%E6%89%A7%E8%A1%8C"><span class="top-box-text">8.3.3 Pipeline执行</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#8-4-Stage%E6%89%A7%E8%A1%8C"><span class="top-box-text">8.4 Stage执行</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-4-1-MergeFolderPlugin"><span class="top-box-text">3.4.1 MergeFolderPlugin</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#8-4-2-DeployPluginModule"><span class="top-box-text">8.4.2 DeployPluginModule</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#8-4-3-ExportClass2Cache"><span class="top-box-text">8.4.3 ExportClass2Cache</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-3-RegisterPandoraService"><span class="top-box-text">4.3 RegisterPandoraService</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-4-RegisterLifecycleListener"><span class="top-box-text">4.4 RegisterLifecycleListener</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-5-ChangeStateDeployed"><span class="top-box-text">4.5 ChangeStateDeployed</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#4-6-StartPandoraService"><span class="top-box-text">4.6 StartPandoraService</span></a></li></ol></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2018/11/06/cong-shang-wang-xia-du-hsf-yuan-ma/">
          <h3 class="post-title">
            下一篇：从上往下读HSF源码
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>聊聊单机和分布式流控的思路和实现</title>
<meta name="keywords" content="聊聊单机和分布式流控的思路和实现, jffu&#39;s blog">
<meta name="description" content="单机和分布式流控的思路+实现。">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="聊聊单机和分布式流控的思路和实现">
<meta property="og:description" content="单机和分布式流控的思路+实现。">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">聊聊单机和分布式流控的思路和实现</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2020-05-15</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
                  ，
                
              </a>
            
              <a href="/tags/%E6%B5%81%E6%8E%A7/">
              流控
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>本文同步发布于 阿里开发者 与 阿里云国际社区 等媒体上，这是原始版本，与对外发布版本略有不同。</p>
</blockquote>
<h1 id="流控的场景"><a href="#流控的场景" class="headerlink" title="流控的场景"></a>流控的场景</h1><p>流控的意义其实无需多言了。最常用的场景下，流控是为了保护下游有限的资源不被流量冲垮，保证服务的可用性，一般允许流控的阈值有一定的弹性，偶尔的超量访问是可以接受的。</p>
<p>有的时候，流控服务于收费模式，比如某些云厂商会对调用API的频次进行计费。既然涉及到钱，一般就不允许有超出阈值的调用量。</p>
<p>这些不同的场景下，适用的流控算法不尽相同。大多数情况下，使用集团的Sentinel中间件已经能很好地应对，但Sentinel也并不是万能的，比如它的集群模式目前看还不太完善。之前对接钉钉开放平台时，钉钉会对单个接口的调用频率做限制，而调用的发起方是应用集群，这就是一个典型的分布式流控场景，需要思考其他的流控方案。</p>
<h1 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h1><p>为了方便，以下所有的示例代码实现都是基于<code>Throttler</code>接口。</p>
<p><code>Throttler</code>接口定义了一个通用的方法用于申请单个配额。</p>
<blockquote>
<ul>
<li>当然你也可以定义一个<code>tryAcquire(String key, int permits)</code>签名的方法用于一次申请多个配额，实现的思路是一样的。</li>
<li>有些流控算法需要为每个key维护一个<code>Throttler</code>实例。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Throttler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试申请一个配额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     申请配额的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 申请成功则返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单机流控"><a href="#单机流控" class="headerlink" title="单机流控"></a>单机流控</h1><h2 id="简单窗口"><a href="#简单窗口" class="headerlink" title="简单窗口"></a>简单窗口</h2><blockquote>
<p>简单窗口是我自己的命名，有些地方也叫做固定窗口，主要是为了跟后面的滑动窗口区分。</p>
</blockquote>
<p>流控是为了限制指定时间间隔内能够允许的访问量，因此，最直观的思路就是基于一个给定的时间窗口，维护一个计数器用于统计访问次数，然后实现以下规则：</p>
<ol>
<li>如果访问次数小于阈值，则代表允许访问，访问次数+1；</li>
<li>如果访问次数超出阈值，则限制访问，访问次数不增；</li>
<li>如果超过了时间窗口，计数器清零，并重置清零后的首次成功访问时间为当前时间。这样就确保计数器统计的是最近一个窗口的访问量；</li>
</ol>
<h3 id="代码实现SimpleWindowThrottler"><a href="#代码实现SimpleWindowThrottler" class="headerlink" title="代码实现SimpleWindowThrottler"></a>代码实现<code>SimpleWindowThrottler</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 毫秒为单位的时间窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> windowInMs;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间窗口内最大允许的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最后一次成功请求时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastReqTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 如果当前时间已经超过了上一次访问时间开始的时间窗口，重置计数器，以当前时间作为新窗口的起始值</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastReqTime &gt; windowInMs) &#123;		#<span class="number">1</span></span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        lastReqTime = now;					#<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; threshold) &#123;					#<span class="number">3</span></span><br><span class="line">        counter++;							#<span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一种常见的场景是根据不同的key来做流控，每个key有单独的时间窗口、阈值配置，因此需要为每个key维护一个单独的限流器实例。</p>
</blockquote>
<h3 id="切换到多线程环境"><a href="#切换到多线程环境" class="headerlink" title="切换到多线程环境"></a>切换到多线程环境</h3><p>在现实应用中，往往是多个线程来同时申请配额，为了比较简洁地表达算法思路，示例代码里面都没有做并发同步控制。</p>
<p>以简单窗口的实现为例，要转换为多线程安全的流控算法，一种直接的办法是将<code>tryAcquire</code>方法设置为<code>synchronized</code>。</p>
<p>当然一种感觉上更高效的办法也可以是修改读写变量的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastReqTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">private</span> <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br></pre></td></tr></table></figure>

<p>不过这样其实并不真正”安全“，设想以下的场景，两个线程A、线程B前后脚尝试获取配额，#1位置的判断条件满足后，会同时走到#2位置修改<code>lastReqTime</code>值，线程B的赋值会覆盖线程A，导致时间窗口起始点向后偏移。同样的，位置#3和#4也会构成竞争条件。当然如果对流控的精度要求不高，这种竞争也是能接受的。</p>
<h3 id="临界突变问题"><a href="#临界突变问题" class="headerlink" title="临界突变问题"></a>临界突变问题</h3><p>简单窗口的流控实现非常简单，以1分钟允许100次访问为例，如果流量均匀保持200次&#x2F;分钟的访问速率，系统的访问量曲线大概是这样的（按分钟清零）：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqGrHN-qw4mMhxqr3MOIg8woSQv1.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FqGrHN-qw4mMhxqr3MOIg8woSQv1.png"  lazyload></a><br>但如果流量并不均匀，假设在时间窗口开始时刻0:00有几次零星的访问，一直到0:50时刻，开始以10次&#x2F;秒的速度请求，就会出现这样的访问量图线：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftrb6tTBC2cG-sGPJqfqvVSI1VVV.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ftrb6tTBC2cG-sGPJqfqvVSI1VVV.png"  lazyload></a><br>在临界的20秒内（0:50~1:10）系统承受的实际访问量是200次，换句话说，最坏的情况下，在窗口临界点附近系统会承受2倍的流量冲击，这就是简单窗口不能解决的临界突变问题。</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>如何解决简单窗口算法的临界突变问题？既然一个窗口统计的精度低，那么可以把整个大的时间窗口切分成更细粒度的子窗口，每个子窗口独立统计。同时，每过一个子窗口大小的时间，就向右滑动一个子窗口。这就是滑动窗口算法的思路。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkJnsc-XUyU13eMQtIN-tMB-EpWb.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FkJnsc-XUyU13eMQtIN-tMB-EpWb.png"  lazyload></a><br>如上图所示，将一分钟的时间窗口切分成6个子窗口，每个子窗口维护一个独立的计数器用于统计10秒内的访问量，每经过10s，时间窗口向右滑动一格。</p>
<p>回到简单窗口出现临界跳变的例子，结合上面的图再看滑动窗口如何消除临界突变。如果0:50到1:00时刻（对应灰色的格子）进来了100次请求，接下来1:00~1:10的100次请求会落到黄色的格子中，由于算法统计的是6个子窗口的访问量总和，这时候总和超过设定的阈值100，就会拒绝后面的这100次请求。</p>
<h3 id="代码实现（参考Sentinel）"><a href="#代码实现（参考Sentinel）" class="headerlink" title="代码实现（参考Sentinel）"></a>代码实现（参考Sentinel）</h3><p>Sentinel提供了一个轻量高性能的滑动窗口流控算法实现，ATA上已经有很多Sentinel的介绍和解析文章，这里就不详细阐述具体的代码逻辑了。</p>
<p>看代码的时候可以重点关注这几个类：</p>
<ol>
<li><p>功能插槽<code>StatisticSlot</code>负责记录、统计不同纬度的 runtime 指标监控信息，例如RT、QPS等。 </p>
<blockquote>
<p>Sentinel内部使用了slot chain的责任链设计模式，每个功能插槽slot有不同的功能（限流、降级、系统保护），通过<code>ProcessorSlotChain</code>串联在一起。参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B">官方Wiki</a>。</p>
</blockquote>
</li>
<li><p><code>StatisticSlot</code>使用<code>StatisticNode#addPassRequest</code>记录允许的请求数，包含秒和分钟两个维度； </p>
</li>
<li><p>具体记录用到的是<code>Metric</code>接口，对应实现类<code>ArrayMetric</code>，背后真正的滑动窗口数据结构是<code>LeapArray</code>； </p>
</li>
<li><p><code>LeapArray</code>内部维护了滑动窗口用到的关键属性和结构，包括:</p>
</li>
</ol>
<ul>
<li><p>总窗口大小<code>intervalInMs</code>，滑动子窗口大小<code>windowLengthInMs</code>，采样数量<code>sampleCount</code> </p>
<blockquote>
<p>sampleCount &#x3D; intervalInMs &#x2F; windowLengthInMs，当前实现默认为2，而总窗口大小默认是1s，也就意味着默认的滑动窗口大小是500ms。可以通过调整采样数量来调整统计的精度。</p>
</blockquote>
</li>
<li><p>滑动窗口的数组<code>array</code>，数组中每个元素以<code>WindowWrap&lt;T&gt;</code>表示，其中包含： </p>
<ul>
<li><code>windowStart</code>：滑动窗口的开始时间</li>
<li><code>windowLength</code>: 滑动窗口的长度</li>
<li><code>value</code>: 滑动窗口记录的内容，泛型表示，关键的一类就是<code>MetricBucket</code>，里面包含了一组<code>LongAdder</code>用于记录不同类型的数据，例如请求通过数、请求阻塞数、请求异常数等等</li>
</ul>
</li>
</ul>
<p>记录请求的逻辑说白了，就是根据当前时间获取所属的滑动窗口，然后将该窗口的统计值+1即可。但实际上，获取当前所属的时间窗口这一步隐含了不少细节，详细的实现可以从<code>LeapArray#currentWindow</code>中找到，源码的注释写得很详细，这里就不多提了（偷个懒）。</p>
<p>这里借助一张其他同学画的图（再偷个懒）表述以上的流程：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmHZr-UWDDoaoBQHkPwWgPEve-0z.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmHZr-UWDDoaoBQHkPwWgPEve-0z.png"  lazyload></a></p>
<blockquote>
<p>以上的流程基于3.9.21版本的源码，早先版本的Sentinel内部版本实现不尽相同，使用了一个叫<code>SentinelRollingNumber</code>的数据结构，但原理是类似的。</p>
</blockquote>
<p>想进一步了解的话，推荐几篇其他同学的文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.atatech.org/articles/122745">Sentinel 原理-滑动窗口</a></p>
<p><a target="_blank" rel="noopener" href="https://www.atatech.org/articles/130312">基于Sentinel集团版本和开源版本的实时统计模型对比分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.atatech.org/articles/127047">Sentinel数据统计SentinelRollingNumber源码解析</a></p>
<h3 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h3><p>现在思考这么一个问题：滑动窗口算法能否精准地控制任意给定时间窗口T内的访问量不大于N？</p>
<p>答案是否定的，还是将1分钟分成6个10秒大小的子窗口的例子，假设请求的速率现在是20次&#x2F;秒，从0:05时刻开始进入，那么在0:050:10时间段内会放进100个请求，同时接下来的请求都会被限流，直到1:00时刻窗口滑动，在1:001:05时刻继续放进100个请求。如果把0:05~1:05看作是1分钟的时间窗口，那么这个窗口内实际的请求量是200，超出了给定的阈值100。</p>
<p>如果要追求更高的精度，理论上只需要把滑动窗口切分得更细。像Sentinel中就可以通过修改单位时间内的采样数量<code>sampleCount</code>值来设置精度，这个值一般根据业务的需求来定，以达到在精度和内存消耗之间的平衡。</p>
<h3 id="平滑度问题"><a href="#平滑度问题" class="headerlink" title="平滑度问题"></a>平滑度问题</h3><p>使用滑动窗口算法限制流量时，我们经常会看到像下面一样的流量曲线。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpV40of7rsxhhE4fah-ye-ffTMGb.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FpV40of7rsxhhE4fah-ye-ffTMGb.png"  lazyload></a><br>突发的大流量在窗口开始不久就直接把限流的阈值打满，导致剩余的窗口内所有请求都无法通过。在时间窗口的单位比较大时（例如以分为单位进行流控），这种问题的影响就比较大了。在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。</p>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>滑动窗口无法很好地解决平滑度问题，再回过头看我们对于平滑度的诉求，当流量超过一定范围后，我们想要的效果不是一下子切断流量，而是将流量控制在系统能承受的一定的速度内。假设平均访问速率为<code>v</code>, 那我们要做的流控其实是流速控制，即控制平均访问速率<code>v ≤ N / T</code>。</p>
<p>在网络通信中常常用到漏通算法来实现流量整形。漏桶算法的思路就是基于流速来做控制。想象一下上学时经常做的水池一边抽水一边注水的应用题，把水池换成水桶（还是底下有洞一注水就开始漏的那种），把请求看作是往桶里注水，桶底漏出的水代表离开缓冲区被服务器处理的请求，桶口溢出的水代表被丢弃的请求。在概念上类比：</p>
<ul>
<li>最大允许请求数<code>N</code>：桶的大小</li>
<li>时间窗口大小<code>T</code>：一整桶水漏完的时间</li>
<li>最大访问速率<code>V</code>：一整桶水漏完的速度，即<code>N / T</code></li>
<li>请求被限流：桶注水的速度比漏水的速度快，最终导致桶内水溢出</li>
</ul>
<p>假设起始时刻桶是空的，每次访问都会往桶里注入一单位体积的水量，那么当我们以小于等于<code>N/T</code>的速度往桶里注水时, 桶内的水就永远不会溢出。反之，一旦实际注水速度超过漏水速度, 桶里就会产生越来越多的积水，直到溢出为止。同时漏水的速度永远被控制在<code>N / T</code>以内，这就实现了平滑流量的目的。</p>
<p>漏桶算法的访问速率曲线如下：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgS9QEjDY2p9P7kuYBIGjE2MUBr-.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FgS9QEjDY2p9P7kuYBIGjE2MUBr-.png"  lazyload></a><br>附上一张网上常见的漏通算法原题图：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtzdKN7tA7ty2kwhf2HjAfIVuP-9.jpg"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FtzdKN7tA7ty2kwhf2HjAfIVuP-9.jpg"  lazyload></a></p>
<h3 id="代码实现LeakyBucketThrottler"><a href="#代码实现LeakyBucketThrottler" class="headerlink" title="代码实现LeakyBucketThrottler"></a>代码实现<code>LeakyBucketThrottler</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前桶内剩余的水</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> left;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上次成功注水的时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastInjectTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> capacity;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一桶水漏完的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> duration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶漏水的速度，即 capacity / duration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> velocity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 当前剩余的水 = 之前的剩余水量 - 过去这段时间内漏掉的水量</span></span><br><span class="line">    <span class="comment">// 过去这段时间内漏掉的水量 = (当前时间-上次注水时间) * 漏水速度</span></span><br><span class="line">    <span class="comment">// 如果当前时间相比上次注水时间相隔太久（一直没有注水），桶内的剩余水量就是0（漏完了）</span></span><br><span class="line">    left = Math.max(<span class="number">0</span>, left - (<span class="type">long</span>)((now - lastInjectTime) * velocity));</span><br><span class="line">    <span class="comment">// 往当前水量基础上注一单位水，只要没有溢出就代表可以访问</span></span><br><span class="line">    <span class="keyword">if</span> (left + <span class="number">1</span> &lt;= capacity) &#123;</span><br><span class="line">        lastInjectTime = now;</span><br><span class="line">        left++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏桶的问题"><a href="#漏桶的问题" class="headerlink" title="漏桶的问题"></a>漏桶的问题</h3><p>漏桶的优势在于能够平滑流量，如果流量不是均匀的，那么漏桶算法与滑动窗口算法一样无法做到真正的精确控制。极端情况下，漏桶在时间窗口 T 内也会放进相当于2倍阈值N的流量。</p>
<blockquote>
<p>设想一下，如果访问量相比窗口大小<code>N</code>大很多，在窗口（<code>0~T</code>）一开始的0时刻就直接涌进来，使得漏桶在时间<code>t</code>（ $ 0 \approx;  t &lt; T $ ）时刻溢出，然后在剩余的<code>T - t</code>时间内按照<code>N / T</code>的速度流入，在总的窗口内的<a class="simple-lightbox" target="_blank" rel="noopener" href="https://www.yuque.com/api/services/graph/generate_redirect/latex?%E8%AE%BF%E9%97%AE%E9%87%8F=N%20+%20(T%20-%20t)%20*%20N%20/%20T#card=math&code=%E8%AE%BF%E9%97%AE%E9%87%8F%3DN%20%2B%20%28T%20-%20t%29%20%2A%20N%20%2F%20T&id=g9l0k"><img   src="/images/loading.svg" data-src="https://www.yuque.com/api/services/graph/generate_redirect/latex?%E8%AE%BF%E9%97%AE%E9%87%8F=N%20+%20(T%20-%20t)%20*%20N%20/%20T#card=math&code=%E8%AE%BF%E9%97%AE%E9%87%8F%3DN%20%2B%20%28T%20-%20t%29%20%2A%20N%20%2F%20T&id=g9l0k"  lazyload></a>，只要<code>t</code>够小，访问量就接近<code>2N</code>。</p>
<p>虽然可以通过限制桶大小的方式使得访问量控制在<code>N</code>以内，但这样做的副作用是流量在还未达到限制条件就被禁止。<br>注意这是把漏桶视为整体后台系统一部分的角度上来看的结果，如果把漏桶视作是一个能够缓存请求的队列，单纯看从漏桶流入到下游的流量，那么因为漏桶“漏”的速率恒定，在下游是看到的是窗口内放进来N的流量。</p>
</blockquote>
<p>还有一个隐含的约束是，漏桶漏水的速度最好是一个整数值（即容量 <code>N</code> 能够整除时间窗口大小 <code>T</code> ），否则在计算剩余水量时会有些许误差。</p>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>漏桶模型中，请求来了是往桶里注水，如果反一下，把请求放行变成从桶里抽水，对应的，把注水看作是补充系统可承受流量的话，漏桶模型就变成了令牌桶模型。</p>
<p>理解漏桶之后，再看令牌桶就很简单了，抄一段令牌桶的原理：</p>
<blockquote>
<p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>
</blockquote>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FoDyELgd0gbTJ-_98vf3nPJ0wctP.jpeg"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FoDyELgd0gbTJ-_98vf3nPJ0wctP.jpeg"  lazyload></a></p>
<h3 id="代码实现TokenBucketThrottler"><a href="#代码实现TokenBucketThrottler" class="headerlink" title="代码实现TokenBucketThrottler"></a>代码实现<code>TokenBucketThrottler</code></h3><p>令牌桶与漏桶本质上是一样的，因此漏桶的代码稍微改下就可以变成令牌桶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">left = Math.min(capacity, left + (<span class="type">long</span>)((now - lastInjectTime) * velocity));</span><br><span class="line"><span class="keyword">if</span> (left - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    lastInjectTime = now;</span><br><span class="line">    left--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产环境中使用令牌桶的话，可以考虑借助<code>Guava</code>中提供的<code>RateLimiter</code>。它的实现是多线程安全的，调用<code>RateLimiter#acquire</code>时，如果剩余令牌不足，会阻塞线程一段时间直至有足够的可用令牌（而不是直接拒绝，这在某些场景下很有用）。除去默认的<code>SmoothBursty</code>策略外，<code>RateLimiter</code>还提供了一种叫<code>SmoothWarmingUp</code>的策略，支持设置一个热身期，热身期内，RateLimiter会平滑地将放令牌的速率加大，直致最大速率。设计这个的意图是为了满足那种资源提供方需要热身时间，而不是每次访问都能提供稳定速率的服务的情况(比如带缓存服务，需要定期刷新缓存) 。<code>RateLimiter</code>有一个缺点是只支持QPS级别。</p>
<h3 id="漏桶、令牌桶的区别"><a href="#漏桶、令牌桶的区别" class="headerlink" title="漏桶、令牌桶的区别"></a>漏桶、令牌桶的区别</h3><p>虽然两者本质上只是反转了一下，不过在实际使用中，适用的场景稍有差别：</p>
<ul>
<li><p>漏桶：用于控制网络中的速率。在该算法中，输入速率可以变化，但输出速率保持恒定。常常配合一个FIFO队列使用。 </p>
<blockquote>
<p>想象一下，漏桶的破洞是固定大小的，因此漏水的速率是可以保持恒定的。</p>
</blockquote>
</li>
<li><p>令牌桶：按照固定速率往桶中添加令牌，允许输出速率根据突发大小而变化。</p>
</li>
</ul>
<p>举个例子，一个系统限制60秒内的最大访问量是60次，换算速率是1次&#x2F;秒，如果在一段时间内没有访问量，那么对漏桶而言此刻是空的。现在，一瞬间涌入60个请求，那么流量整形后，漏桶会以每秒1个请求的速度，花上1分钟将60个请求漏给下游。换成令牌桶的话，则是从令牌桶中一次性取走60个令牌，一下子塞给下游。</p>
<h2 id="滑动日志"><a href="#滑动日志" class="headerlink" title="滑动日志"></a>滑动日志</h2><p>一般情况下，上述的算法已经能很好地用于大部分实际应用场景了，很少有场景需要真正完全精确的控制（即任意给定时间窗口T内请求量不大于 <code>N</code> ）。如果要精确控制的话，我们需要记录每一次用户请求日志，当每次流控判断时，取出最近时间窗口内的日志数，看是否大于流控阈值。这就是滑动日志的算法思路。</p>
<p>设想某一个时刻 <code>t</code> 有一个请求，要判断是否允许，我们要看的其实是过去 t - N 时间段内是否有大于等于 N 个请求被放行，因此只要系统维护一个队列<code>q</code>，里面记录每一个请求的时间，理论上就可以计算出从 t - N 时刻开始的请求数。</p>
<p>考虑到只需关心当前时间之前最长<code>T</code>时间内的记录，因此队列<code>q</code>的长度可以动态变化，并且队列中最多只记录<code>N</code>条访问，因此队列长度的最大值为<code>N</code>。</p>
<blockquote>
<p>滑动日志与滑动窗口非常像，区别在于滑动日志的滑动是根据日志记录的时间做动态滑动，而滑动窗口是根据子窗口的大小，以子窗口维度滑动。</p>
</blockquote>
<h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><p>算法的伪代码表示如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化</span></span><br><span class="line">counter = 0</span><br><span class="line">q = []</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请求处理流程</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.找到队列中第一个时间戳&gt;=t-T的请求，即以当前时间t截止的时间窗口T内的最早请求</span></span><br><span class="line">t = now</span><br><span class="line">start = findWindowStart(q, t)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.截断队列，只保留最近T时间窗口内的记录和计数值</span></span><br><span class="line">q = q[start, q.length - 1] </span><br><span class="line">counter -= start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.判断是否放行，如果允许放行则将这次请求加到队列 q 的末尾</span></span><br><span class="line">if counter &lt; threshold</span><br><span class="line">	push(q, t)</span><br><span class="line">	counter++</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">放行</span></span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">限流</span></span><br></pre></td></tr></table></figure>

<p><code>findWindowStart</code>的实现依赖于队列<code>q</code>使用的数据结构，以简单的数组为例，可以使用二分查找等方式。后面也会看到使用其他数据结构如何实现。</p>
<p>如果用数组实现，一个难点可能是如何截断一个队列，一种可行的思路是使用一组头尾指针<code>head</code>和<code>tail</code>分别指向数组中最近和最早的有效记录索引来解决，<code>findWindowStart</code>的实现就变成在<code>tail</code>和<code>head</code>之间查找对应元素。</p>
<h3 id="复杂度问题"><a href="#复杂度问题" class="headerlink" title="复杂度问题"></a>复杂度问题</h3><p>虽然算法解决了精确度问题，但代价也是显而易见的。</p>
<p>首先，我们要保存一个长度最大为<code>N</code>的队列，这意味着空间复杂度达到<code>O(N)</code>，如果要针对不同的key做流控，那么空间上会占用更多。当然，可以对不活跃key的队列进行复用来降低内存消耗。</p>
<p>其次，我们需要在队列中确定时间窗口，即通过<code>findWindowStart</code>方法寻找不早于当前时间戳<code>t - N</code>的请求记录。以二分查找为例，时间复杂度是<code>O(logN)</code>。</p>
<h1 id="分布式流控"><a href="#分布式流控" class="headerlink" title="分布式流控"></a>分布式流控</h1><p>现实中的应用服务往往是分布式部署的，如果共用的资源（例如数据库）或者依赖的下游服务有流量限制，那么分布式流控就要派上用场了。</p>
<blockquote>
<p>虽然可以给每台应用服务器平均分配流控配额，把问题转换为单机流控，但如果碰到流量不均匀、机器宕机、临时扩缩容等场景，这种做法的效果不佳。</p>
</blockquote>
<p>分布式环境下做流控的核心算法思路其实与单机流控是一致的，区别在于需要实现一种同步机制来保证全局配额。同步机制的实现可以有中心化和去中心化两种思路：</p>
<ul>
<li>中心化：配额由一个中心系统统一管控，应用进程通过向中心系统申请的方式获取流控配额。 <ul>
<li>状态的一致性在中心系统维护，实现简单；</li>
<li>中心系统节点的不可用会导致流控出错，需要有额外的保护。例如，中心化流控在中心存储不可用时，往往会退化为单机流控；</li>
</ul>
</li>
<li>去中心化：应用进程独立保存和维护流控配额状态，集群内周期性异步通讯以保持状态一致。 <ul>
<li>相比中心化方案，去中心化方案能够降低中心化单点可靠性带来的影响，但实现上比较复杂，状态的一致性难以保证；在CAP中去中心化更加倾向于A而中心化更倾向于C；</li>
</ul>
</li>
</ul>
<p>去中心化方案在生产环境中没有见过，因此下文只讨论中心化流控的思路。</p>
<h2 id="接入层入口流控"><a href="#接入层入口流控" class="headerlink" title="接入层入口流控"></a>接入层入口流控</h2><p>应用接入的网络架构中，在应用服务器之前往往有一层LVS或Nginx做统一入口，可以在这一层做入口的流控。本质上这就是单机流控的场景。</p>
<p>以Nginx为例，Nginx提供了<code>ngx_http_limit_req_module</code>模块用于流控，底层使用的是漏桶算法。</p>
<p>一个<code>Nginx</code>流控配置的示例如下，表示每个IP地址每秒只能请求10次<code>/login/</code>接口。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> /login/ &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=mylimit;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://my_upstream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nginx的流控指令还支持更多配置，比如说配置<code>limit_req</code>指令时加上<code>burst</code>和<code>nodelay</code>参数来允许一定程度的突发，或者结合<code>geo</code>和<code>map</code>指令来实现黑白名单流控，具体可以参考Nginx官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/rate-limiting-nginx/">Rate Limiting with NGINX and NGINX Plus</a></p>
<p>如果自带的模块不能满足，那就上自定义的lua模块吧，参考OpenResty提供的Lua限流模块<code>lua-resty-limit-traffic</code>。</p>
<h2 id="TokenServer流控"><a href="#TokenServer流控" class="headerlink" title="TokenServer流控"></a><code>TokenServer</code>流控</h2><blockquote>
<p>这里借用了Sentinel中的<code>TokenServer叫法</code>，Sentinel集群流控的介绍可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7">Sentinel集群流控</a></p>
</blockquote>
<p>这类流控的思路是找一个 <code>TokenServer</code> 来专门来管控流控配额，包括统计总调用量，判断单个请求是否允许等等，应用服务器作为客户端与<code>TokenServer</code>通信来获取配额。因为流控的逻辑在<code>TokenServer</code>内部统一处理，因此单机流控中讨论的算法同样适用。</p>
<p>很自然地能想到，这类流控非常依赖于<code>TokenServer</code>的性能和可用性。</p>
<p>性能方面，单点的<code>TokenServer</code>很容易成为瓶颈，查Sentinel源码，其中使用了Netty来做网络通信，数据包采用自定义格式，其他性能优化能找到的不多。</p>
<p>可用性方面，就像Sentinel官方文档中讲的，若在生产环境使用<code>TokenServer</code>集群限流，必须要解决以下问题：</p>
<ul>
<li>Token Server 自动管理、调度（分配&#x2F;选举 Token Server）</li>
<li>Token Server 高可用，在某个 server 不可用时自动 failover 到其它机器</li>
</ul>
<p>目前Sentinel的<code>TokenServer</code>默认并没有实现这些能力，需要定制或增加其他系统来实现，例如，采用一种分布式一致性协议来做集群选举，或者借助一组<code>monitor</code>来监控状态，实现成本还是挺高的。</p>
<h2 id="存储式流控"><a href="#存储式流控" class="headerlink" title="存储式流控"></a>存储式流控</h2><p>存储式流控的思想是通过一个存储系统来保存流控的计数值等统计信息，应用从存储中获取统计信息，然后将最新的请求信息再写入存储中。存储系统可以选择现成的MySQL数据库或者Redis缓存等，一般从性能出发选择缓存的比较多。这里选择集团的Tair和流行的Redis做例子。</p>
<h3 id="Tair流控"><a href="#Tair流控" class="headerlink" title="Tair流控"></a>Tair流控</h3><p>比较简单，直接上代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">  <span class="comment">// 以秒为单位构建tair的key</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">wrappedKey</span> <span class="operator">=</span> wrapKey(key);</span><br><span class="line">  <span class="comment">// 每次请求+1，初始值为0，key的有效期设置5s</span></span><br><span class="line">  Result&lt;Integer&gt; result = tairManager.incr(NAMESPACE, wrappedKey, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> result.isSuccess() &amp;&amp; result.getValue() &lt;= threshold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">wrapKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">sec</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000L</span>;</span><br><span class="line">  <span class="keyword">return</span> key + <span class="string">&quot;:&quot;</span> + sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉太简单了点？但打听下来，像集团的TOP（淘宝开放平台），钉钉开放平台用的都是这种方式。得益于Tair的高性能，这种方式可以很好地支撑大流量。</p>
<p>这种Tair流控的方案实际上用的简单窗口的思路，每个key以每秒为一个时间窗口做QPS控制（QPM&#x2F;QPD原理类似）。关键在于用到了TAIR的这个API：</p>
<blockquote>
<h3 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h3><p>Result incr(int namespace, Serializable key, int value, int defaultValue, int expireTime)</p>
<h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>增加计数。注意：incr前不要put！！</p>
<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>namespace - 申请时分配的namespace<br>key - key列表，不超过1k<br>value - 增加量<br>defaultValue - 第一次调用incr时的key的count初始值，第一次返回的值为defaultValue + value。<br>expireTime - 数据过期时间，单位为秒，可设相对时间或绝对时间(Unix时间戳)。expireTime &#x3D; 0，表示数据永不过期。expireTime &gt; 0，表示设置过期时间。若expireTime&gt;当前时间的时间戳，则表示使用绝对时间，否则使用相对时间。expireTime &lt; 0，表示不关注过期时间，若之前设过过期时间，则已之前的过期时间为准，若没有，则作为永不过期处理，但当前mdb统一当做永不过期来处理。</p>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>Result对象，返回值可为负值。当key不存在时，第一次返回defaultValue+ value。 后续的incr基于该值增加value。</p>
</blockquote>
<p>当然这种方式也有缺点：</p>
<ul>
<li>简单窗口的临界突变问题。 </li>
<li>Tair的可靠性问题，需要有降级方案。上面其实也说了，中心化的流控一般都需要搭配降级的单机流控。 </li>
<li>集群机器的时间同步问题。由于生成key会用到集群机器的本地时间，因此要求机器时间必须是一致的。 <blockquote>
<p>打个比方，不同机器时间稍微差个10ms，在时间窗口的间隔点上的统计就会产生比较大的误差，比如说在同一时刻，一台机器时间是0.990，一台是1.000，两者调用incr时操作的key不一样，精度自然就会受影响。</p>
</blockquote>
</li>
</ul>
<h3 id="Redis流控"><a href="#Redis流控" class="headerlink" title="Redis流控"></a>Redis流控</h3><p>Redis支持丰富的数据结构，性能也不错，其“单进程”模型方便同步控制，因此非常适合用来做分布式流控的存储。</p>
<h4 id="简单窗口实现"><a href="#简单窗口实现" class="headerlink" title="简单窗口实现"></a>简单窗口实现</h4><p>使用Redis实现简单窗口流控的思路跟使用Tair是一致的。Redis也提供了<code>INCR</code>命令用于计数，同时Redis的“单进程”模型也提供了很好的并发保护。Redis的官方文档就写了如何使用<code>INCR</code>来实现Rate Limiter，我这里稍作翻译了下。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/incr">Redis INCR key</a></p>
<p>以简单窗口为例，最简单直接的实现如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">ts = CURRENT_UNIX_TIME()</span><br><span class="line">keyname = ip+<span class="string">&quot;:&quot;</span>+ts</span><br><span class="line">current = GET(keyname)</span><br><span class="line">IF current != NULL AND current &gt; <span class="number">10</span> THEN</span><br><span class="line">    ERROR <span class="string">&quot;too many requests per second&quot;</span></span><br><span class="line">ELSE</span><br><span class="line">    MULTI</span><br><span class="line">        INCR(keyname,<span class="number">1</span>)</span><br><span class="line">        EXPIRE(keyname,<span class="number">10</span>)</span><br><span class="line">    EXEC</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>实现上与上述的Tair类似，也是对每个key以秒为单位维护一个计数器，差别在于因为Redis没有提供原子的<code>INCR</code> + <code>EXPIRE</code>指令，所以在<code>INCR</code>之后需要再调用一次<code>EXPIRE</code>来设置key的有效期。同时在外层以<code>MULTI</code>和<code>EXEC</code>包裹以保证事务性。</p>
<p>如果不想每次都调用<code>EXPIRE</code>，可以考虑第二种方式：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip):</span><br><span class="line">current = GET(ip)</span><br><span class="line">IF current != NULL AND current &gt; <span class="number">10</span> THEN</span><br><span class="line">    ERROR <span class="string">&quot;too many requests per second&quot;</span></span><br><span class="line">ELSE</span><br><span class="line">    value = INCR(ip)</span><br><span class="line">    IF value == <span class="number">1</span> THEN</span><br><span class="line">        EXPIRE(ip,<span class="number">1</span>)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>计数器的有效期在第一次<code>INCR</code>时设置为1s，因此不需要对key进行额外处理。</p>
<p>不过需要注意的是，这种方式存在一种隐藏的竞争条件。如果客户端在第一次调用了<code>INCR</code>后，由于应用崩溃或其他原因没有调用<code>EXPIRE</code>，计数器会一直存在。</p>
<p>针对方式二的这个问题，可以用lua脚本解决：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> current</span><br><span class="line">current = redis.call(<span class="string">&quot;incr&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(current) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;expire&quot;</span>,KEYS[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>第三种方式是通过Redis的list结构来实现。更复杂一些但可以记录下每次的请求。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION LIMIT_API_CALL(ip)</span><br><span class="line">current = LLEN(ip)</span><br><span class="line">IF current &gt; <span class="number">10</span> THEN</span><br><span class="line">    ERROR <span class="string">&quot;too many requests per second&quot;</span></span><br><span class="line">ELSE</span><br><span class="line">    IF EXISTS(ip) == FALSE				#<span class="number">1</span></span><br><span class="line">        MULTI</span><br><span class="line">            RPUSH(ip,ip)</span><br><span class="line">            EXPIRE(ip,<span class="number">1</span>)</span><br><span class="line">        EXEC</span><br><span class="line">    ELSE</span><br><span class="line">        RPUSHX(ip,ip)</span><br><span class="line">    END</span><br><span class="line">    PERFORM_API_CALL()</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>这里也有一个隐含的竞争条件，在执行到<code>EXIST</code>判断这一行（#1位置）时，两个客户端的<code>EXIST</code>命令可能都会返回false，因此<code>MULTI</code>&#x2F;<code>EXEC</code>块里的命令会被执行两次，不过这种情况很少出现，不太会影响计数器的准确性。</p>
<blockquote>
<p>上述的几种方式还可以进一步优化，因为<code>INCR</code>和<code>RPUSH</code>这些命令都会返回操作后的计数器值，所以可以使用set-then-get的方式获取计数器值。</p>
</blockquote>
<p>将简单窗口改造成滑动窗口也是类似的思路，把单一的key换成一个hash结构，hash里面为每个子窗口保存一个计数值，在统计时，将同个hash中所有子窗口的计数值相加即可。</p>
<h4 id="令牌桶-x2F-漏桶实现"><a href="#令牌桶-x2F-漏桶实现" class="headerlink" title="令牌桶&#x2F;漏桶实现"></a>令牌桶&#x2F;漏桶实现</h4><p>用Redis实现令牌桶或者漏桶也非常简单。以令牌桶为例，在实现上，可以用两个key分别存储每个用户的可用token数和上次请求时间，另一种可能更好的办法是使用Redis的hash数据结构。</p>
<p>下图的示例是一个用户user_1当前在redis中保存的流控配额数据：令牌桶中当前剩余2个token，最近一次访问的时间戳是1490868000。<br><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Flh0ipdB3iyjfMBj1fdTyCOwkbku.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Flh0ipdB3iyjfMBj1fdTyCOwkbku.png"  lazyload></a><br>当收到一个新请求时，Redis客户端要执行的操作与我们在单机流控算法中看到的一样。首先，从对应hash中获得当前配额数据（<code>HGETALL</code>），根据当前时间戳、上次请求的时间戳和token填充速度计算要填充的token数；然后，判断是否放行，更新新的时间戳和token数（<code>HMSET</code>）。</p>
<p>一个示例如下：</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmccrKokT2v21h5pXi_82lZ4Schk.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmccrKokT2v21h5pXi_82lZ4Schk.png"  lazyload></a></p>
<p>同样的，如果要求比较高的精度，这里必须要对客户端的操作做并发控制。</p>
<p>不做同步控制可能导致的问题示例：桶里只有一个token，两个客户端同时请求时出现并发冲突，结果是请求都会放行。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuWi7S1_WXiqeiRI_sgbjsw2VLWE.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FuWi7S1_WXiqeiRI_sgbjsw2VLWE.png"  lazyload></a><br>lua代码示例如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> tokens_key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> timestamp_key = KEYS[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> fill_time = capacity/rate</span><br><span class="line"><span class="keyword">local</span> ttl = <span class="built_in">math</span>.<span class="built_in">floor</span>(fill_time*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> last_tokens = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;get&quot;</span>, tokens_key))</span><br><span class="line"><span class="keyword">if</span> last_tokens == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">  last_tokens = capacity</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> last_refreshed = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;get&quot;</span>, timestamp_key))</span><br><span class="line"><span class="keyword">if</span> last_refreshed == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">  last_refreshed = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> delta = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, now-last_refreshed)</span><br><span class="line"><span class="keyword">local</span> filled_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, last_tokens+(delta*rate))</span><br><span class="line"><span class="keyword">local</span> allowed = filled_tokens &gt;= requested</span><br><span class="line"><span class="keyword">local</span> new_tokens = filled_tokens</span><br><span class="line"><span class="keyword">if</span> allowed <span class="keyword">then</span></span><br><span class="line">  new_tokens = filled_tokens - requested</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&quot;setex&quot;</span>, tokens_key, ttl, new_tokens)</span><br><span class="line">redis.call(<span class="string">&quot;setex&quot;</span>, timestamp_key, ttl, now)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123; allowed, new_tokens &#125;</span><br></pre></td></tr></table></figure>

<h4 id="滑动日志实现"><a href="#滑动日志实现" class="headerlink" title="滑动日志实现"></a>滑动日志实现</h4><p>得益于Redis的Sorted Set结构，实现滑动日志变得异常简单。流程大致如下：</p>
<ul>
<li>每个用户有一个对应的Sorted Set记录请求日志； <ul>
<li>其中每个元素的key和value可以是相同的，即请求的时间戳；</li>
<li>Sorted Set可以根据时间窗口大小设置有效期，比如时间窗口为1s时设置过期时间5s，在请求量不大时可以节省Redis服务器内存；</li>
</ul>
</li>
<li>当收到一个新的用户请求时，首先通过<code>ZREMRANGEBYSCORE</code>命令删除Sorted Set中过期的元素，这里的过期即<code>请求时间戳t &lt; 当前时间戳now - 时间窗口大小interval</code>；</li>
<li>使用<code>ZADD</code>将当前请求添加到Set中；</li>
<li>使用<code>ZCOUNT</code>获取当前剩余Set大小，判断是否需要流控；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">maxScoreMs</span> <span class="operator">=</span> now - windowInSecond * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">redis</span> <span class="operator">=</span> jedisPool.getResource().multi();</span><br><span class="line">redis.zremrangeByScore(key, <span class="number">0</span>, maxScoreMs);</span><br><span class="line">redis.zadd(key, now, now + <span class="string">&quot;-&quot;</span> + Math.random()); <span class="comment">// 加入一个随机值使得member不重复</span></span><br><span class="line">redis.expire(key, windowInSecond);</span><br><span class="line">redis.exec();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/peterkhayes/rolling-rate-limiter/blob/master/index.js">另一个js实现的代码示例</a></p>
</blockquote>
<p>由于滑动日志算法的空间复杂度较其他算法高，使用滑动日志算法时，需要注意监控Redis内存的使用量。</p>
<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><p>上面的几种算法都提到了不做并发控制可能带来的竞态条件，但额外的并发控制必然会带来性能下降，通常需要在精度和性能之间做取舍。Redis流控的并发控制常见的有几类：</p>
<ul>
<li>使用Redis事务<code>MULTI</code>&#x2F;<code>EXEC</code>； </li>
<li>使用<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">RedLock</a>等分布式锁，要求每个客户端操作前先获取对应key的分布式锁； </li>
<li>Lua脚本；</li>
</ul>
<p>最好通过性能测试来决定使用哪一种方式。</p>
<h2 id="扩展的一些思考"><a href="#扩展的一些思考" class="headerlink" title="扩展的一些思考"></a>扩展的一些思考</h2><p>分布式流控带来了网络通信、加锁同步等开销，会对性能带来一定影响。同时分布式环境的可靠性也会带来更多挑战。如何设计一个高性能、高可靠性的分布式流控系统？这可能是个涉及到整个系统方方面面的大话题。</p>
<p>分享一下个人的一些思考，欢迎讨论。</p>
<ol>
<li>根据实际诉求，合理搭配不同层的多级流控是个不错的方式，尽量把流量拦在外层。例如常见的接口层Nginx流控+应用层流控。</li>
<li>选择一个合适的缓存系统保存流控的动态数据，这个一般跟着公司的统一技术架构走，像集团内一般就选择Tair&#x2F;Redis了（否则就要考虑单独运维的开销了）。</li>
<li>将流控的静态配置放到配置中心（例如Diamond）。</li>
<li>设计时要考虑分布式流控不可用的情况（例如缓存挂掉），必要时切到单机流控，使用Sentinel成熟可靠。</li>
<li>很多时候对精度的要求没那么高，因为一般都会允许一定的突发量。这时候可以做一些性能的优化。性能的最大瓶颈在于每次请求都会访问一次缓存，可以结合本地+分布式的方式优化。我之前在设计时就采用了一种折中的办法： <ul>
<li>将可用配额的一部分，按一定比例（例如50%），先预分配给集群内的机器。</li>
<li>一般是平均分配，如果预先就已经知道每台机器的流量权重，可以加权分配。</li>
<li>每台机器消耗配额的速率不同，中间也可能有机器宕机，可能有扩缩容，因此预分配的比例不宜太大，当然也不宜太小。</li>
<li>每台机器在配额耗尽前，使用本地计数做流控，因此性能能够得到保障。与此同时，可以异步地将计数聚合后提交给中心存储（例如redis），聚合提交的频率按实际的精度需求做控制。</li>
<li>每台机器在配额耗尽时，向中心系统请求配额，这里的一个优化点是每台机器会记录自身配额消耗的速率（等同于承受的流量速率），按照速率大小申请不同大小的配额，消耗速率大则一次性申请更多。</li>
<li>在整体可用配额不足一定比例时（例如10%），限制每台机器一次可申请的配额数，按剩余窗口大小计算发放配额的大小，并且每次发放量不超过剩余配额的一定比例（例如50%），使得剩余的流量能够平滑地过渡。</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>拖了几个月终于写到总结这一节了，看了一下居然攒了近2万字了。</p>
</blockquote>
<p>分布式流控的算法其实是单机流控的延伸，算法本质是一样的。这里按我的个人理解总结了上述几种流控算法的复杂度和适用场景。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>简单窗口</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>容易实现，适用于一些简单的流控场景，流量比较均匀，或者允许临界突变</td>
</tr>
<tr>
<td>滑动窗口</td>
<td><code>O(1)</code></td>
<td><code>O(M)</code> - <code>M</code>为子窗口数</td>
<td>适用大多数场景，可以通过调节采样子窗口数来平衡开销</td>
</tr>
<tr>
<td>漏桶</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>要求输出速率恒定的场景，能够平滑流量</td>
</tr>
<tr>
<td>令牌桶</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td>与漏桶类似，区别在于允许一定的突发流量</td>
</tr>
<tr>
<td>滑动日志</td>
<td><code>O(log(N))</code>  - 取决于选择的数据结构</td>
<td><code>O(N)</code> - <code>N</code>为时间窗口内允许的最大请求量</td>
<td>要求完全精确的控制，保证任意<code>T</code>时刻内流量不超过<code>N</code>，高时间和空间复杂度，性能最差</td>
</tr>
</tbody></table>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%B5%81%E6%8E%A7%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="top-box-text">流控的场景</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="top-box-text">接口定义</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%8D%95%E6%9C%BA%E6%B5%81%E6%8E%A7"><span class="top-box-text">单机流控</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%AE%80%E5%8D%95%E7%AA%97%E5%8F%A3"><span class="top-box-text">简单窗口</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0SimpleWindowThrottler"><span class="top-box-text">代码实现SimpleWindowThrottler</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%87%E6%8D%A2%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="top-box-text">切换到多线程环境</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%B8%B4%E7%95%8C%E7%AA%81%E5%8F%98%E9%97%AE%E9%A2%98"><span class="top-box-text">临界突变问题</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="top-box-text">滑动窗口</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%8F%82%E8%80%83Sentinel%EF%BC%89"><span class="top-box-text">代码实现（参考Sentinel）</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="top-box-text">精度问题</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%B9%B3%E6%BB%91%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="top-box-text">平滑度问题</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%BC%8F%E6%A1%B6"><span class="top-box-text">漏桶</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0LeakyBucketThrottler"><span class="top-box-text">代码实现LeakyBucketThrottler</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%BC%8F%E6%A1%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="top-box-text">漏桶的问题</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="top-box-text">令牌桶</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0TokenBucketThrottler"><span class="top-box-text">代码实现TokenBucketThrottler</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%BC%8F%E6%A1%B6%E3%80%81%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="top-box-text">漏桶、令牌桶的区别</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%BB%91%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="top-box-text">滑动日志</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="top-box-text">伪代码实现</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="top-box-text">复杂度问题</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%81%E6%8E%A7"><span class="top-box-text">分布式流控</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8E%A5%E5%85%A5%E5%B1%82%E5%85%A5%E5%8F%A3%E6%B5%81%E6%8E%A7"><span class="top-box-text">接入层入口流控</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#TokenServer%E6%B5%81%E6%8E%A7"><span class="top-box-text">TokenServer流控</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AD%98%E5%82%A8%E5%BC%8F%E6%B5%81%E6%8E%A7"><span class="top-box-text">存储式流控</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Tair%E6%B5%81%E6%8E%A7"><span class="top-box-text">Tair流控</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#incr"><span class="top-box-text">incr</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#Redis%E6%B5%81%E6%8E%A7"><span class="top-box-text">Redis流控</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="top-box-text">扩展的一些思考</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%80%BB%E7%BB%93"><span class="top-box-text">总结</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2019/08/07/yi-ge-spring-shi-jian-hong-fa-wen-ti-de-ding-wei-guo-cheng/">
          <h3 class="post-title">
            下一篇：一个Spring事件触发问题的定位过程
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>


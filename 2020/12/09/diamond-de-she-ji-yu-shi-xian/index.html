<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>Diamond的设计与实现</title>
<meta name="keywords" content="Diamond的设计与实现, jffu&#39;s blog">
<meta name="description" content="如何设计和实现一个分布式配置中心">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Diamond的设计与实现">
<meta property="og:description" content="如何设计和实现一个分布式配置中心">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://jffu.github.io">
        <img class="avatar" src="/images/avatar.jpeg" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://jffu.github.io">
        <h1 class="site-title">jffu&#39;s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">Diamond的设计与实现</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2020-12-09</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Java/">
              Java
                
                  ，
                
              </a>
            
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">
              中间件
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1 架构设计"></a>1 架构设计</h1><p>Diamond提供两大类能力：持久化配置管理和动态配置推送。遵循“可靠、易用、高效”的产品目标设计，架构设计上看简单、可靠。</p>
<h2 id="1-1-组件架构"><a href="#1-1-组件架构" class="headerlink" title="1.1 组件架构"></a>1.1 组件架构</h2><p><a class="simple-lightbox" target="_blank" rel="noopener" href="http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/middleware/diamond/2aa8af9f176b98469604d7ac9b05969e/framework.png"><img   src="/images/loading.svg" data-src="http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/middleware/diamond/2aa8af9f176b98469604d7ac9b05969e/framework.png"  lazyload></a></p>
<p>参考<a target="_blank" rel="noopener" href="https://aliyuque.antfin.com/softloadblance/wpnllg/sgqvfy">Diamond架构及优势</a>，从服务端视角看，整个Diamond服务由三个组件构成：</p>
<ul>
<li><p><strong>地址服务器组件</strong></p>
<p>与ConfigServer的地址服务器功能一样，提供Diamond服务发现功能。客户端（<code>diamond-client</code>）通过访问<code>address-server</code>（<code>jmenv.tbsite.net</code>）获得<code>diamond-server</code>的地址列表。</p>
</li>
<li><p><strong>diamond-server集群</strong></p>
<p>Diamond服务的核心，去中心化结构部署，集群节点间通过特定机制实现数据变更的增量同步。</p>
</li>
<li><p><strong>MySQL存储</strong></p>
<p>Diamond使用MySQL持久化存储配置数据，<code>diamond-server</code>通过定时从MySQL dump数据来保持数据的正确性，在收到<code>diamond-client</code>发来的数据变更时，也会通知其他节点从MySQL中获取最新数据。</p>
</li>
</ul>
<h2 id="1-2-缓存和容灾"><a href="#1-2-缓存和容灾" class="headerlink" title="1.2 缓存和容灾"></a>1.2 缓存和容灾</h2><p>Diamond设计中，在Client端和Server端使用了多个层次的缓存和容灾机制。</p>
<ul>
<li><p>服务端</p>
<ul>
<li><p>MySQL</p>
<pre><code>主备部署，备库会从主库异步同步数据。主库不可用时切换到备库容灾，还可以提供配置读写服务。
</code></pre>
</li>
<li><p>磁盘缓存</p>
<pre><code>- `diamond-server`每个节点都以本地磁盘文件的形式保存了全量的配置数据作为cache，在一个节点挂掉时其他节点能够替代提供服务（`diamond-client`会自动切换到其他节点）。
- 客户端请求配置数据时，直接读取磁盘缓存返回，避免每个请求都直接访问数据库。
- 在MySQL的主备库都宕机时可以读取缓存数据提供读服务（但无法写，因为最终需要持久化到MySQL）。
</code></pre>
</li>
</ul>
</li>
<li><p>客户端</p>
<ul>
<li>快照缓存</li>
<li>可以手动干预的容灾文件</li>
</ul>
<blockquote>
<p>mysql主备库、diamond-server集群整体不可用时，客户端可以借助缓存目录继续使用配置读服务，借助容灾目录使用配置写服务。</p>
</blockquote>
</li>
</ul>
<h2 id="1-3-数据同步"><a href="#1-3-数据同步" class="headerlink" title="1.3 数据同步"></a>1.3 数据同步</h2><blockquote>
<ul>
<li><code>diamond-server</code>间：<code>diamond-server</code>首先将数据写入MySQL，然后写入本地文件，最后发送请求给其余server，其余server收到请求后从MySQL中dump刚刚写入的数据至本地。</li>
<li><code>diamond-server</code>与MySQL间：<code>diamond-server</code>启动后会开启一个定时任务，定时从MySQL中dump所有数据至本地。</li>
<li><code>diamond-client</code>与<code>diamond-server</code>间：<code>diamond-server</code>中含有所有数据的MD5值，当数据更新时，其对应的MD5也将被更新。<code>diamond-client</code>获取数据时会将订阅数据和它的MD5值都取回来，然后开启一个定时任务去检验<code>diamond-server</code>端的MD5是否变化，如果有变化，则请求最新的数据，并写入<code>diamond-client</code>缓存。</li>
</ul>
</blockquote>
<h2 id="1-4-配置获取和发布"><a href="#1-4-配置获取和发布" class="headerlink" title="1.4 配置获取和发布"></a>1.4 配置获取和发布</h2><p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FlQ6lrkgSlAwBFiIK2VXhtVk4A2m.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FlQ6lrkgSlAwBFiIK2VXhtVk4A2m.png"  lazyload></a></p>
<p><strong>配置获取：</strong></p>
<p>在<code>diamond-client</code>调用<code>Diamond#getConfig</code>后，配置读取顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client获取配置</span></span><br><span class="line">Client本地容灾文件 --&gt; `diamond-server`磁盘缓存 --&gt; （如果从Server获取失败）Client本地快照文件</span><br></pre></td></tr></table></figure>

<p>默认情况下，配置由<code>diamond-server</code>磁盘缓存返回，效率很高。</p>
<p><strong>配置发布</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client发布配置</span></span><br><span class="line">`diamond-server` --&gt; MySQL --&gt; 异步通知集群节点 --&gt; </span><br><span class="line">集群节点：读取MySQL --&gt; 更新磁盘缓存</span><br></pre></td></tr></table></figure>

<h2 id="1-5-配置推送"><a href="#1-5-配置推送" class="headerlink" title="1.5 配置推送"></a>1.5 配置推送</h2><p><code>diamond-client</code>使用Http长轮询来获取配置变更事件。</p>
<p><strong>个人理解</strong>：Http长轮询相比WebSocket，缺点在于每推送一次数据需要建立一次连接。对于Diamond来说，配置数据需要是不会频繁变更的，否则会导致在长轮询过程中需要频繁建立新的连接去获取数据。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/middleware/diamond/7a8233c8538dbb4c60e7b0a98c944340/longPull.png"><img   src="/images/loading.svg" data-src="http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/middleware/diamond/7a8233c8538dbb4c60e7b0a98c944340/longPull.png"  lazyload></a></p>
<h2 id="1-6-与ConfigServer比较"><a href="#1-6-与ConfigServer比较" class="headerlink" title="1.6 与ConfigServer比较"></a>1.6 与ConfigServer比较</h2><p>Diamond的设计在一定程度上沿袭了ConfigServer，也会根据两者使用场景差异有所不同。</p>
<blockquote>
<p>ConfigServer和VIPServer同属于软负载领域的产品，Diamond本质上是一款配置管理产品。</p>
</blockquote>
<ul>
<li>地址服务器组件，两者都使用同样的机制提供服务发现功能<ul>
<li>client启动时从<code>address-server</code>获取服务器地址列表，并且将地址列表保存在client本地。保存在本地的目的是一旦从远端无法获取地址列表时，client会使用本地保存的地址列表；</li>
<li>地址服务器各套环境绑定到不同IP上，实现隔离；</li>
</ul>
</li>
<li>多级容灾机制<ul>
<li>ConfigServer的Client在memory和file中各缓存一份服务地址</li>
<li>Diamond的Client本地维护快照缓存和容灾文件</li>
<li>ConfigServer在session server缓存已经压缩过的pub数据，data server保存全量数据</li>
<li>Diamond的Server在磁盘上缓存数据，并使用MySQL持久化</li>
</ul>
</li>
<li>在配置数据变化时，都会进行集群间同步。区别是：<ul>
<li>Diamond会将数据持久化到MySQL，然后通知其他节点从MySQL读取数据</li>
<li>ConfigServer3.0以后，Session Server把数据多写给Data Server集群</li>
</ul>
</li>
<li>Client跟Server维持长连接用于数据变更时及时同步<ul>
<li>ConfigServer与client之间使用TCP长连接</li>
<li>DiamondServer与client之间使用Http长连接（超时后重连）</li>
</ul>
</li>
<li>都是AP的系统架构，牺牲强一致性</li>
<li>待补充</li>
</ul>
<h1 id="2-diamond-client实现"><a href="#2-diamond-client实现" class="headerlink" title="2 diamond-client实现"></a>2 diamond-client实现</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><code>Diamond</code>提供了客户端的client-sdk用于从Diamond服务端获取配置数据。<code>diamond-client</code>在设计和使用上都比较简单。可以与<code>Diamond</code>服务端代码结合起来看来了解<code>Diamond</code>的整体架构。</p>
<p><code>diamond-client</code>在设计上有两个值得关注的点：</p>
<ul>
<li><p>容灾策略</p>
<p>解决如何在与服务端连接出问题的情况下保证配置的可用，<code>diamond-client</code>使用了本地的容灾和缓存文件。</p>
</li>
<li><p>配置监听</p>
<p><code>ConfigServer</code>使用了TCP长连接来监听服务端数据的变化，<code>Diamond</code>也是类似，<code>diamond-client</code>使用HTTP长轮询机制与一个服务端节点保持连接。</p>
</li>
</ul>
<h2 id="2-2-主要类"><a href="#2-2-主要类" class="headerlink" title="2.2 主要类"></a>2.2 主要类</h2><ol>
<li><p><code>CacheData</code></p>
<ul>
<li>缓存了每对<code>dataID</code>+<code>group</code>的配置数据</li>
<li>管理对应的监听器列表</li>
<li>缓存配置相关的重要字段，例如md5，是否使用本地容灾数据的标志位等</li>
</ul>
</li>
<li><p><code>ClientWorker</code><br> <code>diamond-client</code>中关键的一个类，用于执行获取配置任务，包括：</p>
<ul>
<li>静态方法<code>getServerConfig()</code>用于同步获取</li>
<li>后台定时任务<code>LongPullingRunnable</code>用于异步获取</li>
</ul>
<p> <a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fs53Tcr0u20caxBr_NYdJllXWpfy.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Fs53Tcr0u20caxBr_NYdJllXWpfy.png"  lazyload></a></p>
</li>
<li><p><code>Diamond</code>、<code>DiamondEnv</code><br> <code>Diamond</code>类是<code>diamond-client</code>的入口，它提供一系列静态方法用于获取配置数据，设置监听器等，内部调用<code>DiamondEnv</code>的方法。</p>
<p> <a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ft-DidVlCdP9a1XC_vZ5FcHrHFtj.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/Ft-DidVlCdP9a1XC_vZ5FcHrHFtj.png"  lazyload></a></p>
</li>
<li><p><code>ServerHttpAgent</code><br> 在<code>ServerHttpAgent</code>中会调用底层HTTP框架的方法向Diamond服务端发送请求。参考<code>httpGet()</code>和<code>httpPost</code>两个方法，两个注意点：</p>
<ul>
<li>按照优先级顺序给server发请求，直到某个server请求成功</li>
<li>粘性，如果请求某个server成功，那么下个请求也会首先发给该server</li>
</ul>
</li>
</ol>
<h2 id="2-3-代码流程"><a href="#2-3-代码流程" class="headerlink" title="2.3 代码流程"></a>2.3 代码流程</h2><p><code>diamond-client</code>的代码主要都是获取配置相关。</p>
<h3 id="2-3-1-手动获取配置"><a href="#2-3-1-手动获取配置" class="headerlink" title="2.3.1 手动获取配置"></a>2.3.1 手动获取配置</h3><p>适用启动只用一次场景，直接get获取配置值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">configData</span> <span class="operator">=</span> Diamond.getConfig(dataId, group, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmEZgfnGd-7tIihmuIO6YOFi13xT.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FmEZgfnGd-7tIihmuIO6YOFi13xT.png"  lazyload></a></p>
<p>这种方式获取配置的流程按照<strong>本地容灾 -&gt; server -&gt; 本地缓存</strong>的优先级获取配置。</p>
<ol>
<li>查看本地容灾文件，如果文件存在，则读取文件内容返回<ul>
<li>参考路径：<code>~/diamond/default_diamond/data/config-data/group/dataId</code></li>
</ul>
</li>
<li>如果没有容灾文件，发送HTTP GET请求到<code>diamond-server</code>获取数据<ul>
<li>需要先去请求name server服务器，获取Diamond服务器的地址列表。获取到<code>diamond-server</code>地址列表后，会将地址列表存放到客户端本地缓存中。待name server服务器不可用时，直接从本地缓存中获取</li>
</ul>
</li>
<li>如果获取成功，则保存一份快照数据到本地（之前的文件会被覆盖）<ul>
<li>参考路径：<code>~/diamond/default_diamond/snapshot/group/dataId</code></li>
</ul>
</li>
<li>如果获取失败，则从本地快照文件中读取配置数据</li>
</ol>
<p>使用这种获取顺序的原因：</p>
<ol>
<li><p>如果本地容灾文件存在，说明已经进入容灾模式（？），直接读取容灾文件内容</p>
</li>
<li><p>考虑到<code>Diamond.getConfig()</code>使用场景一般是启动后获取一次，优先从<code>diamond-server</code>获取最新数据，而不是从本地快照中读取，因为快照中数据可能已经过时</p>
</li>
<li><p>如果Client跟<code>diamond-server</code>之间连接出现问题，导致从<code>diamond-server</code>获取配置失败，那么使用上次成功获取后保存的快照内容，如果这中间有数据变化，存在数据不一致的风险</p>
</li>
</ol>
<p>主要代码位于<code>DiamondEnv#getConfigInner</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getConfig()内部调用getConfigInner()</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getConfigInner</span><span class="params">(String tenant, String dataId, String group, <span class="type">long</span> timeoutMs)</span> <span class="keyword">throws</span> DiamondException &#123;</span><br><span class="line">	<span class="comment">// 省略参数校验和Mock返回等逻辑</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造响应对象，设置DataId、Group等</span></span><br><span class="line">    <span class="type">ConfigResponse</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigResponse</span>();</span><br><span class="line"></span><br><span class="line">    cr.setDataId(dataId);</span><br><span class="line">    cr.setTenant(tenant);</span><br><span class="line">    cr.setGroup(group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先读取本地容灾文件，如果有数据则返回</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> LocalConfigInfoProcessor.getFailover(<span class="built_in">this</span>, dataId, group, tenant);</span><br><span class="line">    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.warn(getName(), <span class="string">&quot;[get-config] get failover ok, dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, config=&#123;&#125;&quot;</span>, dataId,</span><br><span class="line">                group, tenant, ContentUtils.truncateContent(content));</span><br><span class="line">        cr.setContent(content);</span><br><span class="line">        configFilterChainManager.doFilter(<span class="literal">null</span>, cr);</span><br><span class="line">        content = cr.getContent();</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 从`diamond-server`获取配置数据，如果成功内部会保存一份到本地快照文件</span></span><br><span class="line">        content = ClientWorker.getServerConfig(<span class="built_in">this</span>, dataId, group, tenant, timeoutMs);</span><br><span class="line">        cr.setContent(content);</span><br><span class="line">        configFilterChainManager.doFilter(<span class="literal">null</span>, cr);</span><br><span class="line">        content = cr.getContent();</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DiamondException ioe) &#123;</span><br><span class="line">		<span class="comment">// 省略异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一句打印放读取之后更合理点？</span></span><br><span class="line">    log.warn(getName(), <span class="string">&quot;[get-config] get snapshot ok, dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, config=&#123;&#125;&quot;</span>, dataId, group,</span><br><span class="line">            tenant, ContentUtils.truncateContent(content));</span><br><span class="line">    <span class="comment">// 3. 如果从`diamond-server`获取失败，则尝试读取本地快照文件</span></span><br><span class="line">    content = LocalConfigInfoProcessor.getSnapshot(<span class="built_in">this</span>, dataId, group, tenant);</span><br><span class="line">    cr.setContent(content);</span><br><span class="line">    configFilterChainManager.doFilter(<span class="literal">null</span>, cr);</span><br><span class="line">    content = cr.getContent();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-监听获取配置"><a href="#2-3-2-监听获取配置" class="headerlink" title="2.3.2 监听获取配置"></a>2.3.2 监听获取配置</h3><h4 id="2-3-2-1-主流程"><a href="#2-3-2-1-主流程" class="headerlink" title="2.3.2.1 主流程"></a>2.3.2.1 主流程</h4><p><code>diamond-client</code>会在后台启动一个线程池执行长轮询定时(默认10ms)任务<code>ClientWorker#LongPullingRunnable</code>，用于检查配置数据更新。</p>
<p><a class="simple-lightbox" target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FrE_vsG__AIrnNRZMWonR1xcdO2g.png"><img   src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/jffu/jffu-blog-images@main/img/FrE_vsG__AIrnNRZMWonR1xcdO2g.png"  lazyload></a></p>
<p>主体流程：</p>
<ol>
<li><p>遍历所有的缓存数据对象<code>CacheData</code>，检查本地容灾文件数据，判断是否要优先从本地容灾文件读取</p>
<ul>
<li>如果使用本地容灾文件读取（<code>isUseLocalConfigInfo</code>标记位为true），那么调用<code>checkListenerMd5()</code>检查md5是否变化，如果变化，通知监听器更新</li>
</ul>
</li>
<li><p>检查完本地容灾数据后，再检查服务端数据是否有更新</p>
<ul>
<li>调用<code>checkUpdateDataIds()</code>方法，从<code>diamond-server</code>获取值变化了的DataID+Group列表<code>changedGroupKeys</code></li>
<li>遍历<code>changedGroupKeys</code>，调用<code>getServerConfig()</code>获取最新的配置数据，更新<code>CacheData</code>对象内容</li>
</ul>
</li>
<li><p>遍历<code>CacheData</code>，比对新老md5是否变化，如果有变化，则通知监听器更新</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;CacheData&gt; cacheDatas = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CacheData&gt;();</span><br><span class="line">        <span class="comment">// 1. 遍历所有CacheData，检查本地容灾文件</span></span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : env.getAllCacheDataSnapshot()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cacheData.getTaskId() == taskId) &#123;</span><br><span class="line">                cacheDatas.add(cacheData);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.1 检查本地容灾文件</span></span><br><span class="line">                    checkLocalConfig(env, cacheData);</span><br><span class="line">                    <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                        <span class="comment">// 1.2 如果使用本地数据，那么检查md5是否变化，如果变化，则通知监听器</span></span><br><span class="line">                        cacheData.checkListenerMd5();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;DIAMOND-CLIENT&quot;</span>, <span class="string">&quot;get local config info error&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; inInitializingCacheList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 2.1 然后检查服务端数据是否有变化</span></span><br><span class="line">        List&lt;String&gt; changedGroupKeys = checkUpdateDataIds(cacheDatas, inInitializingCacheList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 遍历有变化的配置，获取变化后的最新数据并更新cacheData</span></span><br><span class="line">        <span class="keyword">for</span> (String groupKey : changedGroupKeys) &#123;</span><br><span class="line">            String key[] = GroupKey.parseKey(groupKey);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> key[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> key[<span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">3</span>) &#123;</span><br><span class="line">                tenant = key[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取服务端配置数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> getServerConfig(env, dataId, group, tenant, <span class="number">3000L</span>);</span><br><span class="line">                <span class="type">CacheData</span> <span class="variable">cache</span> <span class="operator">=</span> env.getCache(dataId, group, tenant);</span><br><span class="line">                <span class="comment">// 更新cacheData</span></span><br><span class="line">                cache.setContent(content);</span><br><span class="line">                log.info(env.getName(), <span class="string">&quot;[data-received] dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;&quot;</span>, dataId,</span><br><span class="line">                        group, tenant, cache.getMd5(), ContentUtils.truncateContent(content));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (DiamondException ioe) &#123;</span><br><span class="line">                log.error(env.getName(), <span class="string">&quot;DIAMOND-XXXX&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;[get-update] get changed config exception. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, msg=&#123;&#125;&quot;</span>,</span><br><span class="line">                        dataId, group, tenant, ioe.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 遍历CacheData，比对新老md5是否变化，如果有变化，则通知监听器更新</span></span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">            <span class="comment">// cacheData.checkListenerMd5();</span></span><br><span class="line">            <span class="keyword">if</span> (!cacheData.isInitializing() || inInitializingCacheList</span><br><span class="line">                    .contains(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant))) &#123;</span><br><span class="line">                <span class="comment">// 比较md5，如果变化则通知监听器</span></span><br><span class="line">                cacheData.checkListenerMd5();</span><br><span class="line">                cacheData.setInitializing(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inInitializingCacheList.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;500&quot;</span>, <span class="string">&quot;longPulling error&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-2-本地容灾配置检查"><a href="#2-3-2-2-本地容灾配置检查" class="headerlink" title="2.3.2.2 本地容灾配置检查"></a>2.3.2.2 本地容灾配置检查</h4><p>主流程第一步会遍历所有的缓存数据对象<code>CacheData</code>，检查本地容灾文件数据，判断是否要优先从本地容灾文件读取。</p>
<p>在<code>checkLocalConfig()</code>中实现检查逻辑，其中会涉及到本地容灾标志位<code>isUseLocalConfigInfo</code>、本地容灾时间戳、md5的修改。分几类情况：</p>
<ol>
<li><p>标志位false，但存在容灾文件</p>
<blockquote>
<p>cacheData刚刚初始化，并且本地容灾文件存在的情况下，每次都会优先从本地容灾文件读取对应的配置信息，并且需要通知监听业务，同时把标志是否使用本地容灾文件isUseLocalConfig设为true</p>
</blockquote>
</li>
<li><p>标志位true，但不存在容灾文件</p>
<blockquote>
<p>原来应用程序从本地的容灾文件读取对应的配置内容，出于别的原因，容灾文件被删除了，因此，每次读取对应的配置内容都会从Diamond服务端获取，并且接受server端的配置变更，对应的是否使用本地容灾文件isUseLocalConfig设为false</p>
</blockquote>
</li>
<li><p>标志位true，存在容灾文件且有变更</p>
<blockquote>
<p>本地容灾文件有可能被修改，需要重新设置cacheData的版本</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查本地容灾文件。及时修改是否使用本地容灾标志位，本地容灾时间戳和md5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkLocalConfig</span><span class="params">(DiamondEnv env, CacheData cacheData)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> cacheData.dataId;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> cacheData.group;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> cacheData.tenant;</span><br><span class="line">    <span class="type">File</span> <span class="variable">path</span> <span class="operator">=</span> LocalConfigInfoProcessor.getFailoverFile(env, dataId, group, tenant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1：没有 -&gt; 有</span></span><br><span class="line">    <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo() &amp;&amp; path.exists()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> LocalConfigInfoProcessor.getFailover(env, dataId, group, tenant);</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> MD5.getInstance().getMD5String(content);</span><br><span class="line">        cacheData.setUseLocalConfigInfo(<span class="literal">true</span>);</span><br><span class="line">        cacheData.setLocalConfigInfoVersion(path.lastModified());</span><br><span class="line">        cacheData.setContent(content);</span><br><span class="line"></span><br><span class="line">        log.warn(env.getName(),</span><br><span class="line">                <span class="string">&quot;[failover-change] failover file created. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;&quot;</span>,</span><br><span class="line">                dataId, group, tenant, md5, ContentUtils.truncateContent(content));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：有 -&gt; 没有。不通知业务监听器，从server拿到配置后通知。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; !path.exists()) &#123;</span><br><span class="line">        cacheData.setUseLocalConfigInfo(<span class="literal">false</span>);</span><br><span class="line">        log.warn(env.getName(), <span class="string">&quot;[failover-change] failover file deleted. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;&quot;</span>, dataId,</span><br><span class="line">                group, tenant);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况3：有变更</span></span><br><span class="line">    <span class="keyword">if</span> (cacheData.isUseLocalConfigInfo() &amp;&amp; path.exists()</span><br><span class="line">            &amp;&amp; cacheData.getLocalConfigInfoVersion() != path.lastModified()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> LocalConfigInfoProcessor.getFailover(env, dataId, group, tenant);</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> MD5.getInstance().getMD5String(content);</span><br><span class="line">        cacheData.setUseLocalConfigInfo(<span class="literal">true</span>);</span><br><span class="line">        cacheData.setLocalConfigInfoVersion(path.lastModified());</span><br><span class="line">        cacheData.setContent(content);</span><br><span class="line"></span><br><span class="line">        log.warn(env.getName(),</span><br><span class="line">                <span class="string">&quot;[failover-change] failover file changed. dataId=&#123;&#125;, group=&#123;&#125;, tenant=&#123;&#125;, md5=&#123;&#125;, content=&#123;&#125;&quot;</span>,</span><br><span class="line">                dataId, group, tenant, md5, ContentUtils.truncateContent(content));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-3-服务端数据变化查询"><a href="#2-3-2-3-服务端数据变化查询" class="headerlink" title="2.3.2.3 服务端数据变化查询"></a>2.3.2.3 服务端数据变化查询</h4><p>在<code>checkUpdateDataIds()</code>中实现。查询时，需要将需要感知的数据拼接为参数(即所有的dataId+group)。服务端解析后判断对应的dataId+group数据是否有变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateDataIds</span><span class="params">(List&lt;CacheData&gt; cacheDatas, List&lt;String&gt; inInitializingCacheList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (MockServer.isTestMode()) &#123;</span><br><span class="line">		<span class="comment">// 省略test mode部分</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">                <span class="comment">// 拼接dataId和group</span></span><br><span class="line">                sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class="line">                sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class="line">                    sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class="line">                    sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cacheData.isInitializing()) &#123;</span><br><span class="line">                    <span class="comment">// cacheData 首次出现在cacheMap中&amp;首次check更新</span></span><br><span class="line">                    inInitializingCacheList</span><br><span class="line">                            .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isInitializingCacheList</span> <span class="operator">=</span> !inInitializingCacheList.isEmpty();</span><br><span class="line">        <span class="comment">// 调用checkUpdateConfigStr，传递拼接后的参数</span></span><br><span class="line">        <span class="keyword">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际调用<code>checkUpdateConfigStr()</code>访问<code>diamond-server</code>获取变化了的DataID列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从DiamondServer获取值变化了的DataID列表。返回的对象里只有dataId和group是有效的。 保证不返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">checkUpdateConfigStr</span><span class="params">(String probeUpdateString, <span class="type">boolean</span> isInitializingCacheList)</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; params = Arrays.asList(Constants.PROBE_MODIFY_REQUEST, probeUpdateString);</span><br><span class="line">    <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> TimeUnit.SECONDS.toMillis(<span class="number">30L</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略请求头参数构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// POST请求，参数即所有dataID和group</span></span><br><span class="line">        <span class="type">HttpResult</span> <span class="variable">result</span> <span class="operator">=</span> env.agent.httpPost(<span class="string">&quot;/config.co&quot;</span>, headers, params, Constants.ENCODE, timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpURLConnection.HTTP_OK == result.code) &#123;</span><br><span class="line">            setHealthServer(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 请求成功后解析返回的响应，返回数据为变化了的dataId的list</span></span><br><span class="line">            <span class="keyword">return</span> parseUpdateDataIdResponse(env, result.content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 省略错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// 省略异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-4-md5校验"><a href="#2-3-2-4-md5校验" class="headerlink" title="2.3.2.4 md5校验"></a>2.3.2.4 md5校验</h4><p>从本地容灾文件或者服务端获取的数据都会缓存在<code>CacheData</code>的<code>content</code>字段中，在更新<code>content</code>字段时，同事会计算md5。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheData#setContent</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String newContent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = newContent;</span><br><span class="line">    <span class="built_in">this</span>.md5 = getMd5String(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一次的md5则保存在监听器包装对象<code>ManagerListenerWrap</code>的<code>lastCallMd5</code>字段里，通过比较这两个md5的值就可以知道数据是否有变化。</p>
<p>如果比较发现有变化，则通过调用<code>safeNotifyListener()</code>来通知监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheData#checkListenerMd5</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkListenerMd5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (ManagerListenerWrap wrap : listeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!md5.equals(wrap.lastCallMd5)) &#123;</span><br><span class="line">            safeNotifyListener(env, dataId, group, content, md5, wrap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-5-监听器回调"><a href="#2-3-2-5-监听器回调" class="headerlink" title="2.3.2.5 监听器回调"></a>2.3.2.5 监听器回调</h4><p>配置数据的md5变化后，会通过<code>safeNotifyListener()</code>通知监听器。</p>
<p>这一步会判断监听器是否提供了线程池<code>executor</code>，如果提供的话会交给<code>executor</code>异步执行回调动作，否则在当前线程回调。如果回调方法比较耗时，建议使用异步方式，避免阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">safeNotifyListener</span><span class="params">(<span class="keyword">final</span> DiamondEnv env, <span class="keyword">final</span> String dataId, <span class="keyword">final</span> String group, <span class="keyword">final</span> String content,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String md5, <span class="keyword">final</span> ManagerListenerWrap listenerWrap)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ManagerListener</span> <span class="variable">listener</span> <span class="operator">=</span> listenerWrap.listener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键逻辑都在run()方法中</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">job</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">diamondClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            ClassLoader appClassLoader= listener.getClass().getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(listener <span class="keyword">instanceof</span> SharedManagerListenerAdapter)&#123;</span><br><span class="line">                    <span class="type">SharedManagerListenerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> (SharedManagerListenerAdapter) listener;</span><br><span class="line">                    adapter.fillContext(dataId, group);</span><br><span class="line">                    log.info(env.getName(), <span class="string">&quot;[notify-context] dataId=&#123;&#125;, group=&#123;&#125;, md5=&#123;&#125;&quot;</span>, dataId, group, md5);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行回调之前先将线程classloader设置为具体webapp的classloader，以免回调方法中调用spi接口是出现异常或错用（多应用部署才会有该问题）。</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(appClassLoader);</span><br><span class="line"></span><br><span class="line">                <span class="type">ConfigResponse</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigResponse</span>();</span><br><span class="line">                cr.setDataId(dataId);</span><br><span class="line">                cr.setGroup(group);</span><br><span class="line">                cr.setContent(content);</span><br><span class="line">                env.getConfigFilterChainManager().doFilter(<span class="literal">null</span>, cr);</span><br><span class="line">                <span class="type">String</span> <span class="variable">contentTmp</span> <span class="operator">=</span> cr.getContent();</span><br><span class="line">                <span class="comment">// 关键步骤：回调</span></span><br><span class="line">                listener.receiveConfigInfo(contentTmp);</span><br><span class="line">                <span class="comment">// 关键步骤：更新lastCallMd5值</span></span><br><span class="line">                listenerWrap.lastCallMd5 = md5;</span><br><span class="line">                log.info(</span><br><span class="line">                        env.getName(),</span><br><span class="line">                        <span class="string">&quot;[notify-ok] dataId=&#123;&#125;, group=&#123;&#125;, md5=&#123;&#125;, listener=&#123;&#125; &quot;</span>,</span><br><span class="line">                        dataId, group, md5, listener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (DiamondException de) &#123;</span><br><span class="line">				<span class="comment">// 省略</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">				<span class="comment">// 省略</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(diamondClassLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 如果监听器指定了线程池executor，则交给executor异步执行</span></span><br><span class="line">         <span class="comment">// 否则使用本线程执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != listener.getExecutor()) &#123;</span><br><span class="line">            listener.getExecutor().execute(job);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            job.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-diamond-server实现"><a href="#3-diamond-server实现" class="headerlink" title="3 diamond-server实现"></a>3 diamond-server实现</h1><h2 id="3-1-获取配置"><a href="#3-1-获取配置" class="headerlink" title="3.1 获取配置"></a>3.1 获取配置</h2><p><code>diamond-client</code>使用<code>Diamond#getConfig</code>时，使用HTTP GET访问<code>diamond-server</code>的<code>/config.co</code>（或<code>/config.do</code>）。对应<code>ConfigServlet</code>。</p>
<p>内部调用<code>ConfigServletInner#doGetConfig</code>获取配置。根据开关<code>isSingleMode</code>（猜测是否单点的配置，默认false），会从数据库或者缓存文件（默认）读取配置返回给客户端。</p>
<p>注：这部分的实现代码结构上比较凌乱，另外存在一些小问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    </span><br><span class="line">    inner.doGetConfig(request, response, dataId, group, tenant, tag, clientIp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步配置获取接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doGetConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String dataId, String group,</span></span><br><span class="line"><span class="params">        String tenant, String tag, String clientIp)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 由dataId、group、tenant生成唯一groupKey，对应唯一的配置数据</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupKey</span> <span class="operator">=</span> GroupKey2.getKey(dataId, group, tenant);</span><br><span class="line">    <span class="type">String</span> <span class="variable">autoTag</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestIpApp</span> <span class="operator">=</span> RequestUtil.getAppName(request);</span><br><span class="line">    <span class="comment">// 读写锁做并发保护，这个锁是CacheItem级别的，并不是全局的，只锁对应的groupKey数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lockResult</span> <span class="operator">=</span> tryConfigReadLock(request, response, groupKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requestIp</span> <span class="operator">=</span> RequestUtil.getRemoteIp(request);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBeta</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (lockResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 结构很长的一段代码，很难理清，需要重构下</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键代码片段</span></span><br><span class="line">        <span class="comment">// singleMode时从数据库读取，否则从磁盘读取文件</span></span><br><span class="line">        <span class="keyword">if</span> (PropertyUtil.isSingleMode()) &#123;</span><br><span class="line">            configInfoBase = persistService.findConfigInfo4Tag(dataId, group, tenant, tag);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            file = DiskUtil.targetTagFile(dataId, group, tenant, tag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 设置响应头，主要是禁用缓存</span></span><br><span class="line">        response.setHeader(Constants.CONTENT_MD5, md5);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>); <span class="comment">// 禁用缓存</span></span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache,no-store&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PropertyUtil.isSingleMode()) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Last-Modified&quot;</span>, lastModified);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Last-Modified&quot;</span>, file.lastModified());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (PropertyUtil.isSingleMode()) &#123;</span><br><span class="line">            out = response.getWriter();</span><br><span class="line">            out.print(configInfoBase.getContent());</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fis.getChannel().transferTo(<span class="number">0L</span>, fis.getChannel().size(),</span><br><span class="line">                    Channels.newChannel(response.getOutputStream()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            releaseConfigReadLock(groupKey);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != fis) fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lockResult == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 省略</span></span><br><span class="line">    	<span class="comment">// 找不到CacheItem对应的数据，返回404</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 省略</span></span><br><span class="line">    	<span class="comment">// 读写冲突，返回409</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回响应，这里的一个问题是数字转字符串的方式</span></span><br><span class="line">    <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-获取数据变化"><a href="#3-2-获取数据变化" class="headerlink" title="3.2 获取数据变化"></a>3.2 获取数据变化</h2><h3 id="3-2-1-主体流程"><a href="#3-2-1-主体流程" class="headerlink" title="3.2.1 主体流程"></a>3.2.1 主体流程</h3><p>这一部分的核心是<code>diamond-server</code>对长轮询的处理。<code>diamond-client</code>使用HTTP长轮询机制从<code>diamond-server</code>获取值变化了的DataID+Group列表，对应对<code>/config.co</code>发起的HTTP POST请求。</p>
<p><strong>客户端:</strong></p>
<p>首先客户端通过设置请求头<code>longPullingTimeout</code>（默认30s）来告诉服务端使用长轮询处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `diamond-client`代码，发送长轮询请求时设置请求头</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> TimeUnit.SECONDS.toMillis(<span class="number">30L</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; headers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">headers.add(<span class="string">&quot;longPullingTimeout&quot;</span>);</span><br><span class="line">headers.add(<span class="string">&quot;&quot;</span> + timeout);</span><br></pre></td></tr></table></figure>

<p>然后客户端在请求参数中带上每个感兴趣配置的dataId+group+md5。参考<code>ClientWorker#checkUpdateDataIds</code>。服务端解析这组参数，通过计算服务端数据的md5与客户端md5比较来感知是否需要推送数据变化给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientWorker#checkUpdateDataIds</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (CacheData cacheData : cacheDatas) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cacheData.isUseLocalConfigInfo()) &#123;</span><br><span class="line">        sb.append(cacheData.dataId).append(WORD_SEPARATOR);</span><br><span class="line">        sb.append(cacheData.group).append(WORD_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(cacheData.tenant)) &#123;</span><br><span class="line">            sb.append(cacheData.getMd5()).append(LINE_SEPARATOR);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(cacheData.getMd5()).append(WORD_SEPARATOR);</span><br><span class="line">            sb.append(cacheData.getTenant()).append(LINE_SEPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheData.isInitializing()) &#123;</span><br><span class="line">            <span class="comment">// cacheData 首次出现在cacheMap中&amp;首次check更新</span></span><br><span class="line">            inInitializingCacheList</span><br><span class="line">                    .add(GroupKey.getKeyTenant(cacheData.dataId, cacheData.group, cacheData.tenant));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInitializingCacheList</span> <span class="operator">=</span> !inInitializingCacheList.isEmpty();</span><br><span class="line"><span class="keyword">return</span> checkUpdateConfigStr(sb.toString(), isInitializingCacheList);</span><br></pre></td></tr></table></figure>



<p><strong>服务端：</strong></p>
<p><code>diamond-server</code>在<code>ConfigServletInner#doPollingConfig</code>中判断处理长轮询请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">doPollingConfig</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Map&lt;String, String&gt; clientMd5Map, <span class="type">int</span> probeRequestSize)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长轮询</span></span><br><span class="line">    <span class="keyword">if</span> (LongPullingService.isSupportLongPulling(request)) &#123;</span><br><span class="line">        longPullingService.addLongPullingClient(request, response, clientMd5Map, probeRequestSize);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_OK + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// else 兼容短轮询逻辑</span></span><br><span class="line">    <span class="comment">// 省略兼容代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>底层调用<code>LongPullingService#addLongPullingClient</code>来对长轮询请求进行处理：</p>
<ol>
<li>调用<code>ConfigController#compareMd5</code>判断是否有md5改动，即是否有配置数据变更；</li>
<li>如果有数据变化，调用<code>ConfigController#compareMd5ResultString</code>生成响应数据返回响应给客户端，客户端借此来解析哪些dataId+group上发生了数据变化；</li>
<li>如果没有数据变化，那么通过Servlet 3.0的异步响应<code>AsyncContext</code>机制，在后台启动任务<code>ClientLongPulling</code>来负责生成异步响应。<code>ClientLongPulling</code>异步任务中会再启动一个定时任务，在超时时间（通过长轮询时间计算）到后，返回响应给客户端；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LongPullingService#addLongPullingClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLongPullingClient</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp, Map&lt;String, String&gt; clientMd5Map, <span class="type">int</span> probeRequestSize)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> req.getHeader(LongPullingService.LONG_PULLING_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">noHangUpFlag</span> <span class="operator">=</span> req.getHeader(LongPullingService.LONG_PULLING_NO_HANG_UP_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> req.getHeader(RequestUtil.CLIENT_APPNAME_HEADER);</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">    <span class="type">int</span> delayTime=SwitchService.getSwitchInteger(SwitchService.FIXED_DELAY_TIME, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 计算timeout，用于ClientLongPulling中设置定时任务时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> Math.max(<span class="number">10000</span>, Long.parseLong(str) - delayTime); <span class="comment">// 提前500ms返回响应，为避免客户端超时 @qiaoyi.dingqy 2013.10.22改动  add delay time for LoadBalance</span></span><br><span class="line">    <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">        timeout = Math.max(<span class="number">10000</span>, getFixedPollingInterval());</span><br><span class="line">        <span class="comment">// do nothing but set fix polling timeout</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 1. 判断是否有数据变化</span></span><br><span class="line">        List&lt;String&gt; changedGroups = ConfigController.compareMd5(req, rsp, clientMd5Map);</span><br><span class="line">        <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 有数据变化，生成变化的group列表，返回响应给客户端</span></span><br><span class="line">            generateResponse(req, rsp, changedGroups);</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;System.currentTimeMillis() - start, <span class="string">&quot;instant&quot;</span>, RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                            clientMd5Map.size(), probeRequestSize, changedGroups.size()&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(noHangUpFlag!=<span class="literal">null</span> &amp;&amp; noHangUpFlag.equalsIgnoreCase(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">            LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;System.currentTimeMillis() - start, <span class="string">&quot;nohangup&quot;</span>, RequestUtil.getRemoteIp(req), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                            clientMd5Map.size(), probeRequestSize, changedGroups.size()&#125;); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> RequestUtil.getRemoteIp(req);</span><br><span class="line">    <span class="comment">// 一定要由HTTP线程调用，否则离开后容器会立即发送响应</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line">    <span class="comment">// AsyncContext.setTimeout()的超时时间不准，所以只能自己控制</span></span><br><span class="line">    asyncContext.setTimeout(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 没有数据变化，后台启动ClientLongPulling任务</span></span><br><span class="line">    scheduler.execute(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClientLongPulling</span>(asyncContext, clientMd5Map, ip, probeRequestSize, timeout, appName, tag));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-比较md5"><a href="#3-2-2-比较md5" class="headerlink" title="3.2.2 比较md5"></a>3.2.2 比较md5</h3><p>在<code>ConfigController#compareMd5</code>中完成md5的比较。</p>
<ol>
<li><p>遍历每个客户端传递的md5，判断是否有更新，如果有更新的话，将<code>groupKey</code>加到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">compareMd5</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                      HttpServletResponse response, Map&lt;String, String&gt; clientMd5Map)</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; changedGroupKeys = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Vipserver-Tag&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : clientMd5Map.entrySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientMd5</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> RequestUtil.getRemoteIp(request);</span><br><span class="line">        <span class="comment">// 调用ConfigService.isUptodate判断是否md5有变化，返回true表示数据无变化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUptodate</span> <span class="operator">=</span> ConfigService.isUptodate(groupKey, clientMd5, ip, tag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isUptodate) &#123;</span><br><span class="line">            <span class="comment">// 如果md5有变化，则加到返回结果中</span></span><br><span class="line">            changedGroupKeys.add(groupKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changedGroupKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><code>ConfigService#isUptodate</code>实现md5比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigService#isUptodate</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUptodate</span><span class="params">(String groupKey, String md5, String ip, String tag)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serverMd5</span> <span class="operator">=</span> ConfigService.getContentMd5(groupKey, ip, tag);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.equals(md5, serverMd5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ConfigService#getContentMd5</code>从缓存数据<code>CacheItem</code>中获得服务端数据的md5值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigService#getContentMd5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> String <span class="title function_">getContentMd5</span><span class="params">(String groupKey, String ip, String tag)</span> &#123;</span><br><span class="line">    <span class="type">CacheItem</span> <span class="variable">item</span> <span class="operator">=</span> cache.get(groupKey);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; item.isBeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.ips4Beta.contains(ip)) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.md54Beta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; item.tagMd5 != <span class="literal">null</span> &amp;&amp; item.tagMd5.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(tag) &amp;&amp; item.tagMd5.containsKey(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> item.tagMd5.get(tag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">null</span> != item) ? item.md5 : Constants.NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-2-3-ClientLongPulling"><a href="#3-2-3-ClientLongPulling" class="headerlink" title="3.2.3 ClientLongPulling"></a>3.2.3 ClientLongPulling</h3><p><code>ClientLongPulling</code>实现了<code>Runnable</code>接口，在Diamond服务端收到客户端的POST长轮询请求时，会创建一个<code>ClientLongPulling</code>任务。<code>ClientLongPulling</code>的<code>run()</code>方法主要完成：</p>
<ol>
<li><p>提交一个定时任务，超时时间根据长轮询超时时间计算后设置</p>
</li>
<li><p>将<code>ClientLongPulling</code>对象保存到<code>allSubs</code>队列中</p>
<p><code>allSubs</code>对象是<code>LongPullingService</code>类的遍历，具体实现为<code>ConcurrentLinkedQueue</code>，保存了<code>ClientLongPulling</code>对象，即当前正在进行长轮询的任务。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 提交一个定时任务，超时后发回空响应给客户端</span></span><br><span class="line">    asyncTimeoutFuture = scheduler.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getRetainIps().put(ClientLongPulling.<span class="built_in">this</span>.ip, System.currentTimeMillis());</span><br><span class="line">                allSubs.remove(ClientLongPulling.<span class="built_in">this</span>); <span class="comment">// 删除订阅关系</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isFixedPolling()) &#123;</span><br><span class="line">					<span class="comment">// 省略</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;(System.currentTimeMillis() - createTime),</span><br><span class="line">                            <span class="string">&quot;timeout&quot;</span>, RequestUtil.getRemoteIp((HttpServletRequest) asyncContext.getRequest()), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                            clientMd5Map.size(), probeRequestSize&#125;);</span><br><span class="line">                    <span class="comment">// 发送空响应给客户端，参数null表示给客户端返回的响应不包含变化的groupKey</span></span><br><span class="line">                    sendResponse(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                LogUtil.defaultLog.error(<span class="string">&quot;long pulling error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, timeoutTime, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存到allSubs队列中</span></span><br><span class="line">    allSubs.add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数据没有变化，那么在定时时间到之后就会执行<code>ClientLongPulling</code>中提交的的定时任务，发回空响应给客户端，客户端发送下一个长轮询请求来监听数据变化。</p>
<p><strong>问题：</strong>如果数据变化的话，<code>ClientLongPulling</code>如何得知数据变化并进行处理？</p>
<p>几个关键点：</p>
<ol>
<li><p><code>ClientLongPulling</code>对象维护了一个定时任务的异步Future对象<code>asyncTimeoutFuture</code>，这个对象的作用在于可以用来在数据有变化时取消定时任务，及时返回响应而不是等到定时时间到。</p>
</li>
<li><p><code>ClientLongPulling</code>提供<code>sendResponse(List&lt;String&gt; changedGroups)</code>方法用于发送响应，定时任务中会通过设置参数<code>changedGroups</code>来发送一个空响应。而真正数据变更时，可以传入变更的<code>changedGroups</code>来发送响应，在里面会调用<code>asyncTimeoutFuture.cancel(false)</code>取消未开始的定时任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendResponse</span><span class="params">(List&lt;String&gt; changedGroups)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">null</span> != asyncTimeoutFuture) &#123; <span class="comment">// 取消超时任务</span></span><br><span class="line">        asyncTimeoutFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据changedGroups生产响应</span></span><br><span class="line">    generateResponse(changedGroups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LongPullingService</code>本身是一个<code>EventListener</code>，监听事件<code>LocalDataChangeEvent</code>，在数据变更时会得到通知，并启动异步任务<code>DataChangeTask</code>，在<code>DataChangeTask</code>会遍历<code>allSubs</code>中的订阅并调用对应的<code>ClientLongPulling#sendResponse</code>。</p>
</li>
</ol>
<h3 id="3-2-4-DataChangeTask"><a href="#3-2-4-DataChangeTask" class="headerlink" title="3.2.4 DataChangeTask"></a>3.2.4 DataChangeTask</h3><p>在<code>LongPullingService</code>收到数据变化事件<code>LocalDataChangeEvent</code>后启动一个<code>DataChangeTask</code>任务，给订阅的客户端返回响应。</p>
<p><code>DataChangeTask</code>的主体流程：遍历<code>allSubs</code>队列，如果客户端长轮询对象<code>ClientLongPulling</code>包含了变化数据对应的<code>groupKey</code>，则给对应客户端发回响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回cache的md5</span></span><br><span class="line">        ConfigService.getContentBetaMd5(groupKey);</span><br><span class="line">        <span class="comment">// 遍历allSubs</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;ClientLongPulling&gt; iter = allSubs.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">ClientLongPulling</span> <span class="variable">clientSub</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// clientSub订阅的数据中包含了变化数据对应的groupKey</span></span><br><span class="line">            <span class="keyword">if</span> (clientSub.clientMd5Map.containsKey(groupKey)) &#123;</span><br><span class="line">				<span class="comment">// 省略</span></span><br><span class="line"></span><br><span class="line">                getRetainIps().put(clientSub.ip, System.currentTimeMillis());</span><br><span class="line">                iter.remove(); <span class="comment">// 删除订阅关系</span></span><br><span class="line">                LogUtil.clientLog.info(<span class="string">&quot;&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;|&#123;&#125;&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;(System.currentTimeMillis() - changeTime),</span><br><span class="line">                                <span class="string">&quot;in-advance&quot;</span>, RequestUtil.getRemoteIp((HttpServletRequest) clientSub.asyncContext.getRequest()), <span class="string">&quot;polling&quot;</span>,</span><br><span class="line">                                clientSub.clientMd5Map.size(), clientSub.probeRequestSize, groupKey&#125;);</span><br><span class="line">                <span class="comment">// 给对应的客户端写回响应，调用sendResponse()方法实现</span></span><br><span class="line">                clientSub.sendResponse(Arrays.asList(groupKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        LogUtil.defaultLog.error(<span class="string">&quot;data change error:&quot;</span> + t.getMessage(), t.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-数据变更监听"><a href="#3-2-5-数据变更监听" class="headerlink" title="3.2.5 数据变更监听"></a>3.2.5 数据变更监听</h3><p><code>diamond-server</code>使用了和ConfigServer一模一样的事件监听机制，通过<code>Event</code>、<code>EventListener</code>和<code>EventDispatcher</code>构建。</p>
<p>数据变更的监听处理即在数据变化时，通过<code>EventDispatcher</code>派发<code>LocalDataChangeEvent</code>事件给<code>LongPullingService</code>实现。</p>
<p>在<code>ConfigService</code>中有几个地方会调用<code>EventDispatcher</code>派发<code>LocalDataChangeEvent</code>，主要有：</p>
<ol>
<li>定时从数据库dump所有数据，有数据变化</li>
<li>集群中其他节点收到客户端发布的配置，通知到本节点</li>
</ol>
<h2 id="3-3-发布配置"><a href="#3-3-发布配置" class="headerlink" title="3.3 发布配置"></a>3.3 发布配置</h2><p>当一个客户端发布配置后，<code>diamond-server</code>关键做了两步：</p>
<ol>
<li>将数据插入或更新到数据库，持久化保存</li>
<li>通知其他节点数据变更事件，其他节点收到事件后</li>
</ol>
<h3 id="3-3-1-主体流程"><a href="#3-3-1-主体流程" class="headerlink" title="3.3.1 主体流程"></a>3.3.1 主体流程</h3><p><code>diamond-client</code>调用发布配置时，会访问<code>diamond-server</code>的对应接口，主要有：</p>
<ul>
<li>非聚合数据：<code>/basestone.do?method=syncUpdateAll</code></li>
<li>聚合数据：<code>/datum.do?method=addDatum</code></li>
</ul>
<p>以非聚合数据为例，<code>diamond-server</code>在<code>com.taobao.diamond.server.controller.BaseStoneController#syncUpdateAll</code>中进行处理。主体流程：</p>
<ol>
<li>如果请求中带有md5参数，则调用<code>updateConfigCas</code>，否则调用<code>syncUpdateConfigAll</code>，以<code>syncUpdateConfigAll</code>为例</li>
<li>参数校验，其中会校验是否发布聚合数据，如果是的话会拒绝发布</li>
<li><strong>关键步骤：</strong>插入或更新数据库数据，调用<code>persistService.insertOrUpdate</code></li>
<li><strong>关键步骤：</strong>派发<code>ConfigDataChangeEvent</code>事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加或更新非聚合数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(params = &quot;method=syncUpdateAll&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">syncUpdateAll</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(&quot;dataId&quot;)</span> String dataId, <span class="meta">@RequestParam(&quot;group&quot;)</span> String group, <span class="meta">@RequestParam(&quot;content&quot;)</span> String content,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;md5&quot;, required = false)</span> String md5,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;appName&quot;, required = false)</span> String appName,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;src_user&quot;, required = false)</span> String srcUser,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;tenant&quot;, required = false, defaultValue = StringUtils.EMPTY)</span> String tenant,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@RequestParam(value = &quot;tag&quot;, required = false)</span> String tag, ModelMap modelMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据是否携带md5参数调用不同的更新方法</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(md5)) &#123;</span><br><span class="line">        <span class="keyword">return</span> syncUpdateConfigAll(request, response, dataId, group, content, appName, srcUser, tenant, tag, modelMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> updateConfigCas(request, response, dataId, group, content, md5, appName, srcUser, tenant, tag, modelMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加或更新非聚合数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">syncUpdateConfigAll</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   String dataId, String group, String content, String appName, String srcUser,</span></span><br><span class="line"><span class="params">                                   String tenant, String tag, ModelMap modelMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">srcIp</span> <span class="operator">=</span> RequestUtil.getRemoteIp(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestIpApp</span> <span class="operator">=</span> RequestUtil.getAppName(request);</span><br><span class="line">    <span class="keyword">if</span> (!checkParam(dataId, group, <span class="string">&quot;datumId&quot;</span>, content, response, modelMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/common/error_message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkParam(tag, response, modelMap)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/common/error_message&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断发布的dataId是否在聚合dataId白名单中</span></span><br><span class="line">    <span class="keyword">if</span> (AggrWhitelist.isAggrDataId(dataId)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;[aggr-conflict] &#123;&#125; attemp to publish single data, &#123;&#125;, &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;</span><br><span class="line">                RequestUtil.getRemoteIp(request), dataId, group &#125;);</span><br><span class="line"></span><br><span class="line">        modelMap.addAttribute(<span class="string">&quot;content&quot;</span>, dataId + <span class="string">&quot; IS aggr&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_FORBIDDEN + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Timestamp</span> <span class="variable">time</span> <span class="operator">=</span> TimeUtils.getCurrentTime();</span><br><span class="line">    <span class="type">SpasAuthorityResult</span> <span class="variable">hasRight</span> <span class="operator">=</span> privilegeService.hasRight(request, dataId, group, tenant, srcIp,</span><br><span class="line">            PrivilegeService.WRITE_READ_PRIVILEGE);</span><br><span class="line">    <span class="keyword">if</span> (!hasRight.getResult()) &#123;</span><br><span class="line">        Object[] objectAgrr = &#123; dataId, group, srcIp &#125;;</span><br><span class="line">        log.error(<span class="string">&quot;no right:dataId=&#123;&#125;,group=&#123;&#125;,requestIp=&#123;&#125;&quot;</span>,</span><br><span class="line">                objectAgrr);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        <span class="keyword">return</span> HttpServletResponse.SC_FORBIDDEN + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">betaIps</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;betaIps&quot;</span>);</span><br><span class="line">    <span class="type">ConfigInfo</span> <span class="variable">configInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigInfo</span>(dataId, group, tenant, appName, content);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(betaIps)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(tag)) &#123;</span><br><span class="line">            <span class="comment">// 插入或更新数据库数据</span></span><br><span class="line">            persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 派发ConfigDataChangeEvent事件</span></span><br><span class="line">            EventDispatcher.fireEvent(<span class="keyword">new</span> <span class="title class_">ConfigDataChangeEvent</span>(<span class="literal">false</span>, dataId, group, tenant, time.getTime()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            persistService.insertOrUpdateTag(configInfo, tag, srcIp, srcUser, time, <span class="literal">false</span>);</span><br><span class="line">            EventDispatcher.fireEvent(<span class="keyword">new</span> <span class="title class_">ConfigDataChangeEvent</span>(<span class="literal">false</span>, dataId, group, tenant, tag, time.getTime()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// beta publish</span></span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回OK响应</span></span><br><span class="line">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(HttpServletResponse.SC_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-通知其他节点"><a href="#3-3-2-通知其他节点" class="headerlink" title="3.3.2 通知其他节点"></a>3.3.2 通知其他节点</h3><p>派发<code>ConfigDataChangeEvent</code>事件后，会由<code>AsyncNotifyService</code>进行处理。在<code>onEvent()</code>方法中，将当前节点列表<code>ipList</code>添加到一个<code>queue</code>中，异步执行<code>AsyncTask</code>来通知。</p>
<p>注：节点列表通过<code>ServerListService.getServerList()</code>获取，机制与ConfigServer一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发产生 ConfigDataChangeEvent</span></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ConfigDataChangeEvent) &#123;</span><br><span class="line">        <span class="type">ConfigDataChangeEvent</span> <span class="variable">evt</span> <span class="operator">=</span> (ConfigDataChangeEvent) event;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dumpTs</span> <span class="operator">=</span> evt.lastModifiedTs;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> evt.dataId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> evt.group;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> evt.tenant;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> evt.tag;</span><br><span class="line">        List&lt;?&gt; ipList = ServerListService.getServerList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其实这里任何类型队列都可以</span></span><br><span class="line">        Queue&lt;NotifySingleTask&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;NotifySingleTask&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ipList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 构造一个NotifySingleTask对象放到queue中</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">NotifySingleTask</span>(dataId, group, tenant, tag, dumpTs, (String) ipList.get(i), evt.isBeta));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步执行AsyncTask，通知queue中的节点</span></span><br><span class="line">        excutor.execute(<span class="keyword">new</span> <span class="title class_">AsyncTask</span>(httpclient, queue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>AsyncTask</code>中完成从节点列表<code>queue</code>中获取节点并且发送通知的过程。通知实际上是给对应节点的<code>/notify.do?method=notifyConfigInfo</code>接口发送HTTP GET请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    executeAsyncInvoke();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeAsyncInvoke</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">// 从queue中依次取出NotifySingleTask</span></span><br><span class="line">        <span class="type">NotifySingleTask</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetIp</span> <span class="operator">=</span> task.getTargetIP();</span><br><span class="line">        <span class="keyword">if</span> (ServerListService.getServerList().contains(</span><br><span class="line">                targetIp)) &#123;</span><br><span class="line">            <span class="comment">// 启动健康检查且有不监控的ip则直接把放到通知队列，否则通知</span></span><br><span class="line">            <span class="keyword">if</span> (ServerListService.isHealthCheck()</span><br><span class="line">                    &amp;&amp; ServerListService.getServerListUnhealth().contains(targetIp)) &#123;</span><br><span class="line">                <span class="comment">// target ip 不健康，则放入通知列表中</span></span><br><span class="line">                <span class="comment">// 省略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送HTTP GET请求给指定节点</span></span><br><span class="line">                <span class="type">HttpGet</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(task.url);</span><br><span class="line">                request.setHeader(NotifyService.NOTIFY_HEADER_LAST_MODIFIED,</span><br><span class="line">                        String.valueOf(task.getLastModified()));</span><br><span class="line">                request.setHeader(NotifyService.NOTIFY_HEADER_OP_HANDLE_IP, SystemConfig.LOCAL_IP);</span><br><span class="line">                request.setHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;charset=GBK&quot;</span>);</span><br><span class="line">                request.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;charset=GBK&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (task.isBeta) &#123;</span><br><span class="line">                    request.setHeader(<span class="string">&quot;isBeta&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                httpclient.execute(request, <span class="keyword">new</span> <span class="title class_">AyscNotifyCallBack</span>(httpclient, task));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送HTTP请求时设置了回调<code>AyscNotifyCallBack</code>，在回调方法中，如果请求异常<code>failed</code>或者失败（响应码不等于200），会进行重试。</p>
<h3 id="3-3-3-接收通知"><a href="#3-3-3-接收通知" class="headerlink" title="3.3.3 接收通知"></a>3.3.3 接收通知</h3><p><code>diamond-server</code>集群中，某个节点收到发布配置时，通过调用其他节点的<code>/notify.do?method=notifyConfigInfo</code>进行通知。这个接口由<code>NotifyController#notifyConfigInfo</code>方法处理。</p>
<p>处理流程：</p>
<ol>
<li><p>调用<code>DumpService#dump</code>添加一个dump任务，用于从数据库dump最新数据；</p>
</li>
<li><p>dump任务管理器<code>dumpTaskMgr</code>底层有一个<code>processingThread</code>线程从任务列表中取出任务执行，对应<code>com.taobao.diamond.notify.utils.task.TaskManager#process</code>方法；</p>
</li>
<li><p>dump任务会交给<code>DumpProcessor#process</code>执行，在其中完成：</p>
<ul>
<li>从数据库dump配置数据<code>dumpService.persistService.findConfigInfo</code></li>
<li>根据从数据库dump出来的数据，区分两种情况：<ul>
<li>有数据，则保存配置文件，并缓存md5。对应<code>ConfigService#dump</code></li>
<li>无数据（删除了配置），则删除配置文件，删除缓存。对应<code>ConfigService#remove</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(String taskType, Task task)</span> &#123;</span><br><span class="line">    <span class="type">DumpTask</span> <span class="variable">dumpTask</span> <span class="operator">=</span> (DumpTask) task;</span><br><span class="line">    String[] pair = GroupKey2.parseKey(dumpTask.groupKey);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> pair[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> pair[<span class="number">1</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">tenant</span> <span class="operator">=</span> pair[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> dumpTask.lastModified;</span><br><span class="line">    <span class="type">String</span> <span class="variable">handleIp</span> <span class="operator">=</span> dumpTask.handleIp;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBeta</span> <span class="operator">=</span> dumpTask.isBeta;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> dumpTask.tag;</span><br><span class="line">    <span class="keyword">if</span> (isBeta) &#123;</span><br><span class="line">        <span class="comment">// 省略beta发布流程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(tag)) &#123;</span><br><span class="line">            <span class="type">ConfigInfo</span> <span class="variable">cf</span> <span class="operator">=</span> dumpService.persistService.findConfigInfo(dataId, group, tenant);</span><br><span class="line">			<span class="comment">// 省略一些特殊dataId处理流程</span></span><br><span class="line">            <span class="type">boolean</span> result;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != cf) &#123;</span><br><span class="line">                <span class="comment">// 有数据的情况，保存配置文件</span></span><br><span class="line">                result = ConfigService.dump(dataId, group, tenant, cf.getContent(), lastModified);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    ConfigTraceService.logDumpEvent(dataId, group, tenant, <span class="literal">null</span>, lastModified, handleIp,</span><br><span class="line">                            ConfigTraceService.DUMP_EVENT_OK, System.currentTimeMillis() - lastModified,</span><br><span class="line">                            cf.getContent().length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无数据的情况，删除配置文件和缓存</span></span><br><span class="line">                result = ConfigService.remove(dataId, group, tenant);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                    ConfigTraceService.logDumpEvent(dataId, group, tenant, <span class="literal">null</span>, lastModified, handleIp,</span><br><span class="line">                            ConfigTraceService.DUMP_EVENT_REMOVE_OK, System.currentTimeMillis() - lastModified, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 省略有tag的流程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据第三步的两种情况（有数据or无数据），在<code>ConfigService</code>中针对性地对配置文件进行处理，例如有数据时，将从数据库dump出来的最新配置数据保存到配置文件中，下次客户端请求时，就可以从配置文件中快速读取数据返回给客户端。另外关键的一步是需要通知与该节点建立长轮询连接的客户端配置变化事件。</p>
</li>
</ol>
<h3 id="3-3-4-配置文件更新"><a href="#3-3-4-配置文件更新" class="headerlink" title="3.3.4 配置文件更新"></a>3.3.4 配置文件更新</h3><p>以数据更新时保存配置文件的情况为例，对应<code>ConfigService#dump</code>方法。其中完成两步：</p>
<ol>
<li>检查md5，如果md5有变化，保存新数据到磁盘配置文件中，并缓存md5</li>
<li>派发一个<code>LocalDataChangeEvent</code>事件，通知监听器处理，收到该事件时，会生成响应通知当前长轮询的客户端连接配置变化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存配置文件，并缓存md5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dump</span><span class="params">(String dataId, String group, String tenant, String content, <span class="type">long</span> lastModifiedTs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">groupKey</span> <span class="operator">=</span> GroupKey2.getKey(dataId, group, tenant);</span><br><span class="line">    makeSure(groupKey);</span><br><span class="line">    <span class="comment">// 获取写锁，并发保护</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">lockResult</span> <span class="operator">=</span> tryWriteLock(groupKey);</span><br><span class="line">    <span class="keyword">assert</span> (lockResult != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dumpLog.warn(<span class="string">&quot;[dump-error] write lock failed. &#123;&#125;&quot;</span>, groupKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 计算并比较新老md5</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">md5</span> <span class="operator">=</span> MD5.getInstance().getMD5String(content);</span><br><span class="line">        <span class="keyword">if</span> (md5.equals(ConfigService.getContentMd5(groupKey))) &#123;</span><br><span class="line">            dumpLog.warn(</span><br><span class="line">                    <span class="string">&quot;[dump-ignore] ignore to save cache file. groupKey=&#123;&#125;, md5=&#123;&#125;, lastModifiedOld=&#123;&#125;, lastModifiedNew=&#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; groupKey, md5, ConfigService.getLastModifiedTs(groupKey), lastModifiedTs &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!PropertyUtil.isSingleMode()) &#123;</span><br><span class="line">            <span class="comment">// md5有变化，保存到磁盘文件中</span></span><br><span class="line">            DiskUtil.saveToDisk(dataId, group, tenant, content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新缓存的md5</span></span><br><span class="line">        updateMd5(groupKey, md5, lastModifiedTs);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">		<span class="comment">// 省略</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseWriteLock(groupKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateMd5</span><span class="params">(String groupKey, String md5, <span class="type">long</span> lastModifiedTs)</span> &#123;</span><br><span class="line">    <span class="type">CacheItem</span> <span class="variable">cache</span> <span class="operator">=</span> makeSure(groupKey);</span><br><span class="line">    <span class="keyword">if</span> (cache.md5 ==<span class="literal">null</span> || !cache.md5.equals(md5)) &#123;</span><br><span class="line">        <span class="comment">// 更新缓存的md5</span></span><br><span class="line">        cache.md5 = md5;</span><br><span class="line">        cache.lastModifiedTs = lastModifiedTs;</span><br><span class="line">        <span class="comment">// 派发LocalDataChangeEvent事件</span></span><br><span class="line">        EventDispatcher.fireEvent(<span class="keyword">new</span> <span class="title class_">LocalDataChangeEvent</span>(groupKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="top-box-text">1 架构设计</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-1-%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="top-box-text">1.1 组件架构</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-2-%E7%BC%93%E5%AD%98%E5%92%8C%E5%AE%B9%E7%81%BE"><span class="top-box-text">1.2 缓存和容灾</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-3-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="top-box-text">1.3 数据同步</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-4-%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%92%8C%E5%8F%91%E5%B8%83"><span class="top-box-text">1.4 配置获取和发布</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-5-%E9%85%8D%E7%BD%AE%E6%8E%A8%E9%80%81"><span class="top-box-text">1.5 配置推送</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#1-6-%E4%B8%8EConfigServer%E6%AF%94%E8%BE%83"><span class="top-box-text">1.6 与ConfigServer比较</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#2-diamond-client%E5%AE%9E%E7%8E%B0"><span class="top-box-text">2 diamond-client实现</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="top-box-text">2.1 概述</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-2-%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="top-box-text">2.2 主要类</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#2-3-%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B"><span class="top-box-text">2.3 代码流程</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-3-1-%E6%89%8B%E5%8A%A8%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="top-box-text">2.3.1 手动获取配置</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#2-3-2-%E7%9B%91%E5%90%AC%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="top-box-text">2.3.2 监听获取配置</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#3-diamond-server%E5%AE%9E%E7%8E%B0"><span class="top-box-text">3 diamond-server实现</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-1-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="top-box-text">3.1 获取配置</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-2-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96"><span class="top-box-text">3.2 获取数据变化</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-1-%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="top-box-text">3.2.1 主体流程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-2-%E6%AF%94%E8%BE%83md5"><span class="top-box-text">3.2.2 比较md5</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-3-ClientLongPulling"><span class="top-box-text">3.2.3 ClientLongPulling</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-4-DataChangeTask"><span class="top-box-text">3.2.4 DataChangeTask</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-2-5-%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E7%9B%91%E5%90%AC"><span class="top-box-text">3.2.5 数据变更监听</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#3-3-%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE"><span class="top-box-text">3.3 发布配置</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-3-1-%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="top-box-text">3.3.1 主体流程</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-3-2-%E9%80%9A%E7%9F%A5%E5%85%B6%E4%BB%96%E8%8A%82%E7%82%B9"><span class="top-box-text">3.3.2 通知其他节点</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-3-3-%E6%8E%A5%E6%94%B6%E9%80%9A%E7%9F%A5"><span class="top-box-text">3.3.3 接收通知</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#3-3-4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0"><span class="top-box-text">3.3.4 配置文件更新</span></a></li></ol></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2020/12/09/pandora-de-she-ji-yu-shi-xian/">
          <h3 class="post-title">
            下一篇：Pandora的设计与实现
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>

